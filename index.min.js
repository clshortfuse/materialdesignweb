var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __reflectGet = Reflect.get;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};
var __superGet = (cls, obj, key) => __reflectGet(__getProtoOf(cls), key, obj);

// node_modules/element-internals-polyfill/dist/index.js
var require_dist = __commonJS({
  "node_modules/element-internals-polyfill/dist/index.js"() {
    init_polyfills();
    (function() {
      "use strict";
      const refMap = /* @__PURE__ */ new WeakMap();
      const validityMap = /* @__PURE__ */ new WeakMap();
      const hiddenInputMap = /* @__PURE__ */ new WeakMap();
      const internalsMap = /* @__PURE__ */ new WeakMap();
      const validationMessageMap = /* @__PURE__ */ new WeakMap();
      const formsMap = /* @__PURE__ */ new WeakMap();
      const shadowHostsMap = /* @__PURE__ */ new WeakMap();
      const formElementsMap = /* @__PURE__ */ new WeakMap();
      const refValueMap = /* @__PURE__ */ new WeakMap();
      const upgradeMap = /* @__PURE__ */ new WeakMap();
      const shadowRootMap = /* @__PURE__ */ new WeakMap();
      const validationAnchorMap = /* @__PURE__ */ new WeakMap();
      const documentFragmentMap = /* @__PURE__ */ new WeakMap();
      const onSubmitMap = /* @__PURE__ */ new WeakMap();
      const observerConfig$1 = { attributes: true, attributeFilter: ["disabled"] };
      const observer = new MutationObserver((mutationsList) => {
        for (const mutation of mutationsList) {
          const target = mutation.target;
          if (target.constructor["formAssociated"]) {
            const isDisabled = target.hasAttribute("disabled");
            target.toggleAttribute("internals-disabled", isDisabled);
            if (isDisabled) {
              target.setAttribute("aria-disabled", "true");
            } else {
              target.removeAttribute("aria-disabled");
            }
            if (target.formDisabledCallback) {
              target.formDisabledCallback.apply(target, [isDisabled]);
            }
          }
        }
      });
      const removeHiddenInputs = /* @__PURE__ */ __name((internals) => {
        const hiddenInputs = hiddenInputMap.get(internals);
        hiddenInputs.forEach((hiddenInput) => {
          hiddenInput.remove();
        });
        hiddenInputMap.set(internals, []);
      }, "removeHiddenInputs");
      const createHiddenInput = /* @__PURE__ */ __name((ref, internals) => {
        const input = document.createElement("input");
        input.type = "hidden";
        input.name = ref.getAttribute("name");
        ref.after(input);
        hiddenInputMap.get(internals).push(input);
        return input;
      }, "createHiddenInput");
      const initRef = /* @__PURE__ */ __name((ref, internals) => {
        hiddenInputMap.set(internals, []);
        const isDisabled = ref.hasAttribute("disabled");
        ref.toggleAttribute("internals-disabled", isDisabled);
        observer.observe(ref, observerConfig$1);
      }, "initRef");
      const initLabels = /* @__PURE__ */ __name((ref, labels) => {
        if (labels.length) {
          Array.from(labels).forEach((label) => label.addEventListener("click", ref.focus.bind(ref)));
          let firstLabelId = labels[0].id;
          if (!labels[0].id) {
            firstLabelId = `${labels[0].htmlFor}_Label`;
            labels[0].id = firstLabelId;
          }
          ref.setAttribute("aria-labelledby", firstLabelId);
        }
      }, "initLabels");
      const setFormValidity = /* @__PURE__ */ __name((form) => {
        const nativeControlValidity = Array.from(form.elements).filter((element) => element.validity).map((element) => element.validity.valid);
        const polyfilledElements = formElementsMap.get(form) || [];
        const polyfilledValidity = Array.from(polyfilledElements).filter((control) => control.isConnected).map((control) => internalsMap.get(control).validity.valid);
        const hasInvalid = [...nativeControlValidity, ...polyfilledValidity].includes(false);
        form.toggleAttribute("internals-invalid", hasInvalid);
        form.toggleAttribute("internals-valid", !hasInvalid);
      }, "setFormValidity");
      const formInputCallback = /* @__PURE__ */ __name((event) => {
        setFormValidity(findParentForm(event.target));
      }, "formInputCallback");
      const formChangeCallback = /* @__PURE__ */ __name((event) => {
        setFormValidity(findParentForm(event.target));
      }, "formChangeCallback");
      const formSubmitCallback = /* @__PURE__ */ __name((event) => {
        const form = event.target;
        const elements = formElementsMap.get(form);
        if (form.noValidate) {
          return;
        }
        if (elements.size) {
          const nodes = Array.from(elements);
          const validityList = nodes.reverse().map((node) => {
            const internals = internalsMap.get(node);
            return internals.reportValidity();
          });
          if (validityList.includes(false)) {
            event.stopImmediatePropagation();
            event.stopPropagation();
            event.preventDefault();
          } else if (onSubmitMap.get(form)) {
            const callback = onSubmitMap.get(form);
            const canceled = callback.call(form, event);
            if (canceled === false) {
              event.preventDefault();
            }
          }
        }
      }, "formSubmitCallback");
      const formResetCallback = /* @__PURE__ */ __name((event) => {
        const elements = formElementsMap.get(event.target);
        if (elements && elements.size) {
          elements.forEach((element) => {
            if (element.constructor.formAssociated && element.formResetCallback) {
              element.formResetCallback.apply(element);
            }
          });
        }
      }, "formResetCallback");
      const initForm = /* @__PURE__ */ __name((ref, form, internals) => {
        if (form) {
          if (form.onsubmit) {
            onSubmitMap.set(form, form.onsubmit.bind(form));
            form.onsubmit = null;
          }
          const formElements = formElementsMap.get(form);
          if (formElements) {
            formElements.add(ref);
          } else {
            const initSet = /* @__PURE__ */ new Set();
            initSet.add(ref);
            formElementsMap.set(form, initSet);
            form.addEventListener("submit", formSubmitCallback);
            form.addEventListener("reset", formResetCallback);
            form.addEventListener("input", formInputCallback);
            form.addEventListener("change", formChangeCallback);
          }
          formsMap.set(form, { ref, internals });
          if (ref.constructor["formAssociated"] && ref.formAssociatedCallback) {
            setTimeout(() => {
              ref.formAssociatedCallback.apply(ref, [form]);
            }, 0);
          }
          setFormValidity(form);
        }
      }, "initForm");
      const findParentForm = /* @__PURE__ */ __name((elem) => {
        let parent = elem.parentNode;
        if (parent && parent.tagName !== "FORM") {
          parent = findParentForm(parent);
        }
        return parent;
      }, "findParentForm");
      const throwIfNotFormAssociated = /* @__PURE__ */ __name((ref, message, ErrorType = DOMException) => {
        if (!ref.constructor["formAssociated"]) {
          throw new ErrorType(message);
        }
      }, "throwIfNotFormAssociated");
      const overrideFormMethod = /* @__PURE__ */ __name((form, returnValue, method) => {
        const elements = formElementsMap.get(form);
        if (elements && elements.size) {
          elements.forEach((element) => {
            const internals = internalsMap.get(element);
            const valid = internals[method]();
            if (!valid) {
              returnValue = false;
            }
          });
        }
        return returnValue;
      }, "overrideFormMethod");
      const upgradeInternals = /* @__PURE__ */ __name((ref) => {
        if (ref.constructor["formAssociated"]) {
          const internals = internalsMap.get(ref);
          const { labels, form } = internals;
          initLabels(ref, labels);
          initForm(ref, form, internals);
        }
      }, "upgradeInternals");
      const aom = {
        ariaAtomic: "aria-atomic",
        ariaAutoComplete: "aria-autocomplete",
        ariaBusy: "aria-busy",
        ariaChecked: "aria-checked",
        ariaColCount: "aria-colcount",
        ariaColIndex: "aria-colindex",
        ariaColSpan: "aria-colspan",
        ariaCurrent: "aria-current",
        ariaDisabled: "aria-disabled",
        ariaExpanded: "aria-expanded",
        ariaHasPopup: "aria-haspopup",
        ariaHidden: "aria-hidden",
        ariaKeyShortcuts: "aria-keyshortcuts",
        ariaLabel: "aria-label",
        ariaLevel: "aria-level",
        ariaLive: "aria-live",
        ariaModal: "aria-modal",
        ariaMultiLine: "aria-multiline",
        ariaMultiSelectable: "aria-multiselectable",
        ariaOrientation: "aria-orientation",
        ariaPlaceholder: "aria-placeholder",
        ariaPosInSet: "aria-posinset",
        ariaPressed: "aria-pressed",
        ariaReadOnly: "aria-readonly",
        ariaRelevant: "aria-relevant",
        ariaRequired: "aria-required",
        ariaRoleDescription: "aria-roledescription",
        ariaRowCount: "aria-rowcount",
        ariaRowIndex: "aria-rowindex",
        ariaRowSpan: "aria-rowspan",
        ariaSelected: "aria-selected",
        ariaSetSize: "aria-setsize",
        ariaSort: "aria-sort",
        ariaValueMax: "aria-valuemax",
        ariaValueMin: "aria-valuemin",
        ariaValueNow: "aria-valuenow",
        ariaValueText: "aria-valuetext",
        role: "role"
      };
      const initAom = /* @__PURE__ */ __name((ref, internals) => {
        for (let key in aom) {
          internals[key] = null;
          let closureValue = null;
          const attributeName = aom[key];
          Object.defineProperty(internals, key, {
            get() {
              return closureValue;
            },
            set(value) {
              closureValue = value;
              if (ref.isConnected) {
                ref.setAttribute(attributeName, value);
              } else {
                upgradeMap.set(ref, internals);
              }
            }
          });
        }
      }, "initAom");
      class ValidityState {
        constructor() {
          this.badInput = false;
          this.customError = false;
          this.patternMismatch = false;
          this.rangeOverflow = false;
          this.rangeUnderflow = false;
          this.stepMismatch = false;
          this.tooLong = false;
          this.tooShort = false;
          this.typeMismatch = false;
          this.valid = true;
          this.valueMissing = false;
          Object.seal(this);
        }
      }
      __name(ValidityState, "ValidityState");
      const setValid = /* @__PURE__ */ __name((validityObject) => {
        validityObject.badInput = false;
        validityObject.customError = false;
        validityObject.patternMismatch = false;
        validityObject.rangeOverflow = false;
        validityObject.rangeUnderflow = false;
        validityObject.stepMismatch = false;
        validityObject.tooLong = false;
        validityObject.tooShort = false;
        validityObject.typeMismatch = false;
        validityObject.valid = true;
        validityObject.valueMissing = false;
        return validityObject;
      }, "setValid");
      const reconcileValidity = /* @__PURE__ */ __name((validityObject, newState, form) => {
        validityObject.valid = isValid(newState);
        Object.keys(newState).forEach((key) => validityObject[key] = newState[key]);
        if (form) {
          setFormValidity(form);
        }
        return validityObject;
      }, "reconcileValidity");
      const isValid = /* @__PURE__ */ __name((validityState) => {
        let valid = true;
        for (let key in validityState) {
          if (key !== "valid" && validityState[key] !== false) {
            valid = false;
          }
        }
        return valid;
      }, "isValid");
      function initNode(node) {
        const internals = internalsMap.get(node);
        const { form } = internals;
        initForm(node, form, internals);
        initLabels(node, internals.labels);
      }
      __name(initNode, "initNode");
      function observerCallback(mutationList) {
        mutationList.forEach((mutationRecord) => {
          const { addedNodes, removedNodes } = mutationRecord;
          const added = Array.from(addedNodes);
          const removed = Array.from(removedNodes);
          added.forEach((node) => {
            if (internalsMap.has(node) && node.constructor["formAssociated"]) {
              initNode(node);
            }
            if (upgradeMap.has(node)) {
              const internals = upgradeMap.get(node);
              const aomKeys = Object.keys(aom);
              aomKeys.filter((key) => internals[key] !== null).forEach((key) => {
                node.setAttribute(aom[key], internals[key]);
              });
              upgradeMap.delete(node);
            }
            if (node.localName === "form") {
              const formElements = formElementsMap.get(node);
              const walker = document.createTreeWalker(node, NodeFilter.SHOW_ELEMENT, {
                acceptNode(node2) {
                  return internalsMap.has(node2) && !formElements && !formElements.has(node2) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
                }
              });
              let current = walker.nextNode();
              while (current) {
                initNode(current);
                current = walker.nextNode();
              }
            }
          });
          removed.forEach((node) => {
            const internals = internalsMap.get(node);
            if (internals && hiddenInputMap.get(internals)) {
              removeHiddenInputs(internals);
            }
            if (shadowHostsMap.has(node)) {
              const observer2 = shadowHostsMap.get(node);
              observer2.disconnect();
            }
          });
        });
      }
      __name(observerCallback, "observerCallback");
      function fragmentObserverCallback(mutationList) {
        mutationList.forEach((mutation) => {
          const { removedNodes } = mutation;
          removedNodes.forEach((node) => {
            const observer2 = documentFragmentMap.get(mutation.target);
            if (internalsMap.has(node)) {
              upgradeInternals(node);
            }
            observer2.disconnect();
          });
        });
      }
      __name(fragmentObserverCallback, "fragmentObserverCallback");
      const deferUpgrade = /* @__PURE__ */ __name((fragment) => {
        const observer2 = new MutationObserver(fragmentObserverCallback);
        observer2.observe(fragment, { childList: true });
        documentFragmentMap.set(fragment, observer2);
      }, "deferUpgrade");
      new MutationObserver(observerCallback);
      const observerConfig = {
        childList: true,
        subtree: true
      };
      const customStateMap = /* @__PURE__ */ new WeakMap();
      class CustomStateSet extends Set {
        static get isPolyfilled() {
          return true;
        }
        constructor(ref) {
          super();
          if (!ref || !ref.tagName || ref.tagName.indexOf("-") === -1) {
            throw new TypeError("Illegal constructor");
          }
          customStateMap.set(this, ref);
        }
        add(state) {
          if (!/^--/.test(state) || typeof state !== "string") {
            throw new DOMException(`Failed to execute 'add' on 'CustomStateSet': The specified value ${state} must start with '--'.`);
          }
          const result = super.add(state);
          const ref = customStateMap.get(this);
          ref.toggleAttribute(`state${state}`, true);
          if (ref.part) {
            ref.part.add(`state${state}`);
          }
          return result;
        }
        clear() {
          for (let [entry] of this.entries()) {
            this.delete(entry);
          }
          super.clear();
        }
        delete(state) {
          const result = super.delete(state);
          const ref = customStateMap.get(this);
          ref.toggleAttribute(`state${state}`, false);
          if (ref.part) {
            ref.part.remove(`state${state}`);
          }
          return result;
        }
      }
      __name(CustomStateSet, "CustomStateSet");
      class ElementInternals2 {
        constructor(ref) {
          if (!ref || !ref.tagName || ref.tagName.indexOf("-") === -1) {
            throw new TypeError("Illegal constructor");
          }
          const rootNode = ref.getRootNode();
          const validity = new ValidityState();
          this.states = new CustomStateSet(ref);
          refMap.set(this, ref);
          validityMap.set(this, validity);
          internalsMap.set(ref, this);
          initAom(ref, this);
          initRef(ref, this);
          Object.seal(this);
          upgradeInternals(ref);
          if (rootNode instanceof DocumentFragment) {
            deferUpgrade(rootNode);
          }
        }
        static get isPolyfilled() {
          return true;
        }
        checkValidity() {
          const ref = refMap.get(this);
          throwIfNotFormAssociated(ref, `Failed to execute 'checkValidity' on 'ElementInternals': The target element is not a form-associated custom element.`);
          if (!this.willValidate) {
            return true;
          }
          const validity = validityMap.get(this);
          if (!validity.valid) {
            const validityEvent = new Event("invalid", {
              bubbles: false,
              cancelable: true,
              composed: false
            });
            ref.dispatchEvent(validityEvent);
          }
          return validity.valid;
        }
        get form() {
          const ref = refMap.get(this);
          throwIfNotFormAssociated(ref, `Failed to read the 'form' property from 'ElementInternals': The target element is not a form-associated custom element.`);
          let form;
          if (ref.constructor["formAssociated"] === true) {
            form = findParentForm(ref);
          }
          return form;
        }
        get labels() {
          const ref = refMap.get(this);
          throwIfNotFormAssociated(ref, `Failed to read the 'labels' property from 'ElementInternals': The target element is not a form-associated custom element.`);
          const id = ref.getAttribute("id");
          const hostRoot = ref.getRootNode();
          if (hostRoot && id) {
            return hostRoot.querySelectorAll(`[for=${id}]`);
          }
          return [];
        }
        reportValidity() {
          const ref = refMap.get(this);
          throwIfNotFormAssociated(ref, `Failed to execute 'reportValidity' on 'ElementInternals': The target element is not a form-associated custom element.`);
          if (!this.willValidate) {
            return true;
          }
          const valid = this.checkValidity();
          const anchor = validationAnchorMap.get(this);
          if (anchor && !ref.constructor["formAssociated"]) {
            throw new DOMException(`Failed to execute 'reportValidity' on 'ElementInternals': The target element is not a form-associated custom element.`);
          }
          if (!valid && anchor) {
            ref.focus();
            anchor.focus();
          }
          return valid;
        }
        setFormValue(value) {
          const ref = refMap.get(this);
          throwIfNotFormAssociated(ref, `Failed to execute 'setFormValue' on 'ElementInternals': The target element is not a form-associated custom element.`);
          removeHiddenInputs(this);
          if (value != null && !(value instanceof FormData)) {
            if (ref.getAttribute("name")) {
              const hiddenInput = createHiddenInput(ref, this);
              hiddenInput.value = value;
            }
          } else if (value != null && value instanceof FormData) {
            Array.from(value).reverse().forEach(([formDataKey, formDataValue]) => {
              if (typeof formDataValue === "string") {
                const hiddenInput = createHiddenInput(ref, this);
                hiddenInput.name = formDataKey;
                hiddenInput.value = formDataValue;
              }
            });
          }
          refValueMap.set(ref, value);
        }
        setValidity(validityChanges, validationMessage, anchor) {
          const ref = refMap.get(this);
          throwIfNotFormAssociated(ref, `Failed to execute 'setValidity' on 'ElementInternals': The target element is not a form-associated custom element.`);
          if (!validityChanges) {
            throw new TypeError("Failed to execute 'setValidity' on 'ElementInternals': 1 argument required, but only 0 present.");
          }
          validationAnchorMap.set(this, anchor);
          const validity = validityMap.get(this);
          const validityChangesObj = {};
          for (const key in validityChanges) {
            validityChangesObj[key] = validityChanges[key];
          }
          if (Object.keys(validityChangesObj).length === 0) {
            setValid(validity);
          }
          const check = { ...validity, ...validityChangesObj };
          delete check.valid;
          const { valid } = reconcileValidity(validity, check, this.form);
          if (!valid && !validationMessage) {
            throw new DOMException(`Failed to execute 'setValidity' on 'ElementInternals': The second argument should not be empty if one or more flags in the first argument are true.`);
          }
          validationMessageMap.set(this, valid ? "" : validationMessage);
          ref.toggleAttribute("internals-invalid", !valid);
          ref.toggleAttribute("internals-valid", valid);
          ref.setAttribute("aria-invalid", `${!valid}`);
        }
        get shadowRoot() {
          const ref = refMap.get(this);
          const shadowRoot = shadowRootMap.get(ref);
          if (shadowRoot) {
            return shadowRoot;
          }
          return null;
        }
        get validationMessage() {
          const ref = refMap.get(this);
          throwIfNotFormAssociated(ref, `Failed to read the 'validationMessage' property from 'ElementInternals': The target element is not a form-associated custom element.`);
          return validationMessageMap.get(this);
        }
        get validity() {
          const ref = refMap.get(this);
          throwIfNotFormAssociated(ref, `Failed to read the 'validity' property from 'ElementInternals': The target element is not a form-associated custom element.`);
          const validity = validityMap.get(this);
          return validity;
        }
        get willValidate() {
          const ref = refMap.get(this);
          throwIfNotFormAssociated(ref, `Failed to read the 'willValidate' property from 'ElementInternals': The target element is not a form-associated custom element.`);
          if (ref.disabled || ref.hasAttribute("disabled") || ref.hasAttribute("readonly")) {
            return false;
          }
          return true;
        }
      }
      __name(ElementInternals2, "ElementInternals");
      function isElementInternalsSupported() {
        if (!window.ElementInternals) {
          return false;
        }
        class ElementInternalsFeatureDetection extends HTMLElement {
          constructor() {
            super();
            this.internals = this.attachInternals();
          }
        }
        __name(ElementInternalsFeatureDetection, "ElementInternalsFeatureDetection");
        const randomName = `element-internals-feature-detection-${Math.random().toString(36).replace(/[^a-z]+/g, "")}`;
        customElements.define(randomName, ElementInternalsFeatureDetection);
        const featureDetectionElement = new ElementInternalsFeatureDetection();
        return [
          "shadowRoot",
          "form",
          "willValidate",
          "validity",
          "validationMessage",
          "labels",
          "setFormValue",
          "setValidity",
          "checkValidity",
          "reportValidity"
        ].every((prop) => prop in featureDetectionElement.internals);
      }
      __name(isElementInternalsSupported, "isElementInternalsSupported");
      if (!isElementInternalsSupported()) {
        let attachShadowObserver = function(...args) {
          const shadowRoot = attachShadow.apply(this, args);
          const observer2 = new MutationObserver(observerCallback);
          shadowRootMap.set(this, shadowRoot);
          if (window.ShadyDOM) {
            observer2.observe(this, observerConfig);
          } else {
            observer2.observe(shadowRoot, observerConfig);
          }
          shadowHostsMap.set(this, observer2);
          return shadowRoot;
        }, checkValidityOverride = function(...args) {
          let returnValue = checkValidity.apply(this, args);
          return overrideFormMethod(this, returnValue, "checkValidity");
        }, reportValidityOverride = function(...args) {
          let returnValue = reportValidity.apply(this, args);
          return overrideFormMethod(this, returnValue, "reportValidity");
        };
        __name(attachShadowObserver, "attachShadowObserver");
        __name(checkValidityOverride, "checkValidityOverride");
        __name(reportValidityOverride, "reportValidityOverride");
        window.ElementInternals = ElementInternals2;
        HTMLElement.prototype.attachInternals = function() {
          if (this.tagName.indexOf("-") === -1) {
            throw new Error(`Failed to execute 'attachInternals' on 'HTMLElement': Unable to attach ElementInternals to non-custom elements.`);
          }
          if (internalsMap.has(this)) {
            throw new DOMException(`DOMException: Failed to execute 'attachInternals' on 'HTMLElement': ElementInternals for the specified element was already attached.`);
          }
          return new ElementInternals2(this);
        };
        const attachShadow = Element.prototype.attachShadow;
        Element.prototype.attachShadow = attachShadowObserver;
        const documentObserver = new MutationObserver(observerCallback);
        documentObserver.observe(document.documentElement, observerConfig);
        const checkValidity = HTMLFormElement.prototype.checkValidity;
        HTMLFormElement.prototype.checkValidity = checkValidityOverride;
        const reportValidity = HTMLFormElement.prototype.reportValidity;
        HTMLFormElement.prototype.reportValidity = reportValidityOverride;
        if (!window.CustomStateSet) {
          window.CustomStateSet = CustomStateSet;
        }
      } else if (!window.CustomStateSet) {
        window.CustomStateSet = CustomStateSet;
        const attachInternals = HTMLElement.prototype.attachInternals;
        HTMLElement.prototype.attachInternals = function(...args) {
          const internals = attachInternals.call(this, args);
          internals.states = new CustomStateSet(this);
          return internals;
        };
      }
    })();
  }
});

// polyfills.js
var import_element_internals_polyfill;
var init_polyfills = __esm({
  "polyfills.js"() {
    import_element_internals_polyfill = __toESM(require_dist(), 1);
  }
});

// index.js
init_polyfills();

// components/bottomappbar/MDWBottomAppBar.js
init_polyfills();

// core/aria/toolbar.js
init_polyfills();

// core/aria/keyboard.js
init_polyfills();
var FORWARD_ARROW_KEY = "mdw:keyboard-forwardarrowkey";
var BACK_ARROW_KEY = "mdw:keyboard-backarrowkey";
var UP_ARROW_KEY = "mdw:keyboard-uparrowkey";
var DOWN_ARROW_KEY = "mdw:keyboard-downarrowkey";
var HOME_KEY = "mdw:keyboard-homekey";
var END_KEY = "mdw:keyboard-endkey";
var PAGEUP_KEY = "mdw:keyboard-pageupkey";
var PAGEDOWN_KEY = "mdw:keyboard-pagedownkey";
var SPACEBAR_KEY = "mdw:keyboard-spacebarkey";
var ENTER_KEY = "mdw:keyboard-enterkey";
function isRtl(element) {
  return getComputedStyle(element).direction === "rtl";
}
__name(isRtl, "isRtl");
function onKeyDownHandler(event) {
  const detail = {
    ctrlKey: event.ctrlKey,
    shiftKey: event.shiftKey,
    altKey: event.altKey,
    metaKey: event.metaKey,
    repeat: event.repeat
  };
  let type;
  switch (event.key) {
    case "Enter":
      type = ENTER_KEY;
      break;
    case " ":
    case "Spacebar":
      type = SPACEBAR_KEY;
      break;
    case "ArrowDown":
    case "Down":
      type = DOWN_ARROW_KEY;
      break;
    case "ArrowUp":
    case "Up":
      type = UP_ARROW_KEY;
      break;
    case "ArrowLeft":
    case "Left":
      type = isRtl(this) ? FORWARD_ARROW_KEY : BACK_ARROW_KEY;
      break;
    case "ArrowRight":
    case "Right":
      type = isRtl(this) ? BACK_ARROW_KEY : FORWARD_ARROW_KEY;
      break;
    case "Home":
      type = HOME_KEY;
      break;
    case "End":
      type = END_KEY;
      break;
    case "PageUp":
      type = PAGEUP_KEY;
      break;
    case "PageDown":
      type = PAGEDOWN_KEY;
      break;
    default:
      return;
  }
  const customEvent = new CustomEvent(type, { bubbles: true, cancelable: true, detail });
  if (!this.dispatchEvent(customEvent)) {
    event.stopPropagation();
    event.preventDefault();
  }
}
__name(onKeyDownHandler, "onKeyDownHandler");
function attach(element) {
  element.addEventListener("keydown", onKeyDownHandler);
}
__name(attach, "attach");

// core/aria/rovingtabindex.js
init_polyfills();
var TABINDEX_ZEROED = "mdw:rovingtabindex-tabindexzeroed";
function onChildFocus(event) {
  if (this.getAttribute("tabindex") === "0")
    return;
  this.setAttribute("tabindex", "0");
  this.dispatchEvent(new Event(TABINDEX_ZEROED, { bubbles: true, cancelable: true }));
}
__name(onChildFocus, "onChildFocus");
function removeTabIndex(items, excludeItems = []) {
  for (const item of items) {
    if (excludeItems.includes(item)) {
      continue;
    }
    if (item.hasAttribute("tabindex")) {
      item.setAttribute("tabindex", "-1");
    }
  }
}
__name(removeTabIndex, "removeTabIndex");
function attemptFocus(element) {
  try {
    element.focus();
  } catch (e) {
    console.error(e);
  }
  const focused = document.activeElement === element;
  if (!focused) {
    console.warn("Element was not focused", element);
    return false;
  }
  return true;
}
__name(attemptFocus, "attemptFocus");
function selectNext(list, current = null, loop = true, reverse = false) {
  let foundCurrent = false;
  const array = reverse ? [...list].reverse() : list;
  for (const candidate of array) {
    if (!foundCurrent) {
      if (current) {
        if (candidate === current) {
          foundCurrent = true;
        }
      } else if (candidate.getAttribute("tabindex") === "0") {
        foundCurrent = true;
      }
      continue;
    }
    if (!candidate.hasAttribute("tabindex")) {
      continue;
    }
    if (candidate.getAttribute("aria-hidden") === "true") {
      continue;
    }
    if (candidate.getAttribute("mdw-skip-tab") === "true") {
      continue;
    }
    if (attemptFocus(candidate)) {
      return candidate;
    }
  }
  if (!loop) {
    if (document.activeElement !== current && current instanceof HTMLElement) {
      current.focus();
    }
    return current;
  }
  for (const candidate of array) {
    if (!candidate.hasAttribute("tabindex")) {
      continue;
    }
    if (candidate.getAttribute("aria-hidden") === "true") {
      continue;
    }
    if (candidate.getAttribute("mdw-skip-tab") === "true") {
      continue;
    }
    if (attemptFocus(candidate)) {
      return candidate;
    }
    if (candidate === current) {
      return candidate;
    }
  }
  return null;
}
__name(selectNext, "selectNext");
function selectPrevious(list, current, loop = true) {
  return selectNext(list, current, loop, true);
}
__name(selectPrevious, "selectPrevious");
function attach2(element) {
  if (!element.hasAttribute("tabindex")) {
    element.setAttribute("tabindex", document.activeElement === element ? "0" : "-1");
  }
  element.addEventListener("focus", onChildFocus);
}
__name(attach2, "attach");
function detach(element) {
  element.removeEventListener("focus", onChildFocus);
}
__name(detach, "detach");
function setupTabIndexes(items, focusableWhenDisabled = true) {
  let currentlyFocusedChild = null;
  let currentTabIndexChild = null;
  let firstFocusableChild = null;
  for (const child of items) {
    if (!currentlyFocusedChild && document.activeElement === child) {
      currentlyFocusedChild = child;
    } else if (!currentTabIndexChild && child.getAttribute("tabindex") === "0") {
      currentTabIndexChild = child;
    } else {
      if (!firstFocusableChild && child.getAttribute("aria-hidden") !== "true" && (focusableWhenDisabled || child.getAttribute("aria-disabled") !== "true")) {
        firstFocusableChild = child;
      }
      child.setAttribute("tabindex", "-1");
    }
    attach2(child);
  }
  if (currentlyFocusedChild) {
    currentlyFocusedChild.setAttribute("tabindex", "0");
  } else if (currentTabIndexChild) {
    if (currentlyFocusedChild) {
      currentTabIndexChild.setAttribute("tabindex", "-1");
    }
  } else if (firstFocusableChild) {
    firstFocusableChild.setAttribute("tabindex", "0");
  }
}
__name(setupTabIndexes, "setupTabIndexes");

// core/aria/toolbar.js
var TOOLBAR_ITEM_SELECTOR = [
  "button",
  "[href]",
  "input",
  "select",
  "textarea",
  "[tabindex]"
].join(", ");
function onTabIndexZeroed(event) {
  event.stopPropagation();
  const element = event.currentTarget;
  const currentItem = event.target;
  removeTabIndex(element.children, [currentItem]);
}
__name(onTabIndexZeroed, "onTabIndexZeroed");
function onUpArrowKey(event) {
  if (event.detail.ctrlKey || event.detail.altKey || event.detail.shiftKey || event.detail.metaKey) {
    return;
  }
  const element = event.currentTarget;
  if (element.getAttribute("aria-orientation") !== "vertical")
    return;
  event.preventDefault();
  event.stopPropagation();
  const items = element.querySelectorAll(TOOLBAR_ITEM_SELECTOR);
  selectPrevious(items);
}
__name(onUpArrowKey, "onUpArrowKey");
function onBackArrowKey(event) {
  if (event.detail.ctrlKey || event.detail.altKey || event.detail.shiftKey || event.detail.metaKey) {
    return;
  }
  const element = event.currentTarget;
  if (element.getAttribute("aria-orientation") === "vertical")
    return;
  event.preventDefault();
  event.stopPropagation();
  const items = element.querySelectorAll(TOOLBAR_ITEM_SELECTOR);
  selectPrevious(items);
}
__name(onBackArrowKey, "onBackArrowKey");
function onDownArrowKey(event) {
  if (event.detail.ctrlKey || event.detail.altKey || event.detail.shiftKey || event.detail.metaKey) {
    return;
  }
  const element = event.currentTarget;
  if (element.getAttribute("aria-orientation") !== "vertical")
    return;
  event.preventDefault();
  event.stopPropagation();
  const items = element.querySelectorAll(TOOLBAR_ITEM_SELECTOR);
  selectNext(items);
}
__name(onDownArrowKey, "onDownArrowKey");
function onForwardArrowKey(event) {
  if (event.detail.ctrlKey || event.detail.altKey || event.detail.shiftKey || event.detail.metaKey) {
    return;
  }
  const element = event.currentTarget;
  if (element.getAttribute("aria-orientation") === "vertical")
    return;
  event.preventDefault();
  event.stopPropagation();
  const items = element.querySelectorAll(TOOLBAR_ITEM_SELECTOR);
  selectNext(items);
}
__name(onForwardArrowKey, "onForwardArrowKey");
function attach3(element) {
  if (element.hasAttribute("role") && element.getAttribute("role") !== "toolbar")
    return;
  element.setAttribute("role", "toolbar");
  const items = element.querySelectorAll(TOOLBAR_ITEM_SELECTOR);
  setupTabIndexes(items, true);
  attach(element);
  element.addEventListener(DOWN_ARROW_KEY, onDownArrowKey);
  element.addEventListener(UP_ARROW_KEY, onUpArrowKey);
  element.addEventListener(BACK_ARROW_KEY, onBackArrowKey);
  element.addEventListener(FORWARD_ARROW_KEY, onForwardArrowKey);
  element.addEventListener(TABINDEX_ZEROED, onTabIndexZeroed);
}
__name(attach3, "attach");
function detach2(element) {
  element.removeEventListener(DOWN_ARROW_KEY, onDownArrowKey);
  element.removeEventListener(UP_ARROW_KEY, onUpArrowKey);
  element.removeEventListener(BACK_ARROW_KEY, onBackArrowKey);
  element.removeEventListener(FORWARD_ARROW_KEY, onForwardArrowKey);
  element.removeEventListener(TABINDEX_ZEROED, onTabIndexZeroed);
}
__name(detach2, "detach");

// core/container/MDWContainer.js
init_polyfills();

// core/text/MDWText.js
init_polyfills();

// core/component/MDWComponent.js
init_polyfills();
var _attachShadow, attachShadow_fn, _attachStyles, attachStyles_fn, _attachContent, attachContent_fn, _attachInternals, attachInternals_fn, _attachARIA, attachARIA_fn, _attachIDLs, attachIDLs_fn, _fragmentCache, _stylesCache, _idlValues, _storeIdl, storeIdl_fn, _getIdlValue, getIdlValue_fn;
var _MDWComponent = class extends HTMLElement {
  constructor() {
    super();
    __privateAdd(this, _attachShadow);
    __privateAdd(this, _attachStyles);
    __privateAdd(this, _attachContent);
    __privateAdd(this, _attachInternals);
    __privateAdd(this, _attachARIA);
    __privateAdd(this, _attachIDLs);
    __privateAdd(this, _storeIdl);
    __privateAdd(this, _getIdlValue);
    __privateAdd(this, _idlValues, /* @__PURE__ */ new Map());
    __privateMethod(this, _attachIDLs, attachIDLs_fn).call(this);
    __privateMethod(this, _attachShadow, attachShadow_fn).call(this);
    __privateMethod(this, _attachStyles, attachStyles_fn).call(this);
    __privateMethod(this, _attachContent, attachContent_fn).call(this);
    __privateMethod(this, _attachInternals, attachInternals_fn).call(this);
    __privateMethod(this, _attachARIA, attachARIA_fn).call(this);
  }
  static get observedAttributes() {
    return [
      ...this.idlBooleanAttributes,
      ...this.idlIntegerAttributes,
      ...this.idlFloatAttributes,
      ...this.idlStringAttributes
    ];
  }
  attributeChangedCallback(name, oldValue, newValue) {
    if (oldValue == null && newValue == null)
      return;
    const component = this.constructor;
    if (component.idlBooleanAttributes.includes(name)) {
      const tuple = __privateMethod(this, _getIdlValue, getIdlValue_fn).call(this, name);
      if (tuple[1] === newValue)
        return;
      tuple[1] = newValue;
      tuple[0] = newValue != null;
      return;
    }
    if (component.idlStringAttributes.includes(name)) {
      const tuple = __privateMethod(this, _getIdlValue, getIdlValue_fn).call(this, name);
      if (tuple[1] === newValue)
        return;
      tuple[1] = newValue;
      tuple[0] = newValue;
      return;
    }
    if (component.idlIntegerAttributes.includes(name)) {
      const tuple = __privateMethod(this, _getIdlValue, getIdlValue_fn).call(this, name);
      if (tuple[1] === newValue)
        return;
      tuple[1] = newValue;
      if (newValue == null) {
        tuple[0] = null;
      } else {
        const numValue = Number.parseInt(newValue, 10);
        tuple[0] = Number.isNaN(numValue) ? null : numValue;
      }
    }
    if (component.idlFloatAttributes.includes(name)) {
      const tuple = __privateMethod(this, _getIdlValue, getIdlValue_fn).call(this, name);
      if (tuple[1] === newValue)
        return;
      tuple[1] = newValue;
      if (newValue == null) {
        tuple[0] = null;
      } else {
        const numValue = Number.parseFloat(newValue);
        tuple[0] = Number.isNaN(numValue) ? null : numValue;
      }
    }
  }
  static attrNameToPropName(name) {
    const propNameWords = name.split("-");
    if (propNameWords.length === 1)
      return name;
    return propNameWords.reduce((prev, curr) => {
      if (prev == null)
        return curr;
      return prev + curr[0].toUpperCase() + curr.slice(1);
    });
  }
  static register(elementName) {
    customElements.define(elementName || this.elementName, this);
  }
};
var MDWComponent = _MDWComponent;
__name(MDWComponent, "MDWComponent");
_attachShadow = new WeakSet();
attachShadow_fn = /* @__PURE__ */ __name(function() {
  const component = this.constructor;
  this.attachShadow({ mode: "open", delegatesFocus: component.delegatesFocus });
}, "#attachShadow");
_attachStyles = new WeakSet();
attachStyles_fn = /* @__PURE__ */ __name(function() {
  if (!_MDWComponent.supportsAdoptedStyleSheets)
    return;
  const component = this.constructor;
  let array = __privateGet(_MDWComponent, _stylesCache).get(component);
  if (!array) {
    array = component.styles.filter((style) => style instanceof CSSStyleSheet);
    __privateGet(_MDWComponent, _stylesCache).set(component, array);
  }
  this.shadowRoot.adoptedStyleSheets = array;
}, "#attachStyles");
_attachContent = new WeakSet();
attachContent_fn = /* @__PURE__ */ __name(function() {
  const component = this.constructor;
  let content = __privateGet(_MDWComponent, _fragmentCache).get(component);
  if (!content) {
    content = document.createDocumentFragment();
    content.append(
      ...component.styles.map((style) => {
        if (typeof style === "string") {
          const el2 = document.createElement("style");
          el2.textContent = style;
          return el2;
        }
        if (style instanceof URL) {
          const el2 = document.createElement("link");
          el2.rel = "stylesheet";
          el2.href = style.href;
          return el2;
        }
        if (_MDWComponent.supportsAdoptedStyleSheets)
          return null;
        const el = document.createElement("style");
        el.textContent = [...style.cssRules].map((r) => r.cssText).join("\n");
        return el;
      }).filter(Boolean),
      ...component.fragments.map((fragment) => {
        if (typeof fragment === "string") {
          return document.createRange().createContextualFragment(fragment);
        }
        return fragment;
      })
    );
    __privateGet(_MDWComponent, _fragmentCache).set(component, content);
  }
  this.shadowRoot.prepend(content.cloneNode(true));
}, "#attachContent");
_attachInternals = new WeakSet();
attachInternals_fn = /* @__PURE__ */ __name(function() {
  if (_MDWComponent.supportsElementInternals) {
    this.elementInternals = this.attachInternals();
  }
}, "#attachInternals");
_attachARIA = new WeakSet();
attachARIA_fn = /* @__PURE__ */ __name(function() {
  const component = this.constructor;
  if (component.supportsElementInternalsRole) {
    this.elementInternals.role = component.ariaRole;
  } else {
    if (this.hasAttribute("role"))
      return;
    this.setAttribute("role", component.ariaRole);
  }
}, "#attachARIA");
_attachIDLs = new WeakSet();
attachIDLs_fn = /* @__PURE__ */ __name(function() {
  const component = this.constructor;
  for (const key of component.idlBooleanAttributes) {
    const propName = _MDWComponent.attrNameToPropName(key);
    Object.defineProperty(this, propName, {
      enumerable: true,
      get() {
        const tuple = __privateMethod(this, _getIdlValue, getIdlValue_fn).call(this, key);
        return tuple[0];
      },
      set(value) {
        const parsedValue = !!value;
        __privateMethod(this, _storeIdl, storeIdl_fn).call(this, key, parsedValue, parsedValue ? "" : null);
        this.toggleAttribute(key, parsedValue);
      }
    });
  }
  for (const key of [...component.idlIntegerAttributes, ...component.idlFloatAttributes]) {
    const propName = _MDWComponent.attrNameToPropName(key);
    Object.defineProperty(this, propName, {
      enumerable: true,
      get() {
        return __privateMethod(this, _getIdlValue, getIdlValue_fn).call(this, key)[0];
      },
      set(value) {
        if (value == null) {
          __privateMethod(this, _storeIdl, storeIdl_fn).call(this, key, null);
          this.removeAttribute(key);
          return;
        }
        if (typeof value !== "number")
          throw new TypeError("Value must be a number");
        const stringValue = String(value);
        __privateMethod(this, _storeIdl, storeIdl_fn).call(this, key, value, stringValue);
        this.setAttribute(key, stringValue);
      }
    });
  }
  for (const key of component.idlStringAttributes) {
    const propName = _MDWComponent.attrNameToPropName(key);
    Object.defineProperty(this, propName, {
      enumerable: true,
      get() {
        return __privateMethod(this, _getIdlValue, getIdlValue_fn).call(this, key)[0];
      },
      set(value) {
        if (value == null) {
          __privateMethod(this, _storeIdl, storeIdl_fn).call(this, key, null);
          this.removeAttribute(key);
          return;
        }
        const stringValue = String(value);
        __privateMethod(this, _storeIdl, storeIdl_fn).call(this, key, stringValue, stringValue);
        this.setAttribute(key, stringValue);
      }
    });
  }
}, "#attachIDLs");
_fragmentCache = new WeakMap();
_stylesCache = new WeakMap();
_idlValues = new WeakMap();
_storeIdl = new WeakSet();
storeIdl_fn = /* @__PURE__ */ __name(function(key, value, stringValue) {
  const tuple = __privateMethod(this, _getIdlValue, getIdlValue_fn).call(this, key);
  tuple[0] = value;
  tuple[1] = stringValue;
}, "#storeIdl");
_getIdlValue = new WeakSet();
getIdlValue_fn = /* @__PURE__ */ __name(function(key) {
  let value = __privateGet(this, _idlValues).get(key);
  if (!value) {
    value = [null, null];
    __privateGet(this, _idlValues).set(key, value);
  }
  return value;
}, "#getIdlValue");
__publicField(MDWComponent, "supportsAdoptedStyleSheets", "adoptedStyleSheets" in ShadowRoot.prototype);
__publicField(MDWComponent, "supportsElementInternals", "attachInternals" in HTMLElement.prototype);
__publicField(MDWComponent, "supportsElementInternalsRole", _MDWComponent.supportsElementInternals && "role" in ElementInternals.prototype);
__publicField(MDWComponent, "ariaRole", "none");
__publicField(MDWComponent, "delegatesFocus", false);
__publicField(MDWComponent, "idlBooleanAttributes", []);
__publicField(MDWComponent, "idlIntegerAttributes", []);
__publicField(MDWComponent, "idlFloatAttributes", []);
__publicField(MDWComponent, "idlStringAttributes", []);
__publicField(MDWComponent, "fragments", []);
__publicField(MDWComponent, "styles", []);
__privateAdd(MDWComponent, _fragmentCache, /* @__PURE__ */ new WeakMap());
__privateAdd(MDWComponent, _stylesCache, /* @__PURE__ */ new WeakMap());
__publicField(MDWComponent, "elementName", null);

// core/text/MDWText.css
init_polyfills();
var contents = `/* core/text/MDWText.css */
:host {
  font-weight: var(--mdw-type__font-weight, invalid);
  font-size: var(--mdw-type__font-size, invalid);
  line-height: var(--mdw-type__line-height, invalid);
  font-family: var(--mdw-type__font-family, invalid);
  letter-spacing: var(--mdw-type__letter-spacing, invalid);
}
:host([block]) {
  display: block;
}
:host([ink]) {
  color: rgb(var(--mdw-ink));
}
:host([ink="inverse-primary"]) {
  --mdw-ink: var(--mdw-color__inverse-primary);
}
:host([ink="primary"]) {
  --mdw-ink: var(--mdw-color__primary);
}
:host([ink="secondary"]) {
  --mdw-ink: var(--mdw-color__secondary);
}
:host([ink="tertiary"]) {
  --mdw-ink: var(--mdw-color__tertiary);
}
:host([ink="error"]) {
  --mdw-ink: var(--mdw-color__error);
}
:host([ink="outline"]) {
  --mdw-ink: var(--mdw-color__outline);
}
:host([type-style|="display"]) {
  --mdw-type__font-weight: var(--mdw-typescale__display-large__font-weight);
  --mdw-type__font-size: var(--mdw-typescale__display-large__font-size);
  --mdw-type__line-height: var(--mdw-typescale__display-large__line-height);
  --mdw-type__font-family: var(--mdw-typescale__display-large__font-family);
  --mdw-type__letter-spacing: var(--mdw-typescale__display-large__letter-spacing);
}
:host([type-style="display-medium"]) {
  --mdw-type__font-weight: var(--mdw-typescale__display-medium__font-weight);
  --mdw-type__font-size: var(--mdw-typescale__display-medium__font-size);
  --mdw-type__line-height: var(--mdw-typescale__display-medium__line-height);
  --mdw-type__font-family: var(--mdw-typescale__display-medium__font-family);
  --mdw-type__letter-spacing: var(--mdw-typescale__display-medium__letter-spacing);
}
:host([type-style="display-small"]) {
  --mdw-type__font-weight: var(--mdw-typescale__display-small__font-weight);
  --mdw-type__font-size: var(--mdw-typescale__display-small__font-size);
  --mdw-type__line-height: var(--mdw-typescale__display-small__line-height);
  --mdw-type__font-family: var(--mdw-typescale__display-small__font-family);
  --mdw-type__letter-spacing: var(--mdw-typescale__display-small__letter-spacing);
}
:host([type-style|="headline"]) {
  --mdw-type__font-weight: var(--mdw-typescale__headline-large__font-weight);
  --mdw-type__font-size: var(--mdw-typescale__headline-large__font-size);
  --mdw-type__line-height: var(--mdw-typescale__headline-large__line-height);
  --mdw-type__font-family: var(--mdw-typescale__headline-large__font-family);
  --mdw-type__letter-spacing: var(--mdw-typescale__headline-large__letter-spacing);
}
:host([type-style="headline-medium"]),
h2 {
  --mdw-type__font-weight: var(--mdw-typescale__headline-medium__font-weight);
  --mdw-type__font-size: var(--mdw-typescale__headline-medium__font-size);
  --mdw-type__line-height: var(--mdw-typescale__headline-medium__line-height);
  --mdw-type__font-family: var(--mdw-typescale__headline-medium__font-family);
  --mdw-type__letter-spacing: var(--mdw-typescale__headline-medium__letter-spacing);
}
:host([type-style="headline-small"]),
h3 {
  --mdw-type__font-weight: var(--mdw-typescale__headline-small__font-weight);
  --mdw-type__font-size: var(--mdw-typescale__headline-small__font-size);
  --mdw-type__line-height: var(--mdw-typescale__headline-small__line-height);
  --mdw-type__font-family: var(--mdw-typescale__headline-small__font-family);
  --mdw-type__letter-spacing: var(--mdw-typescale__headline-small__letter-spacing);
}
:host([type-style|="title"]),
h4 {
  --mdw-type__font-weight: var(--mdw-typescale__title-large__font-weight);
  --mdw-type__font-size: var(--mdw-typescale__title-large__font-size);
  --mdw-type__line-height: var(--mdw-typescale__title-large__line-height);
  --mdw-type__font-family: var(--mdw-typescale__title-large__font-family);
  --mdw-type__letter-spacing: var(--mdw-typescale__title-large__letter-spacing);
}
:host([type-style="title-medium"]),
h5 {
  --mdw-type__font-weight: var(--mdw-typescale__title-medium__font-weight);
  --mdw-type__font-size: var(--mdw-typescale__title-medium__font-size);
  --mdw-type__line-height: var(--mdw-typescale__title-medium__line-height);
  --mdw-type__font-family: var(--mdw-typescale__title-medium__font-family);
  --mdw-type__letter-spacing: var(--mdw-typescale__title-medium__letter-spacing);
}
:host([type-style="title-small"]),
h6 {
  --mdw-type__font-weight: var(--mdw-typescale__title-small__font-weight);
  --mdw-type__font-size: var(--mdw-typescale__title-small__font-size);
  --mdw-type__line-height: var(--mdw-typescale__title-small__line-height);
  --mdw-type__font-family: var(--mdw-typescale__title-small__font-family);
  --mdw-type__letter-spacing: var(--mdw-typescale__title-small__letter-spacing);
}
:host([type-style|="label"]) {
  --mdw-type__font-weight: var(--mdw-typescale__label-large__font-weight);
  --mdw-type__font-size: var(--mdw-typescale__label-large__font-size);
  --mdw-type__line-height: var(--mdw-typescale__label-large__line-height);
  --mdw-type__font-family: var(--mdw-typescale__label-large__font-family);
  --mdw-type__letter-spacing: var(--mdw-typescale__label-large__letter-spacing);
}
:host([type-style="label-medium"]) {
  --mdw-type__font-weight: var(--mdw-typescale__label-medium__font-weight);
  --mdw-type__font-size: var(--mdw-typescale__label-medium__font-size);
  --mdw-type__line-height: var(--mdw-typescale__label-medium__line-height);
  --mdw-type__font-family: var(--mdw-typescale__label-medium__font-family);
  --mdw-type__letter-spacing: var(--mdw-typescale__label-medium__letter-spacing);
}
:host([type-style="label-small"]) {
  --mdw-type__font-weight: var(--mdw-typescale__label-small__font-weight);
  --mdw-type__font-size: var(--mdw-typescale__label-small__font-size);
  --mdw-type__line-height: var(--mdw-typescale__label-small__line-height);
  --mdw-type__font-family: var(--mdw-typescale__label-small__font-family);
  --mdw-type__letter-spacing: var(--mdw-typescale__label-small__letter-spacing);
}
:host([type-style|="body"]) {
  --mdw-type__font-weight: var(--mdw-typescale__body-large__font-weight);
  --mdw-type__font-size: var(--mdw-typescale__body-large__font-size);
  --mdw-type__line-height: var(--mdw-typescale__body-large__line-height);
  --mdw-type__font-family: var(--mdw-typescale__body-large__font-family);
  --mdw-type__letter-spacing: var(--mdw-typescale__body-large__letter-spacing);
}
:host([type-style="body-medium"]) {
  --mdw-type__font-weight: var(--mdw-typescale__body-medium__font-weight);
  --mdw-type__font-size: var(--mdw-typescale__body-medium__font-size);
  --mdw-type__line-height: var(--mdw-typescale__body-medium__line-height);
  --mdw-type__font-family: var(--mdw-typescale__body-medium__font-family);
  --mdw-type__letter-spacing: var(--mdw-typescale__body-medium__letter-spacing);
}
:host([type-style="body-small"]) {
  --mdw-type__font-weight: var(--mdw-typescale__body-small__font-weight);
  --mdw-type__font-size: var(--mdw-typescale__body-small__font-size);
  --mdw-type__line-height: var(--mdw-typescale__body-small__line-height);
  --mdw-type__font-family: var(--mdw-typescale__body-small__font-family);
  --mdw-type__letter-spacing: var(--mdw-typescale__body-small__letter-spacing);
}`;
var styles;
try {
  styles = new CSSStyleSheet();
  styles.replaceSync(contents);
} catch (e) {
  styles = contents;
}
var MDWText_default = styles;

// core/text/MDWText.js
var _MDWText = class extends MDWComponent {
  constructor() {
    super();
    this.slotElement = this.shadowRoot.getElementById("slot");
  }
};
var MDWText = _MDWText;
__name(MDWText, "MDWText");
__publicField(MDWText, "idlBooleanAttributes", [
  ...MDWComponent.idlBooleanAttributes,
  "block"
]);
__publicField(MDWText, "idlStringAttributes", [
  ...__superGet(_MDWText, _MDWText, "idlStringAttributes"),
  "ink",
  "type-style"
]);
__publicField(MDWText, "elementName", "mdw-text");
__publicField(MDWText, "styles", [...__superGet(_MDWText, _MDWText, "styles"), MDWText_default]);
__publicField(MDWText, "fragments", [
  ...__superGet(_MDWText, _MDWText, "fragments"),
  `
      <slot id=slot></slot>
    `
]);

// core/container/MDWContainer.css
init_polyfills();
var contents2 = `/* core/container/MDWContainer.css */
:host {
  --mdw-container__elevation__opacity: 0;
  --mdw-container__elevation__visibility: visible;
  --mdw-container__elevation__color: var(--mdw-color__primary);
  --mdw-container__box-shadow: var(--mdw-container__box-shadow__0dp);
  --mdw-container__filter: var(--mdw-container__elevation__filter__0dp);
  --mdw-container__box-shadow__0dp: none;
  --mdw-container__box-shadow__1dp:
    0 0 02px 0 rgba(var(--mdw-color__shadow), 0.14),
    0 02px 02px 0 rgba(var(--mdw-color__shadow), 0.12),
    0 01px 03px 0 rgba(var(--mdw-color__shadow), 0.20);
  --mdw-container__box-shadow__2dp:
    0 0 04px 0 rgba(var(--mdw-color__shadow), 0.14),
    0 03px 04px 0 rgba(var(--mdw-color__shadow), 0.12),
    0 01px 05px 0 rgba(var(--mdw-color__shadow), 0.20);
  --mdw-container__box-shadow__3dp:
    0 03px 03px 0 rgba(var(--mdw-color__shadow), 0.14),
    0 03px 04px 0 rgba(var(--mdw-color__shadow), 0.12),
    0 01px 08px 0 rgba(var(--mdw-color__shadow), 0.20);
  --mdw-container__box-shadow__4dp:
    0 02px 04px 0 rgba(var(--mdw-color__shadow), 0.14),
    0 04px 05px 0 rgba(var(--mdw-color__shadow), 0.12),
    0 01px 10px 0 rgba(var(--mdw-color__shadow), 0.20);
  --mdw-container__box-shadow__6dp:
    0 06px 10px 0 rgba(var(--mdw-color__shadow), 0.14),
    0 01px 18px 0 rgba(var(--mdw-color__shadow), 0.12),
    0 03px 05px 0 rgba(var(--mdw-color__shadow), 0.20);
  --mdw-container__box-shadow__8dp:
    0 08px 10px 1px rgba(var(--mdw-color__shadow), 0.14),
    0 03px 14px 3px rgba(var(--mdw-color__shadow), 0.12),
    0 04px 15px 0 rgba(var(--mdw-color__shadow), 0.20);
  --mdw-container__box-shadow__9dp:
    0 09px 12px 1px rgba(var(--mdw-color__shadow), 0.14),
    0 03px 16px 2px rgba(var(--mdw-color__shadow), 0.12),
    0 05px 06px 0 rgba(var(--mdw-color__shadow), 0.20);
  --mdw-container__box-shadow__12dp:
    0 12px 17px 2px rgba(var(--mdw-color__shadow), 0.14),
    0 05px 22px 4px rgba(var(--mdw-color__shadow), 0.12),
    0 07px 08px 0 rgba(var(--mdw-color__shadow), 0.20);
  --mdw-container__box-shadow__16dp:
    0 16px 24px 2px rgba(var(--mdw-color__shadow), 0.14),
    0 06px 30px 5px rgba(var(--mdw-color__shadow), 0.12),
    0 08px 10px 0 rgba(var(--mdw-color__shadow), 0.20);
  --mdw-container__box-shadow__24dp:
    0 24px 38px 3px rgba(var(--mdw-color__shadow), 0.14),
    0 09px 46px 8px rgba(var(--mdw-color__shadow), 0.12),
    0 11px 15px 0 rgba(var(--mdw-color__shadow), 0.20);
  --mdw-container__elevation__opacity__1: 0.05;
  --mdw-container__elevation__opacity__2: 0.08;
  --mdw-container__elevation__opacity__3: 0.11;
  --mdw-container__elevation__opacity__4: 0.12;
  --mdw-container__elevation__opacity__5: 0.14;
  --mdw-container__box-shadow__1: var(--mdw-container__box-shadow__1dp);
  --mdw-container__box-shadow__2: var(--mdw-container__box-shadow__3dp);
  --mdw-container__box-shadow__3: var(--mdw-container__box-shadow__6dp);
  --mdw-container__box-shadow__4: var(--mdw-container__box-shadow__8dp);
  --mdw-container__box-shadow__5: var(--mdw-container__box-shadow__12dp);
  --mdw-container__elevation__filter__0dp: none;
  --mdw-container__elevation__filter__1dp: drop-shadow(0 00.92px 00.5px rgba(var(--mdw-color__shadow), 0.26)) drop-shadow(0 0 00.67px rgba(var(--mdw-color__shadow), 0.08));
  --mdw-container__elevation__filter__2dp: drop-shadow(0 01.83px 01.0px rgba(var(--mdw-color__shadow), 0.26)) drop-shadow(0 0 01.33px rgba(var(--mdw-color__shadow), 0.08));
  --mdw-container__elevation__filter__3dp: drop-shadow(0 02.75px 01.5px rgba(var(--mdw-color__shadow), 0.26)) drop-shadow(0 0 02.00px rgba(var(--mdw-color__shadow), 0.08));
  --mdw-container__elevation__filter__4dp: drop-shadow(0 03.67px 02.0px rgba(var(--mdw-color__shadow), 0.26)) drop-shadow(0 0 02.67px rgba(var(--mdw-color__shadow), 0.08));
  --mdw-container__elevation__filter__6dp: drop-shadow(0 05.50px 03.0px rgba(var(--mdw-color__shadow), 0.26)) drop-shadow(0 0 04.00px rgba(var(--mdw-color__shadow), 0.08));
  --mdw-container__elevation__filter__8dp: drop-shadow(0 07.33px 04.0px rgba(var(--mdw-color__shadow), 0.26)) drop-shadow(0 0 05.33px rgba(var(--mdw-color__shadow), 0.08));
  --mdw-container__elevation__filter__9dp: drop-shadow(0 08.25px 04.5px rgba(var(--mdw-color__shadow), 0.26)) drop-shadow(0 0 06.00px rgba(var(--mdw-color__shadow), 0.08));
  --mdw-container__elevation__filter__12dp: drop-shadow(0 11.00px 06.0px rgba(var(--mdw-color__shadow), 0.26)) drop-shadow(0 0 08.00px rgba(var(--mdw-color__shadow), 0.08));
  --mdw-container__elevation__filter__16dp: drop-shadow(0 14.67px 08.0px rgba(var(--mdw-color__shadow), 0.26)) drop-shadow(0 0 10.67px rgba(var(--mdw-color__shadow), 0.08));
  --mdw-container__elevation__filter__24dp: drop-shadow(0 22.12px 12.0px rgba(var(--mdw-color__shadow), 0.26)) drop-shadow(0 0 16.00px rgba(var(--mdw-color__shadow), 0.08));
  --mdw-container__transition-property:
    background-color,
    color,
    border-radius,
    box-shadow;
  --mdw-shape__size: 0;
  --mdw-shape__size__top-start-size: var(--mdw-shape__size);
  --mdw-shape__size__top-end-size: var(--mdw-shape__size);
  --mdw-shape__size__bottom-start-size: var(--mdw-shape__size);
  --mdw-shape__size__bottom-end-size: var(--mdw-shape__size);
  display: block;
  position: relative;
  border-start-start-radius: var(--mdw-shape__size__top-start-size);
  border-start-end-radius: var(--mdw-shape__size__top-end-size);
  border-end-start-radius: var(--mdw-shape__size__bottom-start-size);
  border-end-end-radius: var(--mdw-shape__size__bottom-end-size);
  transition-delay: 1ms;
  transition-duration: 100ms;
  transition-property: var(--mdw-container__transition-property);
  box-shadow: var(--mdw-container__box-shadow);
}
:host([color]:where(:not([disabled]))) {
  background-color: rgb(var(--mdw-bg));
  color: rgb(var(--mdw-ink));
}
:host([color="primary"]) {
  --mdw-bg: var(--mdw-color__primary);
  --mdw-ink: var(--mdw-color__on-primary);
}
:host([color="primary-container"]) {
  --mdw-bg: var(--mdw-color__primary-container);
  --mdw-ink: var(--mdw-color__on-primary-container);
}
:host([color="secondary"]) {
  --mdw-bg: var(--mdw-color__secondary);
  --mdw-ink: var(--mdw-color__on-secondary);
}
:host([color="secondary-container"]) {
  --mdw-bg: var(--mdw-color__secondary-container);
  --mdw-ink: var(--mdw-color__on-secondary-container);
}
:host([color="tertiary"]) {
  --mdw-bg: var(--mdw-color__tertiary);
  --mdw-ink: var(--mdw-color__on-tertiary);
}
:host([color="tertiary-container"]) {
  --mdw-bg: var(--mdw-color__tertiary-container);
  --mdw-ink: var(--mdw-color__on-tertiary-container);
}
:host([color="error"]) {
  --mdw-bg: var(--mdw-color__error);
  --mdw-ink: var(--mdw-color__on-error);
}
:host([color="error-container"]) {
  --mdw-bg: var(--mdw-color__error-container);
  --mdw-ink: var(--mdw-color__on-error-container);
}
:host([color="background"]) {
  --mdw-bg: var(--mdw-color__background);
  --mdw-ink: var(--mdw-color__on-background);
}
:host([color|="surface"]) {
  --mdw-bg: var(--mdw-color__surface);
  --mdw-ink: var(--mdw-color__on-surface);
}
:host([color="surface-primary"]) {
  --mdw-ink: var(--mdw-color__primary);
}
:host([color="surface-variant"]) {
  --mdw-bg: var(--mdw-color__surface-variant);
  --mdw-ink: var(--mdw-color__on-surface-variant);
}
:host([color|="inverse"]) {
  --mdw-bg: var(--mdw-color__inverse-surface);
}
:host([color="inverse-surface"]) {
  --mdw-ink: var(--mdw-color__inverse-on-surface);
}
:host([color="inverse-primary"]) {
  --mdw-ink: var(--mdw-color__inverse-primary);
}
:host([disabled]) {
  --mdw-container__elevation__visibility: hidden;
  filter: none;
  box-shadow: none;
}
:host([color|="surface"]) {
}
:host([color|="surface"][elevation="1"]) {
  --mdw-container__elevation__opacity: var(--mdw-container__elevation__opacity__1);
  --mdw-container__box-shadow: var(--mdw-container__box-shadow__1);
}
:host([color|="surface"][elevation="2"]) {
  --mdw-container__elevation__opacity: var(--mdw-container__elevation__opacity__2);
  --mdw-container__box-shadow: var(--mdw-container__box-shadow__2);
}
:host([color|="surface"][elevation="3"]) {
  --mdw-container__elevation__opacity: var(--mdw-container__elevation__opacity__3);
  --mdw-container__box-shadow: var(--mdw-container__box-shadow__3);
}
:host([color|="surface"][elevation="4"]) {
  --mdw-container__elevation__opacity: var(--mdw-container__elevation__opacity__4);
  --mdw-container__box-shadow: var(--mdw-container__box-shadow__4);
}
:host([color|="surface"][elevation="5"]) {
  --mdw-container__elevation__opacity: var(--mdw-container__elevation__opacity__5);
  --mdw-container__box-shadow: var(--mdw-container__box-shadow__5);
}
:host([color][disabled]) {
}
:host([shape-style="extra-small"]) {
  --mdw-shape__size: var(--mdw-shape__extra-small);
}
:host([shape-style="small"]) {
  --mdw-shape__size: var(--mdw-shape__small);
}
:host([shape-style="medium"]) {
  --mdw-shape__size: var(--mdw-shape__medium);
}
:host([shape-style="large"]) {
  --mdw-shape__size: var(--mdw-shape__large);
}
:host([shape-style="extra-large"]) {
  --mdw-shape__size: var(--mdw-shape__extra-large);
}
:host([shape-style="full"]) {
  --mdw-shape__size: var(--mdw-shape__full);
}
:host([shape-top]) {
  --mdw-shape__size__bottom-start-size: 0;
  --mdw-shape__size__bottom-end-size: 0;
}
:host([shape-bottom]) {
  --mdw-shape__size__top-start-size: 0;
  --mdw-shape__size__top-end-size: 0;
}
:host([shape-start]) {
  --mdw-shape__size__top-end-size: 0;
  --mdw-shape__size__bottom-end-size: 0;
}
:host([mdw-shape-end]) {
  --mdw-shape__size__top-start-size: 0;
  --mdw-shape__size__bottom-start-size: 0;
}
#elevation {
  position: absolute;
  inset: 0;
  pointer-events: none;
  transition-delay: 1ms;
  transition-duration: 100ms;
  transition-property:
    opacity,
    color,
    background-color;
  opacity: var(--mdw-container__elevation__opacity);
  visibility: var(--mdw-container__elevation__visibility);
  background-color: rgb(var(--mdw-container__elevation__color));
  border-radius: inherit;
}`;
var styles2;
try {
  styles2 = new CSSStyleSheet();
  styles2.replaceSync(contents2);
} catch (e) {
  styles2 = contents2;
}
var MDWContainer_default = styles2;

// core/container/MDWContainer.js
var _MDWContainer = class extends MDWText {
  constructor() {
    super();
    this.elevationElement = this.shadowRoot.getElementById("elevation");
  }
  attributeChangedCallback(name, oldValue, newValue) {
    super.attributeChangedCallback(name, oldValue, newValue);
    if (oldValue == null && newValue == null)
      return;
    switch (name) {
      case "disabled":
        if (newValue == null) {
          this.setAttribute("aria-disabled", "false");
        } else {
          this.setAttribute("aria-disabled", "true");
        }
        break;
      default:
    }
  }
};
var MDWContainer = _MDWContainer;
__name(MDWContainer, "MDWContainer");
__publicField(MDWContainer, "idlBooleanAttributes", [
  ...__superGet(_MDWContainer, _MDWContainer, "idlBooleanAttributes"),
  "disabled",
  "shape-top",
  "shape-bottom",
  "shape-start",
  "shape-end"
]);
__publicField(MDWContainer, "idlIntegerAttributes", [
  ...__superGet(_MDWContainer, _MDWContainer, "idlIntegerAttributes"),
  "elevation"
]);
__publicField(MDWContainer, "idlStringAttributes", [
  ...__superGet(_MDWContainer, _MDWContainer, "idlStringAttributes"),
  "color",
  "bg",
  "shape-style"
]);
__publicField(MDWContainer, "elementName", "mdw-container");
__publicField(MDWContainer, "styles", [...__superGet(_MDWContainer, _MDWContainer, "styles"), MDWContainer_default]);
__publicField(MDWContainer, "fragments", [
  ...__superGet(_MDWContainer, _MDWContainer, "fragments"),
  `
      <div id=elevation aria-hidden=true></div>
    `
]);

// components/bottomappbar/MDWBottomAppBar.css
init_polyfills();
var contents3 = `/* components/bottomappbar/MDWBottomAppBar.css */
:host {
  --mdw-container__elevation__opacity: var(--mdw-container__elevation__opacity__2);
  display: flex;
  align-items: center;
  gap: 8px;
  justify-content: flex-start;
  box-sizing: border-box;
  block-size: 80px;
  padding-block: 12px;
  padding-inline: 8px 16px;
  background-color: rgb(var(--mdw-color__surface));
  box-shadow: none;
  color: rgb(var(--mdw-color__on-surface));
  direction: ltr;
}
:host([color]:not([color|="surface"])) {
  --mdw-container__elevation__opacity: 0;
}`;
var styles3;
try {
  styles3 = new CSSStyleSheet();
  styles3.replaceSync(contents3);
} catch (e) {
  styles3 = contents3;
}
var MDWBottomAppBar_default = styles3;

// components/bottomappbar/MDWBottomAppBar.js
var _MDWBottomAppBar = class extends MDWContainer {
  connectedCallback() {
    attach3(this);
  }
  disconnectedCallback() {
    detach2(this);
  }
};
var MDWBottomAppBar = _MDWBottomAppBar;
__name(MDWBottomAppBar, "MDWBottomAppBar");
__publicField(MDWBottomAppBar, "ariaRole", "toolbar");
__publicField(MDWBottomAppBar, "elementName", "mdw-bottom-app-bar");
__publicField(MDWBottomAppBar, "styles", [...__superGet(_MDWBottomAppBar, _MDWBottomAppBar, "styles"), MDWBottomAppBar_default]);

// components/button/MDWButton.js
init_polyfills();

// core/input/MDWInput.js
init_polyfills();

// core/ripple/MDWRipple.js
init_polyfills();

// core/overlay/MDWOverlay.js
init_polyfills();

// core/overlay/MDWOverlay.css
init_polyfills();
var contents4 = `/* core/overlay/MDWOverlay.css */
:host {
  position: relative;
  outline: none;
  -webkit-tap-highlight-color: transparent;
}
:host(::-moz-focus-inner) {
  border: 0;
}
:host {
  --mdw-overlay__hover-opacity: 0.08;
  --mdw-overlay__focus-opacity: 0.12;
  --mdw-overlay__pressed-opacity: 0.12;
  --mdw-overlay__dragged-opacity: 0.12;
  --mdw-overlay__visibility: intial;
}
:host(:is([disabled]:not([mdw-overlay-disabled~="hover"]), [mdw-overlay-off~="hover"], :not(:hover))) {
  --mdw-overlay__hover-opacity: 0;
}
:host(:is([disabled]:not([mdw-overlay-disabled~="focus"]), [mdw-overlay-off~="focus"], :not(:focus))) {
  --mdw-overlay__focus-opacity: 0;
}
:host(:is([disabled]:not([mdw-overlay-disabled~="pressed"]), [mdw-overlay-off~="pressed"], :not(:active))) {
  --mdw-overlay__pressed-opacity: 0;
}
:host(:is([disabled]:not([mdw-overlay-disabled~="dragged"]), [mdw-overlay-off~="dragged"], :not([aria-dragged="true"]))) {
  --mdw-overlay__dragged-opacity: 0;
}
#overlay {
  position: absolute;
  inset: 0;
  pointer-events: none;
  transition-delay: 1ms;
  transition-duration: 0ms;
  transition-property:
    opacity,
    color,
    background-color;
  opacity: calc(var(--mdw-overlay__hover-opacity) + var(--mdw-overlay__focus-opacity) + var(--mdw-overlay__pressed-opacity) + var(--mdw-overlay__dragged-opacity));
  visibility: var(--mdw-overlay__visibility);
  background-color: currentColor;
  border-radius: inherit;
}
#overlay[touched] {
  --mdw-overlay__hover-opacity: 0;
  --mdw-overlay__focus-opacity: 0;
}
:host([disabled]:not([mdw-overlay-disabled])) {
  --mdw-overlay__visibility: hidden;
}`;
var styles4;
try {
  styles4 = new CSSStyleSheet();
  styles4.replaceSync(contents4);
} catch (e) {
  styles4 = contents4;
}
var MDWOverlay_default = styles4;

// core/overlay/MDWOverlay.js
var _lastInteraction;
var _MDWOverlay = class extends MDWContainer {
  constructor() {
    super();
    __privateAdd(this, _lastInteraction, null);
    this.overlayElement = this.shadowRoot.getElementById("overlay");
  }
  static onMouseDown(event) {
    if (__privateGet(this, _lastInteraction))
      return;
    __privateSet(this, _lastInteraction, "mouse");
    this.overlayElement.removeAttribute("touched");
  }
  static onTouchStart(event) {
    __privateSet(this, _lastInteraction, "touch");
    this.overlayElement.setAttribute("touched", "");
  }
  static onKeyDown(event) {
    __privateSet(this, _lastInteraction, "key");
    this.overlayElement.removeAttribute("touched");
  }
  static onBlur(event) {
    switch (__privateGet(this, _lastInteraction)) {
      case null:
        return;
      case "touch":
        _MDWOverlay.lastInteractionWasTouch = true;
        this.overlayElement.removeAttribute("touched");
        break;
      default:
        _MDWOverlay.lastInteractionWasTouch = false;
    }
  }
  static onFocus(event) {
    if (!__privateGet(this, _lastInteraction) && _MDWOverlay.lastInteractionWasTouch) {
      __privateSet(this, _lastInteraction, "touch");
      this.overlayElement.setAttribute("touched", "");
    }
  }
  connectedCallback() {
    this.addEventListener("mousedown", _MDWOverlay.onMouseDown, { passive: true });
    this.addEventListener("touchstart", _MDWOverlay.onTouchStart, { passive: true });
    this.addEventListener("keydown", _MDWOverlay.onKeyDown, { passive: true });
    this.addEventListener("blur", _MDWOverlay.onBlur, { passive: true });
    this.addEventListener("focus", _MDWOverlay.onFocus, { passive: true });
  }
  disconnectedCallback() {
    this.removeEventListener("mousedown", _MDWOverlay.onMouseDown);
    this.removeEventListener("touchstart", _MDWOverlay.onTouchStart);
    this.removeEventListener("keydown", _MDWOverlay.onKeyDown);
    this.removeEventListener("blur", _MDWOverlay.onBlur);
    this.removeEventListener("focus", _MDWOverlay.onFocus);
  }
};
var MDWOverlay = _MDWOverlay;
__name(MDWOverlay, "MDWOverlay");
_lastInteraction = new WeakMap();
__publicField(MDWOverlay, "elementName", "mdw-overlay");
__publicField(MDWOverlay, "styles", [...__superGet(_MDWOverlay, _MDWOverlay, "styles"), MDWOverlay_default]);
__publicField(MDWOverlay, "fragments", [
  ...__superGet(_MDWOverlay, _MDWOverlay, "fragments"),
  '<div id="overlay" aria-hidden="true"/>'
]);
__publicField(MDWOverlay, "lastInteractionWasTouch", window?.matchMedia?.("(any-pointer: coarse)").matches);

// core/ripple/MDWRipple.css
init_polyfills();
var contents5 = `/* core/ripple/MDWRipple.css */
:host {
  --enter-delay: 80ms;
  --fade-out-duration: calc(1000ms / 3.0);
  --touch-down-acceleration: 1024;
  --touch-up-acceleration: 3400;
  --mdw-ripple-expand-duration: var(--mdw-motion-expand-duration, 250ms);
  --mdw-ripple-simple-duration: var(--mdw-motion-simple-duration, 100ms);
  --mdw-ripple-standard-easing: var(--mdw-motion-standard-easing, cubic-bezier(0.4, 0.0, 0.2, 1));
  --mdw-ripple-deceleration-easing: var(--mdw-motion-deceleration-easing, cubic-bezier(0.0, 0.0, 0.2, 1));
  --mdw-ripple__visibility: visible;
}
:host(:not([mdw-ripple="none"])) {
  --mdw-overlay__pressed-opacity: 0;
}
:host([mdw-ripple="none"]) {
  --mdw-ripple__visibility: hidden;
}
:host {
  -webkit-tap-highlight-color: transparent;
}
#ripple {
  position: absolute;
  inset: 0;
  overflow: hidden;
  box-sizing: border-box;
  pointer-events: none;
  visibility: var(--mdw-ripple__visibility);
  z-index: 1;
  border-radius: inherit;
}
#ripple-inner {
  --mdw-ripple__fade-in-name: ripple-fade-in;
  display: block;
  position: absolute;
  pointer-events: none;
  animation: var(--mdw-ripple__fade-in-name) var(--mdw-ripple-expand-duration) linear, ripple-fade-out calc(1000ms / 3.0) var(--mdw-ripple-deceleration-easing);
  animation-name: none, none;
  animation-direction: normal;
  animation-fill-mode: forwards;
  transition-delay: 0s;
  transition-duration: var(--mdw-ripple-simple-duration);
  transition-property: background-color, color;
  transition-timing-function: var(--mdw-ripple-standard-easing);
  will-change: transform, opacity;
  opacity: 0.12;
  transform: scale(0);
  background-color: currentColor;
  border-radius: 50%;
}
#ripple-inner[mdw-fade-in-repeat] {
  --mdw-ripple__fade-in-name: ripple-fade-in-repeat;
}
#ripple-inner[mdw-fade-in] {
  animation-name: var(--mdw-ripple__fade-in-name), none;
}
#ripple-inner[mdw-fade-in-complete] {
  animation-name: none, ripple-fade-out;
}
#ripple-inner[mdw-fade-out] {
  animation-name: none, ripple-fade-out;
}
:host(:active) {
  animation-name: var(--mdw-ripple__fade-in-name), none;
}
:host([disabled]) {
  --mdw-ripple__visibility: hidden;
}
@keyframes ripple-fade-in {
  from {
    transform: scale(0);
  }
  to {
    transform: scale(2);
  }
}
@keyframes ripple-fade-in-repeat {
  from {
    transform: scale(0);
  }
  to {
    transform: scale(2);
  }
}
@keyframes ripple-fade-out {
  from {
    transform: scale(2);
  }
  to {
    opacity: 0;
    transform: scale(2);
  }
}`;
var styles5;
try {
  styles5 = new CSSStyleSheet();
  styles5.replaceSync(contents5);
} catch (e) {
  styles5 = contents5;
}
var MDWRipple_default = styles5;

// core/ripple/MDWRipple.js
var _MDWRipple = class extends MDWOverlay {
  constructor() {
    super();
    this.rippleElement = this.shadowRoot.getElementById("ripple");
    this.innerElement = this.shadowRoot.getElementById("ripple-inner");
  }
  updateRipplePosition(x, y) {
    let width;
    let height;
    let xPos;
    let yPos;
    const { clientWidth, clientHeight } = this.rippleElement;
    if (x == null || y == null) {
      width = clientWidth / 2;
      height = clientHeight / 2;
      xPos = width;
      yPos = height;
    } else {
      width = x >= clientWidth / 2 ? x : clientWidth - x;
      height = y >= clientHeight / 2 ? y : clientHeight - y;
      xPos = x;
      yPos = y;
    }
    const hypotenuse = Math.sqrt(width * width + height * height);
    this.innerElement.style.setProperty("height", `${hypotenuse}px`);
    this.innerElement.style.setProperty("width", `${hypotenuse}px`);
    this.innerElement.style.setProperty("left", `${xPos - hypotenuse / 2}px`);
    this.innerElement.style.setProperty("top", `${yPos - hypotenuse / 2}px`);
  }
  drawRipple(initiator, x, y) {
    const currentInitiator = this.innerElement.getAttribute("mdw-fade-in");
    if (currentInitiator && currentInitiator !== initiator)
      return;
    this.updateRipplePosition(x, y);
    this.innerElement.setAttribute("mdw-fade-in", initiator);
    if (currentInitiator === initiator) {
      this.innerElement.removeAttribute("mdw-fade-in-complete");
      if (this.innerElement.hasAttribute("mdw-fade-in-repeat")) {
        this.innerElement.removeAttribute("mdw-fade-in-repeat");
      } else {
        this.innerElement.setAttribute("mdw-fade-in-repeat", "");
      }
    }
  }
  static onAnimationEnd({ animationName }) {
    switch (animationName) {
      case "ripple-fade-in":
      case "ripple-fade-in-repeat":
        this.setAttribute("mdw-fade-in-complete", "");
        break;
      case "ripple-fade-out":
        this.removeAttribute("mdw-fade-in");
        this.removeAttribute("mdw-fade-in-repeat");
        this.removeAttribute("mdw-fade-in-complete");
        this.removeAttribute("mdw-fade-out");
        break;
      default:
    }
  }
  clearRipple() {
    if (!this.innerElement.hasAttribute("mdw-fade-in"))
      return;
    if (!this.innerElement.hasAttribute("mdw-fade-in-complete"))
      return;
    this.innerElement.removeAttribute("mdw-fade-in");
    this.innerElement.removeAttribute("mdw-fade-in-repeat");
    this.innerElement.removeAttribute("mdw-fade-in-complete");
    this.innerElement.setAttribute("mdw-fade-out", "");
  }
  static onMouseDown(event) {
    if (event.button)
      return;
    const rect = this.rippleElement.getBoundingClientRect();
    const x = event.pageX - rect.left - window.pageXOffset;
    const y = event.pageY - rect.top - window.pageYOffset;
    this.drawRipple("mouse", x, y);
  }
  static onTouchStart(event) {
    const [touch] = event.changedTouches;
    if (!touch)
      return;
    const rect = this.rippleElement.getBoundingClientRect();
    const x = touch.pageX - rect.left - window.pageXOffset;
    const y = touch.pageY - rect.top - window.pageYOffset;
    this.drawRipple("touch", x, y);
  }
  static onClick(event) {
    this.drawRipple("click");
  }
  static onKeyDown(event) {
    if (event.repeat)
      return;
    requestAnimationFrame(() => {
      if (!this.matches(":active"))
        return;
      const { host } = this.getRootNode();
      host.drawRipple("key");
    });
  }
  connectedCallback() {
    super.connectedCallback();
    this.innerElement.removeAttribute("mdw-fade-in");
    this.innerElement.removeAttribute("mdw-fade-in-repeat");
    this.innerElement.removeAttribute("mdw-fade-in-complete");
    this.innerElement.removeAttribute("mdw-fade-out");
    this.addEventListener("click", _MDWRipple.onClick, { passive: true });
    this.addEventListener("mousedown", _MDWRipple.onMouseDown, { passive: true });
    this.addEventListener("touchstart", _MDWRipple.onTouchStart, { passive: true });
    this.addEventListener("keydown", _MDWRipple.onKeyDown, { passive: true });
    this.innerElement.addEventListener("animationend", _MDWRipple.onAnimationEnd, { passive: true });
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.removeEventListener("click", _MDWRipple.onClick);
    this.removeEventListener("mousedown", _MDWRipple.onMouseDown);
    this.removeEventListener("touchstart", _MDWRipple.onTouchStart);
    this.removeEventListener("keydown", _MDWRipple.onKeyDown);
  }
};
var MDWRipple = _MDWRipple;
__name(MDWRipple, "MDWRipple");
__publicField(MDWRipple, "elementName", "mdw-ripple");
__publicField(MDWRipple, "styles", [...__superGet(_MDWRipple, _MDWRipple, "styles"), MDWRipple_default]);
__publicField(MDWRipple, "fragments", [
  ...__superGet(_MDWRipple, _MDWRipple, "fragments"),
  `
      <div id="ripple" aria-hidden="true">
        <div id="ripple-inner"></div>
      </div>
    `
]);

// core/input/MDWInput.css
init_polyfills();
var contents6 = `/* core/input/MDWInput.css */
:host {
  --mdw-input__padding-inline-start: 0;
  --mdw-input__padding-inline-end: 0;
  display: inline-flex;
}
:host(::-moz-focus-inner) {
  border: 0;
}
label {
  flex: 1;
}
input {
  position: absolute;
  inset: 0;
  block-size: 100%;
  inline-size: 100%;
  margin: 0;
  border: 0;
  padding: 0;
  -webkit-appearance: none;
  -moz-appearance: none;
  appearance: none;
  cursor: inherit;
  outline: none;
  opacity: 0;
}
input::-moz-focus-inner {
  border: 0;
}
input:active ~ #ripple > #ripple-inner {
  animation-name: var(--mdw-ripple__fade-in-name), none;
}`;
var styles6;
try {
  styles6 = new CSSStyleSheet();
  styles6.replaceSync(contents6);
} catch (e) {
  styles6 = contents6;
}
var MDWInput_default = styles6;

// core/input/MDWInput.js
var _MDWInput = class extends MDWRipple {
  constructor() {
    super();
    this.inputElement = this.shadowRoot.getElementById("input");
    this.labelElement = this.shadowRoot.getElementById("label");
    this.labelElement.append(
      this.overlayElement,
      this.rippleElement,
      this.slotElement
    );
    if (!this.hasAttribute("tabindex")) {
      this.setAttribute("tabindex", "0");
    }
  }
  static get observedAttributes() {
    return [
      ...super.observedAttributes,
      ...this.idlInputElementAttributes,
      "aria-label"
    ];
  }
  attributeChangedCallback(name, oldValue, newValue) {
    super.attributeChangedCallback(name, oldValue, newValue);
    if (oldValue == null && newValue == null)
      return;
    switch (name) {
      case "aria-label":
        if (newValue == null) {
          this.inputElement?.removeAttribute(name);
          if (!this.hasAttribute("aria-labelledby")) {
            this.inputElement?.setAttribute("aria-labelledby", "slot");
          }
        } else {
          this.inputElement?.setAttribute(name, newValue);
          if (!this.hasAttribute("aria-labelledby")) {
            this.inputElement?.removeAttribute("aria-labelledby");
          }
        }
        break;
      case "disabled":
        if (!this.inputElement)
          break;
        switch (this.inputElement.getAttribute("role")) {
          case null:
          case "button":
            this.inputElement.disabled = newValue != null;
            if (newValue === null) {
              this.setAttribute("tabindex", "0");
            } else {
              this.setAttribute("tabindex", "-1");
            }
            break;
          default:
        }
        break;
      default:
    }
    if (_MDWInput.idlInputElementAttributes.includes(name)) {
      if (newValue == null) {
        this.inputElement?.removeAttribute(name);
      } else {
        this.inputElement?.setAttribute(name, newValue);
      }
    }
    if (name === "checked") {
      switch (this.type) {
        case "checkbox":
        case "radio":
          if (newValue == null) {
            console.log("MDWInput.attributeChangedCallback: unset", this.name, "null");
            this.elementInternals.setFormValue(null);
          } else {
            console.log("MDWInput.attributeChangedCallback: set", this.name, this.value ?? "on");
            this.elementInternals.setFormValue(this.value ?? "on");
            const { form } = this.elementInternals;
            if (form) {
              form.dispatchEvent(new CustomEvent(_MDWInput.FORM_IPC_EVENT, { detail: [this.name, this.value] }));
              console.log("MDWInput.attributeChangedCallback: FORM_IPC_EVENT complete");
            }
          }
          break;
        default:
      }
    }
  }
  formAssociatedCallback(form) {
    if (form == null)
      return;
    console.log("Form associated. Adding bind.");
    form.addEventListener(_MDWInput.FORM_IPC_EVENT, this.formIPCEvent.bind(this));
  }
  formIPCEvent(event) {
    if (event.target !== this.elementInternals.form) {
      console.warn("MDWInput.formIPCEvent: Abort from wrong form");
      return;
    }
    if (this.type !== "radio") {
      console.warn("MDWInput.formIPCEvent: Abort from not radio");
      return;
    }
    const [name, value] = event.detail;
    if (this.name !== name)
      return;
    if (value !== this.value) {
      console.log("MDWInput.formIPCEvent: Unset self", this.name, this.value);
      this.checked = false;
      this.removeAttribute("checked");
    } else {
      console.log("MDWInput.formIPCEvent: Continue match", this.name, this.value);
    }
  }
  formDisabledCallback(disabled) {
  }
  formResetCallback() {
    this.value = this.getAttribute("value") || "";
  }
  formStateRestoreCallback(state, mode) {
    this.value = state;
  }
  focus(options) {
    super.focus(options);
    this.inputElement?.focus(options);
  }
  get form() {
    return this.elementInternals.form;
  }
  get name() {
    return this.getAttribute("name");
  }
  get type() {
    return this.inputElement.type;
  }
  set type(value) {
    this.inputElement.type = value;
  }
  get checked() {
    return this.inputElement.checked;
  }
  set checked(value) {
    this.inputElement.checked = value;
  }
  get required() {
    return this.inputElement.required;
  }
  set required(v) {
    this.inputElement.required = v;
  }
  get value() {
    return this.inputElement.value;
  }
  set value(v) {
    console.log("MDWInput.value =", v);
    this.inputElement.value = v;
  }
  get validity() {
    return this.elementInternals.validity;
  }
  get validationMessage() {
    return this.elementInternals.validationMessage;
  }
  get willValidate() {
    return this.elementInternals.willValidate;
  }
  checkValidity() {
    return this.elementInternals.checkValidity();
  }
  reportValidity() {
    return this.elementInternals.reportValidity();
  }
  connectedCallback() {
    super.connectedCallback();
    this.removeEventListener("keydown", MDWRipple.onKeyDown);
    this.inputElement.addEventListener("keydown", MDWRipple.onKeyDown, { passive: true });
  }
};
var MDWInput = _MDWInput;
__name(MDWInput, "MDWInput");
__publicField(MDWInput, "delegatesFocus", true);
__publicField(MDWInput, "formAssociated", true);
__publicField(MDWInput, "FORM_IPC_EVENT", "mdw-input-changed");
__publicField(MDWInput, "idlBooleanAttributes", [
  ...__superGet(_MDWInput, _MDWInput, "idlBooleanAttributes")
]);
__publicField(MDWInput, "idlInputElementAttributes", [
  "aria-labelledby",
  "type",
  "value",
  "checked",
  "name",
  "required",
  "list"
]);
__publicField(MDWInput, "elementName", "mdw-input");
__publicField(MDWInput, "styles", [...__superGet(_MDWInput, _MDWInput, "styles"), MDWInput_default]);
__publicField(MDWInput, "fragments", [
  ...__superGet(_MDWInput, _MDWInput, "fragments"),
  `
      <label id=label>
        <input id=input aria-labelledby="slot" >
      </label>
    `
]);

// components/button/MDWButton.css
init_polyfills();
var contents7 = `/* components/button/MDWButton.css */
:host {
  --mdw-shape__size: 20px;
  --mdw-button__padding-inline-start: 12px;
  --mdw-button__padding-inline-end: 12px;
  --mdw-button__icon__display: none;
  --mdw-button__icon__font-variation-settings: "FILL" 1;
  --mdw-button__icon__margin-inline-start: 12px;
  --mdw-button__icon__margin-inline-end: 8px;
  --mdw-button__icon__opacity: 1;
  --mdw-button__icon__size: 18px;
  --mdw-button__outline__size: 1px;
  --mdw-button__outline__visibility: hidden;
  --mdw-button__outline__opacity: 1;
  --mdw-button__outline__rgb: var(--mdw-color__outline);
  --mdw-button__touch-target__size: 10mm;
  --mdw-ink: var(--mdw-color__primary);
  --mdw-type__font-weight: var(--mdw-typescale__label-large__font-weight);
  --mdw-type__font-size: var(--mdw-typescale__label-large__font-size);
  --mdw-type__line-height: var(--mdw-typescale__label-large__line-height);
  --mdw-type__font-family: var(--mdw-typescale__label-large__font-family);
  --mdw-type__letter-spacing: var(--mdw-typescale__label-large__letter-spacing);
  display: inline-flex;
  align-items: stretch;
  justify-content: center;
  min-block-size: 40px;
  min-inline-size: 48px;
  cursor: pointer;
  color: rgb(var(--mdw-ink));
}
:host(:where([elevated], [filled])) {
  background-color: rgb(var(--mdw-bg));
}
:host(:where([elevated])) {
  --mdw-bg: var(--mdw-color__surface);
  --mdw-ink: var(--mdw-color__primary);
}
:host(:where([filled])) {
  --mdw-bg: var(--mdw-color__primary);
  --mdw-ink: var(--mdw-color__on-primary);
}
:host(:where([filled="tonal"])) {
  --mdw-bg: var(--mdw-color__secondary-container);
  --mdw-ink: var(--mdw-color__on-secondary-container);
}
:host(:where([outlined])) {
  color: rgb(var(--mdw-color__primary));
}
:host(:where([outlined="surface"])) {
  background-color: rgb(var(--mdw-color__surface));
}
:host(:where([outlined], [elevated], [filled], [icon])) {
  --mdw-button__icon__display: block;
  --mdw-button__padding-inline-start: 0;
  --mdw-button__padding-inline-end: 24px;
}
:host(:is([outlined], [elevated], [filled])) {
  --mdw-button__icon__margin-inline-start: 16px;
}
:host([disabled]) {
  --mdw-button__outline__opacity: 0.12;
  cursor: not-allowed;
  color: rgba(var(--mdw-color__on-surface), 0.38);
}
:host([disabled]:is([elevated], [filled])) {
  background: rgba(var(--mdw-color__on-surface), 0.12);
  color: rgba(var(--mdw-color__on-surface), 0.38);
}
:host(:focus) {
  --mdw-button__outline__rgb: var(--mdw-ink);
}
:host(:where([elevated], [filled]:hover:not(:active))) {
  --mdw-container__elevation__opacity: var(--mdw-container__elevation__opacity__1);
  --mdw-container__box-shadow: var(--mdw-container__box-shadow__1);
}
:host([elevated]:hover:not(:active)) {
  --mdw-container__elevation__opacity: var(--mdw-container__elevation__opacity__2);
  --mdw-container__box-shadow: var(--mdw-container__box-shadow__2);
}
:host([outlined]) {
  --mdw-button__outline__visibility: visible;
}
#outline {
  position: absolute;
  inset: 0;
  border-style: solid;
  border-width: var(--mdw-button__outline__size);
  pointer-events: none;
  visibility: var(--mdw-button__outline__visibility);
  border-color: rgba(var(--mdw-button__outline__rgb), var(--mdw-button__outline__opacity));
  border-radius: inherit;
}
#icon {
  --mdw-icon__font-variation-settings: var(--mdw-button__icon__font-variation-settings);
  --mdw-icon__opacity: var(--mdw-button__icon__opacity);
  --mdw-icon__size: var(--mdw-button__icon__size);
  display: var(--mdw-button__icon__display);
  order: -1;
  margin-inline-start: var(--mdw-button__icon__margin-inline-start);
  margin-inline-end: var(--mdw-button__icon__margin-inline-end);
}
:host(:not([icon])) #icon {
  inline-size: 0;
}
:host([disabled]) #icon {
  --mdw-icon__image__opacity: 0.38;
}
#touch-target {
  position: absolute;
  inset-block-start: calc(50% - var(--mdw-button__touch-target__size) / 2);
  inset-inline-start: calc(50% - var(--mdw-button__touch-target__size) / 2);
  block-size: var(--mdw-button__touch-target__size);
  inline-size: var(--mdw-button__touch-target__size);
  visibility: hidden;
}
@media (any-pointer: coarse) {
  #touch-target {
    visibility: visible;
  }
}
label {
  display: flex;
  position: relative;
  align-items: center;
  justify-content: center;
  box-sizing: border-box;
  block-size: auto;
  min-block-size: none;
  max-block-size: none;
  inline-size: auto;
  min-inline-size: none;
  max-inline-size: none;
  flex: 1;
  margin: 0;
  border: none;
  padding: 0;
  padding-inline-start: var(--mdw-button__padding-inline-start);
  padding-inline-end: var(--mdw-button__padding-inline-end);
  cursor: inherit;
  outline: none;
  -webkit-tap-highlight-color: transparent;
  -moz-user-select: none;
  -ms-user-select: none;
  -webkit-user-select: none;
  user-select: none;
  z-index: 0;
  background-color: transparent;
  border-radius: inherit;
  color: inherit;
  font: inherit;
  letter-spacing: inherit;
  text-decoration: none;
  white-space: nowrap;
}
#slot {
  text-align: center;
}
#overlay[touched] ~ #outline {
  --mdw-button__outline__rgb: var(--mdw-color__outline);
}`;
var styles7;
try {
  styles7 = new CSSStyleSheet();
  styles7.replaceSync(contents7);
} catch (e) {
  styles7 = contents7;
}
var MDWButton_default = styles7;

// components/button/MDWButton.js
var _MDWButton = class extends MDWInput {
  constructor() {
    super();
    this.iconElement = this.shadowRoot.getElementById("icon");
    this.touchTargetElement = this.shadowRoot.getElementById("touch-target");
    this.outlineElement = this.shadowRoot.getElementById("outline");
    this.labelElement.append(
      this.iconElement,
      this.rippleElement,
      this.touchTargetElement,
      this.outlineElement
    );
    this.inputElement.setAttribute("role", "button");
    if (!this.hasAttribute("type")) {
      this.type = "button";
    }
  }
  attributeChangedCallback(name, oldValue, newValue) {
    super.attributeChangedCallback(name, oldValue, newValue);
    if (oldValue == null && newValue == null)
      return;
    switch (name) {
      case "icon":
      case "src":
        if (newValue == null) {
          this.iconElement.removeAttribute(name);
        } else {
          this.iconElement.setAttribute(name, newValue);
        }
        break;
      default:
    }
  }
  static onButtonClick(event) {
    if (this.disabled)
      return;
    if (this.type !== "submit")
      return;
    const { host } = this.getRootNode();
    if (host.disabled)
      return;
    const value = null;
    const form = host.elementInternals?.form;
    if (!form)
      return;
    host.elementInternals.setFormValue(value);
    if ((this.type ?? "submit") !== "submit")
      return;
    const duplicatedButton = this.cloneNode();
    duplicatedButton.hidden = true;
    form.append(duplicatedButton);
    if ("requestSubmit" in form) {
      form.requestSubmit(duplicatedButton);
    } else {
      duplicatedButton.click();
    }
    duplicatedButton.remove();
  }
  connectedCallback() {
    super.connectedCallback();
    this.inputElement.addEventListener("click", _MDWButton.onButtonClick, { passive: true });
  }
  disconnectedCallback() {
    this.inputElement.removeEventListener("click", _MDWButton.onButtonClick);
    super.disconnectedCallback();
  }
};
var MDWButton = _MDWButton;
__name(MDWButton, "MDWButton");
__publicField(MDWButton, "idlBooleanAttributes", [
  ...__superGet(_MDWButton, _MDWButton, "idlBooleanAttributes"),
  "elevated",
  "filled",
  "outlined"
]);
__publicField(MDWButton, "idlStringAttributes", [
  ...__superGet(_MDWButton, _MDWButton, "idlStringAttributes"),
  "icon",
  "src"
]);
__publicField(MDWButton, "elementName", "mdw-button");
__publicField(MDWButton, "styles", [...__superGet(_MDWButton, _MDWButton, "styles"), MDWButton_default]);
__publicField(MDWButton, "fragments", [
  ...__superGet(_MDWButton, _MDWButton, "fragments"),
  `
      <div id=touch-target aria-hidden="true"></div>
      <div id=outline aria-hidden="true"></div>
      <mdw-icon id=icon aria-hidden="true"></mdw-icon>
    `
]);

// components/card/MDWCard.js
init_polyfills();

// components/card/MDWCard.css
init_polyfills();
var contents8 = `/* components/card/MDWCard.css */
:host {
  --mdw-shape__size: 12px;
  --mdw-card__elevation__visiblity: visible;
  --mdw-card__outline__size: 1px;
  --mdw-card__outline__visibility: hidden;
  --mdw-card__outline__opacity: 1;
  --mdw-card__outline__rgb: var(--mdw-color__outline);
  display: inline-block;
  position: relative;
  align-items: flex-start;
  box-sizing: border-box;
}
:host([actionable]) {
  --mdw-card__elevation__visiblity: hidden;
  box-shadow: none;
}
:host([disabled]) {
  --mdw-card__outline__opacity: 0.12;
  cursor: not-allowed;
  color: rgba(var(--mdw-color__on-surface), 0.38);
}
:host([disabled]:is([elevated], [filled])) {
  background-color: rgba(var(--mdw-color__on-surface), 0.12);
}
:host([disabled]) #slot::slotted(:first-child) {
  --mdw-card-action-area__pointer-events: none;
}
:host([disabled]) #primary-action {
  visibility: hidden;
}
#elevation {
  visibility: var(--mdw-card__elevation__visiblity);
}
#primary-action::slotted(:first-child) {
  --mdw-ink: inherit;
  --mdw-shape__size: inherit;
  --mdw-container__elevation__opacity: inherit;
  --mdw-container__box-shadow: inherit;
  position: absolute;
  inset: 0;
  padding: 0;
  z-index: 1;
  background-color: transparent;
  color: var(--mdw-ink);
}
:host(:where([elevated])) {
  background-color: rgb(var(--mdw-color__surface));
  color: rgb(var(--mdw-color__on-surface));
}
:host([elevated]) {
  --mdw-container__elevation__opacity: var(--mdw-container__elevation__opacity__1);
  --mdw-container__box-shadow: var(--mdw-container__box-shadow__1);
}
:host(:is([elevated], [filled])[color]:not([color*="surface"])) {
  --mdw-container__elevation__opacity: 0;
}
:host([elevated]) #primary-action:hover {
  --mdw-container__elevation__opacity: var(--mdw-container__elevation__opacity__2);
  --mdw-container__box-shadow: var(--mdw-container__box-shadow__2);
}
:host([elevated]) #primary-action:active {
  --mdw-container__elevation__opacity: var(--mdw-container__elevation__opacity__1);
  --mdw-container__box-shadow: var(--mdw-container__box-shadow__1);
}
:host(:where([filled])) {
  background-color: rgb(var(--mdw-color__surface-variant));
  color: rgb(var(--mdw-color__on-surface-variant));
}
:host([filled]) #primary-action:hover {
  --mdw-container__box-shadow: var(--mdw-container__box-shadow__1);
}
:host([outlined]) {
  --mdw-card__outline__visibility: visible;
}
#outline {
  position: absolute;
  inset: 0;
  border-style: solid;
  border-width: var(--mdw-card__outline__size);
  visibility: var(--mdw-card__outline__visibility);
  border-color: rgba(var(--mdw-card__outline__rgb), var(--mdw-card__outline__opacity));
  border-radius: inherit;
}
#slot {
  overflow: hidden;
}`;
var styles8;
try {
  styles8 = new CSSStyleSheet();
  styles8.replaceSync(contents8);
} catch (e) {
  styles8 = contents8;
}
var MDWCard_default = styles8;

// components/card/MDWCard.js
var _MDWCard = class extends MDWContainer {
};
var MDWCard = _MDWCard;
__name(MDWCard, "MDWCard");
__publicField(MDWCard, "elementName", "mdw-card");
__publicField(MDWCard, "ariaRole", "figure");
__publicField(MDWCard, "styles", [...__superGet(_MDWCard, _MDWCard, "styles"), MDWCard_default]);
__publicField(MDWCard, "fragments", [
  ...__superGet(_MDWCard, _MDWCard, "fragments"),
  `
      <slot id=primary-action name=primary-action></slot>
      <div id=outline></div>
    `
]);

// components/card/MDWCardActionArea.js
init_polyfills();

// components/card/MDWCardActionArea.css
init_polyfills();
var contents9 = `/* components/card/MDWCardActionArea.css */
:host {
  position: relative;
  pointer-events: var(--mdw-card-action-area__pointer-events, auto);
  z-index: 2;
}`;
var styles9;
try {
  styles9 = new CSSStyleSheet();
  styles9.replaceSync(contents9);
} catch (e) {
  styles9 = contents9;
}
var MDWCardActionArea_default = styles9;

// components/card/MDWCardActionArea.js
var _MDWCardActionArea = class extends MDWContainer {
};
var MDWCardActionArea = _MDWCardActionArea;
__name(MDWCardActionArea, "MDWCardActionArea");
__publicField(MDWCardActionArea, "elementName", "mdw-card-action-area");
__publicField(MDWCardActionArea, "styles", [...__superGet(_MDWCardActionArea, _MDWCardActionArea, "styles"), MDWCardActionArea_default]);

// components/chip/MDWChip.js
init_polyfills();

// components/chip/MDWChip.css
init_polyfills();
var contents10 = `/* components/chip/MDWChip.css */
:host {
  --mdw-ink: var(--mdw-color__primary);
  --mdw-shape__size: 8px;
  --mdw-button__icon__size: 18px;
  --mdw-chip__trailing-icon__size: 18px;
  --mdw-chip__trailing-icon__opacity: 1;
  --mdw-chip__trailing-icon__display: block;
  --mdw-chip__trailing-icon__font-variation-settings: "FILL" 1;
  --mdw-chip__label-color: var(--mdw-color__on-surface);
  --mdw-button__padding-inline-end: 16px;
  min-block-size: 32px;
  color: rgb(var(--mdw-chip__label-color));
}
:host([elevated]) {
  color: rgb(var(--mdw-chip__label-color));
}
:host(:where([suggestion])) {
  --mdw-ink: var(--mdw-color__on-surface-variant);
  --mdw-chip__label-color: var(--mdw-ink);
}
.mdw-button__text {
  block-size: 32px;
  padding-inline-start: 0;
  padding-inline-end: 16px;
}
.mdw-button__outline {
  --mdw-button__outline__rgb: var(--mdw-color__outline);
}
:host([elevated]) .mdw-button__outline {
  visibility: hidden;
}
#icon {
  --mdw-button__icon__margin-inline-start: 8px;
  --mdw-button__icon__margin-inline-end: 8px;
  color: rgb(var(--mdw-ink));
}
#slot,
#overlay,
#ripple {
  color: rgb(var(--mdw-chip__label-color));
}
:host([disabled]) :is(#slot, #icon) {
  color: rgba(var(--mdw-color__on-surface), 0.38);
}`;
var styles10;
try {
  styles10 = new CSSStyleSheet();
  styles10.replaceSync(contents10);
} catch (e) {
  styles10 = contents10;
}
var MDWChip_default = styles10;

// components/chip/MDWChip.js
var _MDWChip = class extends MDWButton {
  constructor() {
    super();
    this.setAttribute("outlined", "");
  }
};
var MDWChip = _MDWChip;
__name(MDWChip, "MDWChip");
__publicField(MDWChip, "idlBooleanAttributes", [
  ...__superGet(_MDWChip, _MDWChip, "idlBooleanAttributes"),
  "suggestion"
]);
__publicField(MDWChip, "elementName", "mdw-chip");
__publicField(MDWChip, "styles", [...__superGet(_MDWChip, _MDWChip, "styles"), MDWChip_default]);

// components/chip/MDWFilterChip.js
init_polyfills();

// components/chip/MDWFilterChip.css
init_polyfills();
var contents11 = `/* components/chip/MDWFilterChip.css */
:host {
  --mdw-ink: var(--mdw-color__on-secondary-container);
  --mdw-bg: var(--mdw-color__secondary-container);
  color: rgb(var(--mdw-color__on-surface__variant));
}
#slot,
#overlay,
#ripple,
#icon {
  color: inherit;
}
#label {
  padding: 0;
}
:host(:focus) {
  --mdw-button__outline__rgb: var(--mdw-color__outline);
}
:host([disabled][checked]) {
  background-color: rgba(var(--mdw-color__on-surface), 0.12);
}
:host([checked]) {
  --mdw-button__icon__font-variation-settings: "FILL" 1;
  background-color: rgb(var(--mdw-bg));
  color: rgb(var(--mdw-ink));
}
:host(:not([checked])) {
  background-color: transparent;
  color: rgb(var(--mdw-color__on-surface__variant));
}
#trailing-icon {
  --mdw-icon__size: var(--mdw-chip__trailing-icon__size);
  --mdw-icon__opacity: var(--mdw-chip__trailing-icon__opacity);
  --mdw-icon__display: var(--mdw-chip__trailing-icon__display);
  --mdw-icon__font-variation-settings: var(--mdw-chip__trailing-icon__font-variation-settings);
  position: relative;
  order: 1;
  margin-inline-start: 8px;
  margin-inline-end: 8px;
}
.mdw-chip__checkbox {
  position: absolute;
  max-block-size: 0;
  max-inline-size: 0;
  appearance: none;
  pointer-events: none;
}
:host(:not([trailing-icon])) #trailing-icon {
  --mdw-chip__trailing-icon__size: 0;
}
#check-icon {
  --mdw-icon__size: 0;
  order: -1;
  margin-inline: 8px;
}
:host(:not([icon])) #icon {
  display: none;
}
:host([icon]) #check-icon {
  display: none;
}
:host([checked]) #check-icon {
  --mdw-icon__size: 18px;
}
:host[type=checkbox] :is(#slot, #overlay, #ripple, #icon, #check-icon) {
  color: inherit;
}`;
var styles11;
try {
  styles11 = new CSSStyleSheet();
  styles11.replaceSync(contents11);
} catch (e) {
  styles11 = contents11;
}
var MDWFilterChip_default = styles11;

// components/chip/MDWFilterChip.js
var _MDWFilterChip = class extends MDWChip {
  constructor() {
    super();
    this.checkIconElement = this.shadowRoot.getElementById("check-icon");
    this.trailingIconElement = this.shadowRoot.getElementById("trailing-icon");
    this.labelElement.append(
      this.checkIconElement,
      this.trailingIconElement
    );
    this.inputElement.removeAttribute("role");
    this.inputElement.autocomplete = "off";
    if (!this.hasAttribute("type")) {
      this.type = "checkbox";
      this.attributeChangedCallback("type", null, "checkbox");
    }
    if (this.getAttribute("trailing-icon") === "") {
      this.setAttribute("trailing-icon", "dropdown");
      this.attributeChangedCallback("trailing-icon", null, "dropdown");
    }
  }
  attributeChangedCallback(name, oldValue, newValue) {
    super.attributeChangedCallback(name, oldValue, newValue);
    if (oldValue == null && newValue == null)
      return;
    switch (name) {
      case "trailing-icon":
        if (newValue) {
          this.trailingIconElement.setAttribute("icon", newValue);
        }
        break;
      case "trailing-src":
        if (newValue == null) {
          this.trailingIconElement.removeAttribute("src");
        } else {
          this.trailingIconElement.setAttribute("src", newValue);
        }
        break;
      default:
    }
    super.attributeChangedCallback(name, oldValue, newValue);
  }
  static onInputClick(event) {
    const { host } = this.getRootNode();
    if (host.hasAttribute("disabled")) {
      event.preventDefault();
      return;
    }
    if (this.type !== "radio")
      return;
    if (this.required)
      return;
    if (!this.hasAttribute("checked"))
      return;
    this.checked = false;
    host.toggleAttribute("checked", false);
  }
  static onInputKeydown(event) {
    if (event.key !== "Spacebar" && event.key !== " ")
      return;
    const { host } = this.getRootNode();
    if (host.hasAttribute("disabled")) {
      event.preventDefault();
      return;
    }
    if (this.type !== "radio")
      return;
    if (this.required)
      return;
    if (!this.hasAttribute("checked"))
      return;
    event.preventDefault();
    this.checked = false;
    host.toggleAttribute("checked", false);
    event.preventDefault();
  }
  static onInputChange(event) {
    const { host } = this.getRootNode();
    if (host.hasAttribute("disabled")) {
      event.preventDefault();
      return;
    }
    host.toggleAttribute("checked", this.checked);
  }
  connectedCallback() {
    super.connectedCallback();
    this.inputElement.addEventListener("click", _MDWFilterChip.onInputClick);
    this.inputElement.addEventListener("change", _MDWFilterChip.onInputChange);
    this.inputElement.addEventListener("keydown", _MDWFilterChip.onInputKeydown);
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.inputElement.removeEventListener("click", _MDWFilterChip.onInputClick);
    this.inputElement.removeEventListener("change", _MDWFilterChip.onInputChange);
    this.inputElement.removeEventListener("keydown", _MDWFilterChip.onInputKeydown);
  }
};
var MDWFilterChip = _MDWFilterChip;
__name(MDWFilterChip, "MDWFilterChip");
__publicField(MDWFilterChip, "elementName", "mdw-filter-chip");
__publicField(MDWFilterChip, "styles", [...__superGet(_MDWFilterChip, _MDWFilterChip, "styles"), MDWFilterChip_default]);
__publicField(MDWFilterChip, "fragments", [
  ...__superGet(_MDWFilterChip, _MDWFilterChip, "fragments"),
  `
      <mdw-icon id=check-icon icon=check aria-hidden="true"></mdw-icon>
      <mdw-icon id=trailing-icon aria-hidden="true"></mdw-icon>
    `
]);

// components/dialog/MDWDialog.js
init_polyfills();

// core/aria/modal.js
init_polyfills();
function handleTabKeyPress(event) {
  const focusableElements = this.querySelectorAll([
    'button:not(:disabled):not([tabindex="-1"])',
    '[href]:not(:disabled):not([tabindex="-1"])',
    'input:not(:disabled):not([tabindex="-1"])',
    'select:not(:disabled):not([tabindex="-1"])',
    'textarea:not(:disabled):not([tabindex="-1"])',
    '[tabindex]:not([tabindex="-1"])'
  ].join(", "));
  let foundTarget = false;
  let candidate = null;
  for (const el of focusableElements) {
    if (el === event.target) {
      foundTarget = true;
      if (event.shiftKey) {
        break;
      }
    } else if (event.shiftKey) {
      candidate = el;
    } else if (foundTarget) {
      candidate = el;
      break;
    }
  }
  if (!candidate) {
    candidate = event.shiftKey ? focusableElements[focusableElements.length - 1] : focusableElements[0];
  }
  event.stopPropagation();
  event.preventDefault();
  if (candidate && candidate instanceof HTMLElement) {
    try {
      candidate.focus();
    } catch {
    }
  }
}
__name(handleTabKeyPress, "handleTabKeyPress");

// components/dialog/MDWDialog.css
init_polyfills();
var contents12 = `/* components/dialog/MDWDialog.css */
:host {
  --mdw-shape__size: 28px;
  --mdw-container__elevation__opacity: var(--mdw-container__elevation__opacity__3);
  --mdw-container__box-shadow: var(--mdw-container__box-shadow__3);
  --mdw-bg: var(--mdw-color__surface);
  --mdw-ink: var(--mdw-color__on-surface);
  --mdw-dialog__expand-duration: var(--mdw-motion-expand-duration, 250ms);
  --mdw-dialog__simple-duration: var(--mdw-motion-simple-duration, 100ms);
  --mdw-dialog__standard-easing: var(--mdw-motion-standard-easing, cubic-bezier(0.4, 0.0, 0.2, 1));
  --mdw-dialog__deceleration-easing: var(--mdw-motion-deceleration-easing, cubic-bezier(0.0, 0.0, 0.2, 1));
  --mdw-dialog__fade-in-duration: var(--mdw-motion-fade-in-duration, 150ms);
  --mdw-dialog__scrim__visibility: hidden;
  --mdw-bg: var(--mdw-color__surface);
  --mdw-ink: var(--mdw-color__on-surface);
  --mdw-dialog__edge-distance: 48px;
  position: fixed;
  inset: 0;
  pointer-events: none;
  z-index: 24;
}
@media (min-width: 1440px) {
  :host {
    --mdw-dialog__edge-distance: 56px;
  }
}
dialog {
  display: flex;
  position: fixed;
  inset-block-start: 0;
  inset-inline-start: 0;
  align-items: center;
  flex-direction: row;
  justify-content: center;
  box-sizing: border-box;
  block-size: 100%;
  max-block-size: none;
  inline-size: 100%;
  max-inline-size: none;
  margin: 0;
  border: none;
  padding: var(--mdw-dialog__edge-distance);
  transition: none;
  transition-duration: motion.$fadeOutDuration;
  transition-property: opacity;
  transition-timing-function: motion.$accelerateEasing;
  will-change: opacity;
  opacity: 0;
  z-index: 24;
  background-color: transparent;
}
dialog::backdrop {
  display: none;
}
dialog:modal {
  --mdw-dialog__scrim__visibility: visible;
  pointer-events: auto;
  transition-duration: var(--mdw-dialog__fade-in-duration);
  transition-property: opacity;
  transition-timing-function: var(--mdw-dialog__deceleration-easing);
  opacity: 1;
}
#scrim {
  position: fixed;
  inset: 0;
  overflow-y: scroll;
  overscroll-behavior: none;
  overscroll-behavior: contain;
  scrollbar-width: none;
  block-size: 100%;
  inline-size: 100%;
  cursor: default;
  pointer-events: inherit;
  -webkit-tap-highlight-color: transparent;
  opacity: 0.38;
  visibility: var(--mdw-dialog__scrim__visibility);
  z-index: 0;
  background-color: black;
}
#scrim::-webkit-scrollbar {
  display: none;
}
#scrim::after {
  content: "";
  display: block;
  block-size: 200%;
  inline-size: 200%;
}
@keyframes scaleUpAnimation {
  from {
    transform: scale(0);
  }
  to {
    transform: scale(1);
  }
}
dialog:modal #container {
  animation-name: scaleUpAnimation;
  animation-duration: var(--mdw-dialog__fade-in-duration);
  animation-direction: forwards;
}
#container {
  display: flex;
  position: relative;
  align-items: center;
  flex-direction: column;
  flex-direction: column;
  overflow-y: auto;
  overscroll-behavior: none;
  overscroll-behavior: contain;
  box-sizing: border-box;
  max-block-size: 100%;
  min-inline-size: 280px;
  max-inline-size: 560px;
  flex-shrink: 1;
  padding: 24px;
  will-change: display, transform;
  transform: scale(1);
  transform-origin: bottom center;
  z-index: 24;
  background-color: rgb(var(--mdw-color__surface));
  color: rgb(var(--mdw-color__on-surface-variant));
  -webkit-overflow-scrolling: touch;
}
#headline {
  --mdw-type__font-weight: var(--mdw-typescale__headline-small__font-weight);
  --mdw-type__font-size: var(--mdw-typescale__headline-small__font-size);
  --mdw-type__line-height: var(--mdw-typescale__headline-small__line-height);
  --mdw-type__font-family: var(--mdw-typescale__headline-small__font-family);
  --mdw-type__letter-spacing: var(--mdw-typescale__headline-small__letter-spacing);
  margin-block-end: 16px;
}
#icon {
  --mdw-icon__size: 24px;
  margin-block-end: 16px;
  color: rgb(var(--mdw-color__secondary));
}
#body[slotted] {
  display: block;
  overflow-y: auto;
  border-style: solid none;
  border-width: 1px 0;
  border-color: rgb(var(--mdw-color__outline));
}`;
var styles12;
try {
  styles12 = new CSSStyleSheet();
  styles12.replaceSync(contents12);
} catch (e) {
  styles12 = contents12;
}
var MDWDialog_default = styles12;

// components/dialog/MDWDialog.js
var _MDWDialog = class extends MDWComponent {
  constructor() {
    super();
    this.dialogElement = this.shadowRoot.getElementById("dialog");
    this.scrimElement = this.shadowRoot.getElementById("scrim");
    this.containerElement = this.shadowRoot.getElementById("container");
    this.iconElement = this.shadowRoot.getElementById("icon");
    this.headlineElement = this.shadowRoot.getElementById("headline");
    this.descriptionElement = this.shadowRoot.getElementById("description");
    this.bodyElement = this.shadowRoot.getElementById("body");
    this.cancelElement = this.shadowRoot.getElementById("cancel");
    this.confirmElement = this.shadowRoot.getElementById("confirm");
    this.bodyElement.addEventListener("slotchange", _MDWDialog.onSlotChanged);
  }
  attributeChangedCallback(name, oldValue, newValue) {
    super.attributeChangedCallback(name, oldValue, newValue);
    if (oldValue == null && newValue == null)
      return;
    switch (name) {
      case "icon":
        this.iconElement.textContent = newValue ?? "";
        break;
      case "title":
        this.headlineElement.textContent = newValue ?? "";
        break;
      case "description":
        this.descriptionElement.textContent = newValue ?? "";
        break;
      case "cancel":
        this.cancelElement.textContent = newValue ?? "";
        break;
      case "confirm":
        this.confirmElement.textContent = newValue ?? "";
        break;
      case "default":
        this.confirmElement.toggleAttribute("autofocus", newValue == null || newValue === "confirm");
        this.cancelElement.toggleAttribute("autofocus", newValue === "cancel");
        break;
      case "open":
        if (newValue == null) {
          this.dialogElement.setAttribute("aria-hidden", "true");
        } else {
          this.dialogElement.setAttribute("aria-hidden", "false");
        }
        break;
      default:
    }
  }
  static onTransitionEnd(event) {
    console.log("transition end");
    if (event.propertyName !== "opacity")
      return;
    if (this.getAttribute("aria-hidden") !== "true")
      return;
    this.setAttribute("mdw-ready", "");
  }
  static onSlotChanged(event) {
    const nodes = this.assignedNodes();
    const hasContent = nodes.some((node) => node.nodeType === node.ELEMENT_NODE || node.nodeType === node.TEXT_NODE && node.nodeValue.trim().length);
    this.toggleAttribute("slotted", hasContent);
  }
  close(returnValue) {
    if (!this.open)
      return false;
    if (_MDWDialog.supportsHTMLDialogElement && this.dialogElement.open) {
      this.dialogElement.close(returnValue);
    } else {
      this.dialogElement.returnValue = returnValue;
    }
    this.open = false;
    dispatchEvent(new Event("close"));
    let stackIndex = -1;
    _MDWDialog.OPEN_DIALOGS.some((stack, index) => {
      if (stack.element === this) {
        stackIndex = index;
        return true;
      }
      return false;
    });
    if (stackIndex !== -1) {
      const stack = _MDWDialog.OPEN_DIALOGS[stackIndex];
      if (stack.previousFocus && stack.previousFocus instanceof HTMLElement && document.activeElement?.closest(_MDWDialog.elementName) === this) {
        try {
          stack.previousFocus.focus();
        } catch {
        }
      }
      _MDWDialog.OPEN_DIALOGS.splice(stackIndex, 1);
      if (stack.state === window.history.state) {
        window.history.back();
      }
    }
    if (!_MDWDialog.OPEN_DIALOGS.length) {
      window.removeEventListener("popstate", _MDWDialog.onPopState);
    }
    return true;
  }
  static onScrimClick(event) {
    const { host } = this.getRootNode();
    const cancelEvent = new Event("cancel", { cancelable: true });
    if (!host.dispatchEvent(cancelEvent))
      return;
    host.close();
  }
  static onContainerKeyDown(event) {
    if (event.key === "Tab") {
      if (!_MDWDialog.supportsHTMLDialogElement) {
        handleTabKeyPress(event);
      }
      return;
    }
    if (event.key === "Escape" || event.key === "Esc") {
      event.preventDefault();
      event.stopPropagation();
      const { host } = this.getRootNode();
      const cancelEvent = new Event("cancel", { cancelable: true });
      if (this.dispatchEvent(cancelEvent)) {
        host.close();
      }
    }
  }
  static onNativeCancelEvent(event) {
    console.log("onNativeCancelEvent");
    event.stopPropagation();
    const { host } = this.getRootNode();
    const cancelEvent = new Event("cancel", { cancelable: true });
    if (!host.dispatchEvent(cancelEvent)) {
      event.preventDefault();
    }
  }
  static onNativeCloseEvent(event) {
    event.stopPropagation();
    const { host } = this.getRootNode();
    host.close(this.returnValue);
  }
  connectedCallback() {
    this.dialogElement.addEventListener("cancel", _MDWDialog.onNativeCancelEvent);
    this.dialogElement.addEventListener("close", _MDWDialog.onNativeCloseEvent, { passive: true });
    this.scrimElement.addEventListener("click", _MDWDialog.onScrimClick, { passive: true });
    this.containerElement.addEventListener("keydown", _MDWDialog.onContainerKeyDown);
    if (_MDWDialog.supportsHTMLDialogElement) {
      this.dialogElement.setAttribute("aria-modal", "true");
      if (!this.dialogElement.hasAttribute("aria-hidden")) {
        this.setAttribute("aria-hidden", "true");
      }
    }
  }
  disconnectedCallback() {
    this.dialogElement.removeEventListener("cancel", _MDWDialog.onNativeCancelEvent);
    this.dialogElement.removeEventListener("close", _MDWDialog.onNativeCloseEvent);
    this.scrimElement.removeEventListener("click", _MDWDialog.onScrimClick);
    this.containerElement.removeEventListener("keydown", _MDWDialog.onContainerKeyDown);
  }
  static onPopState(event) {
    console.log("popstate", event);
    if (!event.state)
      return;
    console.log("popstate");
    const lastOpenDialog = _MDWDialog.OPEN_DIALOGS.at(-1);
    if (!lastOpenDialog || !lastOpenDialog.previousState) {
      return;
    }
    if (lastOpenDialog.previousState === event.state || Object.entries(event.state).every(([key, value]) => value === lastOpenDialog.previousState[key])) {
      console.log("will close", lastOpenDialog.previousState, event.state, lastOpenDialog.previousState, event.state);
      const cancelEvent = new Event("cancel", { cancelable: true });
      if (lastOpenDialog.element.dispatchEvent(cancelEvent)) {
        lastOpenDialog.element.close();
      } else {
        window.history.pushState(lastOpenDialog.state, lastOpenDialog.state.title);
      }
    }
  }
  get returnValue() {
    return this.dialogElement.returnValue;
  }
  show(event) {
    if (this.open)
      return false;
    this.open = true;
    if (_MDWDialog.supportsHTMLDialogElement && !this.dialogElement.open) {
      this.dialogElement.showModal();
    }
    const previousFocus = document.activeElement;
    const title = this.title || this.description;
    const newState = { time: Date.now(), random: Math.random(), title };
    let previousState = null;
    if (!window.history.state) {
      window.history.replaceState({}, document.title);
    }
    previousState = window.history.state;
    window.history.pushState(newState, title);
    window.addEventListener("popstate", _MDWDialog.onPopState);
    const dialogStack = {
      element: this,
      previousFocus,
      state: newState,
      previousState
    };
    _MDWDialog.OPEN_DIALOGS.push(dialogStack);
    const focusElement = this.querySelector("[autofocus]") ?? this.shadowRoot.querySelector("[autofocus]");
    try {
      if (focusElement && focusElement instanceof HTMLElement) {
        if (focusElement.scrollIntoView) {
          focusElement.scrollIntoView();
        }
        focusElement.focus();
      } else {
        this.containerElement.focus();
      }
    } catch {
    }
    return true;
  }
};
var MDWDialog = _MDWDialog;
__name(MDWDialog, "MDWDialog");
__publicField(MDWDialog, "supportsHTMLDialogElement", typeof HTMLDialogElement !== "undefined");
__publicField(MDWDialog, "ariaRole", "none");
__publicField(MDWDialog, "OPEN_DIALOGS", []);
__publicField(MDWDialog, "elementName", "mdw-dialog");
__publicField(MDWDialog, "idlStringAttributes", [
  ...__superGet(_MDWDialog, _MDWDialog, "idlStringAttributes"),
  "title",
  "description",
  "icon",
  "default",
  "cancel",
  "confirm"
]);
__publicField(MDWDialog, "idlBooleanAttributes", [
  ...__superGet(_MDWDialog, _MDWDialog, "idlBooleanAttributes"),
  "open"
]);
__publicField(MDWDialog, "styles", [...__superGet(_MDWDialog, _MDWDialog, "styles"), MDWDialog_default]);
__publicField(MDWDialog, "fragments", [
  ...__superGet(_MDWDialog, _MDWDialog, "fragments"),
  `
      <dialog id=dialog role="dialog" aria-hidden="true" aria-labelledby="headline" aria-describedby="description">
        <div id=scrim aria-hidden="true"></div>
        <form id=form method="dialog" role=none>
          <mdw-container id=container>
            <mdw-icon id=icon aria-hidden="true"></mdw-icon>
            <mdw-text id=headline role="header"></mdw-text>
            <div id=description></div>
            <slot id=body></slot>
            <div id=actions>
              <mdw-button id=cancel type=submit value="cancel">Cancel</mdw-button>
              <mdw-button id=confirm type=submit value="confirm" autofocus>Confirm</mdw-button>
            </div>
          </mdw-container>
        </form>
      </dialog>
    `
]);
MDWDialog.prototype.showModal = MDWDialog.prototype.show;

// components/divider/MDWDivider.js
init_polyfills();

// components/divider/MDWDivider.css
init_polyfills();
var contents13 = `/* components/divider/MDWDivider.css */
:host {
  inline-size: 100%;
  margin-block-start: -1px;
  border-block-end: 1px solid;
  background-color: currentColor;
  color: rgb(var(--mdw-color__outline-variant));
}
:host([mdw-vertical]) {
  writing-mode: vertical-lr;
}`;
var styles13;
try {
  styles13 = new CSSStyleSheet();
  styles13.replaceSync(contents13);
} catch (e) {
  styles13 = contents13;
}
var MDWDivider_default = styles13;

// components/divider/MDWDivider.js
var _MDWIcon = class extends MDWContainer {
};
var MDWIcon = _MDWIcon;
__name(MDWIcon, "MDWIcon");
__publicField(MDWIcon, "elementName", "mdw-divider");
__publicField(MDWIcon, "styles", [...__superGet(_MDWIcon, _MDWIcon, "styles"), MDWDivider_default]);

// components/fab/MDWExtendedFab.js
init_polyfills();

// components/fab/MDWExtendedFab.css
init_polyfills();
var contents14 = `/* components/fab/MDWExtendedFab.css */
:host {
  --mdw-shape__size: 16px;
  --mdw-fab__elevation__opacity: var(--mdw-container__elevation__opacity__3);
  --mdw-fab__box-shadow: var(--mdw-container__box-shadow__3);
  --mdw-fab__elevation__opacity__hovered: var(--mdw-container__elevation__opacity__4);
  --mdw-fab__box-shadow__hovered: var(--mdw-container__box-shadow__4);
  --mdw-container__elevation__opacity: var(--mdw-fab__elevation__opacity);
  --mdw-container__box-shadow: var(--mdw-fab__box-shadow);
  --mdw-button__icon__size: 24px;
  --mdw-button__padding-inline-start: 20px;
  --mdw-button__padding-inline-end: 20px;
  --mdw-button__icon__display: none;
  min-block-size: 56px;
  min-inline-size: 80px;
}
:host([icon]) {
  --mdw-button__icon__display: block;
  --mdw-button__icon__margin-inline-start: 16px;
  --mdw-button__icon__margin-inline-end: 12px;
  --mdw-button__padding-inline-start: 0;
}
:host([lowered]) {
  --mdw-fab__elevation__opacity: var(--mdw-container__elevation__opacity__1);
  --mdw-fab__box-shadow: var(--mdw-container__box-shadow__1);
  --mdw-fab__elevation__opacity__hovered: var(--mdw-container__elevation__opacity__2);
  --mdw-fab__box-shadow__hovered: var(--mdw-container__box-shadow__2);
}
:host(:hover:not(:active)) {
  --mdw-container__elevation__opacity: var(--mdw-fab__elevation__opacity__hovered);
  --mdw-container__box-shadow: var(--mdw-fab__box-shadow__hovered);
}`;
var styles14;
try {
  styles14 = new CSSStyleSheet();
  styles14.replaceSync(contents14);
} catch (e) {
  styles14 = contents14;
}
var MDWExtendedFab_default = styles14;

// components/fab/MDWExtendedFab.js
var _MDWExtendedFab = class extends MDWButton {
};
var MDWExtendedFab = _MDWExtendedFab;
__name(MDWExtendedFab, "MDWExtendedFab");
__publicField(MDWExtendedFab, "elementName", "mdw-extended-fab");
__publicField(MDWExtendedFab, "idlBooleanAttributes", [
  ...__superGet(_MDWExtendedFab, _MDWExtendedFab, "idlBooleanAttributes"),
  "lowered"
]);
__publicField(MDWExtendedFab, "styles", [...__superGet(_MDWExtendedFab, _MDWExtendedFab, "styles"), MDWExtendedFab_default]);

// components/fab/MDWFab.js
init_polyfills();

// components/fab/MDWFab.css
init_polyfills();
var contents15 = `/* components/fab/MDWFab.css */
:host {
  --mdw-shape__size: 16px;
  --mdw-fab__elevation__opacity: var(--mdw-container__elevation__opacity__3);
  --mdw-fab__box-shadow: var(--mdw-container__box-shadow__3);
  --mdw-fab__elevation__opacity__hovered: var(--mdw-container__elevation__opacity__4);
  --mdw-fab__box-shadow__hovered: var(--mdw-container__box-shadow__4);
  --mdw-container__elevation__opacity: var(--mdw-fab__elevation__opacity);
  --mdw-container__box-shadow: var(--mdw-fab__box-shadow);
  --mdw-button__icon__display: block;
  --mdw-button__icon__size: 24px;
  min-block-size: 56px;
  min-inline-size: 56px;
  background-color: rgb(var(--mdw-color__primary-container));
  color: rgb(var(--mdw-color__on-primary-container));
}
label {
  padding: 0;
}
#icon {
  margin: 0;
}
:host([size="small"]) {
  --mdw-shape__size: 12px;
  min-block-size: 40px;
  min-inline-size: 40px;
}
:host([size="large"]) {
  --mdw-shape__size: 28px;
  --mdw-button__icon__size: 36px;
  min-block-size: 96px;
  min-inline-size: 96px;
}`;
var styles15;
try {
  styles15 = new CSSStyleSheet();
  styles15.replaceSync(contents15);
} catch (e) {
  styles15 = contents15;
}
var MDWFab_default = styles15;

// components/fab/MDWFab.js
var _MDWFab = class extends MDWExtendedFab {
  constructor() {
    super();
    this.setAttribute("icon", "");
    this.iconElement.appendChild(this.slotElement);
  }
};
var MDWFab = _MDWFab;
__name(MDWFab, "MDWFab");
__publicField(MDWFab, "idlStringAttributes", [
  ...__superGet(_MDWFab, _MDWFab, "idlStringAttributes"),
  "size"
]);
__publicField(MDWFab, "elementName", "mdw-fab");
__publicField(MDWFab, "styles", [...__superGet(_MDWFab, _MDWFab, "styles"), MDWFab_default]);

// components/iconbutton/MDWIconButton.js
init_polyfills();

// components/iconbutton/MDWIconButton.css
init_polyfills();
var contents16 = `/* components/iconbutton/MDWIconButton.css */
:host {
  --mdw-shape__size: var(--mdw-shape__full);
  --mdw-container__box-shadow: none;
  --mdw-container__elevation__opacity: 0;
  --mdw-button__icon__size: 24px;
  --mdw-button__icon__display: block;
  --mdw-button__outline__opacity: 1;
  --mdw-button__icon__font-variation-settings: "FILL" 0;
  --mdw-icon-button__background-alpha: 1;
  --mdw-button__outline__size: 0;
  --mdw-ink: var(--mdw-color__on-surface-variant);
  block-size: 40px;
  min-block-size: 40px;
  inline-size: 40px;
  min-inline-size: 40px;
}
:host(:where([type="checkbox"])[checked]) {
  --mdw-button__icon__font-variation-settings: "FILL" 1;
}
:host(:where([type="checkbox"]):not([checked])) {
  color: rgb(var(--mdw-color__on-surface-variant));
}
:host(:where([filled])) {
  --mdw-ink: var(--mdw-color__on-primary);
  --mdw-bg: var(--mdw-color__primary);
  --mdw-button__icon__font-variation-settings: "FILL" 1;
}
:host(:where([filled="tonal"])) {
  --mdw-ink: var(--mdw-color__on-secondary-container);
  --mdw-bg: var(--mdw-color__secondary-container);
}
:host(:where([filled][type="checkbox"]):not([checked])) {
  --mdw-button__icon__font-variation-settings: "FILL" 0;
  background-color: rgb(var(--mdw-color__surface-variant));
  color: rgb(var(--mdw-bg));
}
:host(:where([filled="tonal"][type="checkbox"]):not([checked])) {
  --mdw-button__icon__font-variation-settings: "FILL" 0;
  background-color: rgb(var(--mdw-color__surface-variant));
  color: rgb(var(--mdw-color__on-surface-variant));
}
:host(:where([outlined])) {
  --mdw-bg: var(--mdw-color__inverse-surface);
  --mdw-ink: var(--mdw-color__inverse-on-surface);
  --mdw-button__icon__font-variation-settings: "FILL" 0;
  --mdw-button__outline__size: 1px;
  background-color: transparent;
  color: rgb(var(--mdw-color__on-surface-variant));
}
:host(:where([outlined][type="checkbox"]):not([checked])) {
  background-color: transparent;
  color: rgb(var(--mdw-color__on-surface-variant));
}
:host(:where([outlined][type="checkbox"])[checked]) {
  --mdw-button__icon__font-variation-settings: "FILL" 1;
  --mdw-button__outline__size: 0;
  background-color: rgba(var(--mdw-bg), var(--mdw-icon-button__background-alpha));
  color: rgb(var(--mdw-ink));
}
:host([disabled]) {
  --mdw-button__outline__opacity: 0.12;
  --mdw-icon-button__background-alpha: 0.12;
  cursor: not-allowed;
  color: rgba(var(--mdw-color__on-surface), 0.38);
}
:host([disabled]:is([filled], [outlined][type="checkbox"][checked])) {
  background-color: rgba(var(--mdw-color__on-surface), 0.12);
}
:host(:focus) {
  --mdw-button__outline__rgb: var(--mdw-color__outline);
}
:host([ink]:focus) {
  --mdw-button__outline__rgb: var(--mdw-ink);
}
label {
  padding: 0;
}
#icon {
  margin: 0;
}`;
var styles16;
try {
  styles16 = new CSSStyleSheet();
  styles16.replaceSync(contents16);
} catch (e) {
  styles16 = contents16;
}
var MDWIconButton_default = styles16;

// components/iconbutton/MDWIconButton.js
var _MDWIconButton = class extends MDWButton {
  constructor() {
    super();
    this.setAttribute("icon", "");
    this.iconElement.appendChild(this.slotElement);
  }
  attributeChangedCallback(name, oldValue, newValue) {
    super.attributeChangedCallback(name, oldValue, newValue);
    if (oldValue == null && newValue == null)
      return;
    switch (name) {
      case "type":
        if (newValue === null) {
          this.inputElement.removeAttribute("aria-pressed");
        } else if (newValue === "checkbox") {
          this.inputElement.setAttribute("aria-pressed", this.checked ? "true" : "false");
        }
        break;
      case "checked":
        if (this.type !== "checkbox") {
          this.inputElement.removeAttribute("aria-pressed");
        }
        this.inputElement.setAttribute("aria-pressed", newValue == null ? "false" : "true");
        break;
      default:
    }
  }
  static onInputChange(event) {
    if (this.type !== "checkbox")
      return;
    if (this.disabled)
      return;
    const { host } = this.getRootNode();
    host.toggleAttribute("checked", this.checked);
  }
  static onInputKeyDown(event) {
    if (event.key !== "Enter")
      return;
    if (this.type !== "checkbox")
      return;
    event.stopPropagation();
    event.preventDefault();
    if (this.disabled)
      return;
    const clickEvent = new Event("click", { bubbles: true, cancelable: true, composed: true });
    if (!this.dispatchEvent(clickEvent))
      return;
    this.checked = !this.checked;
    this.dispatchEvent(new Event("change", { bubbles: true }));
  }
  connectedCallback() {
    super.connectedCallback();
    this.inputElement.addEventListener("change", _MDWIconButton.onInputChange, { passive: true });
    this.inputElement.addEventListener("keydown", _MDWIconButton.onInputKeyDown);
  }
  disconnectedCallback() {
    this.inputElement.removeEventListener("change", _MDWIconButton.onInputChange);
    this.inputElement.removeEventListener("keydown", _MDWIconButton.onInputKeyDown);
    super.disconnectedCallback();
  }
};
var MDWIconButton = _MDWIconButton;
__name(MDWIconButton, "MDWIconButton");
__publicField(MDWIconButton, "elementName", "mdw-icon-button");
__publicField(MDWIconButton, "styles", [...__superGet(_MDWIconButton, _MDWIconButton, "styles"), MDWIconButton_default]);

// components/segmentedbutton/MDWSegmentedButton.js
init_polyfills();

// components/segmentedbutton/MDWSegmentedButton.css
init_polyfills();
var contents17 = `/* components/segmentedbutton/MDWSegmentedButton.css */
:host {
  --mdw-shape__size: 0;
  --mdw-button__icon__font-variation-settings: "FILL" 0;
  --mdw-button__outline__size: 1px;
  --mdw-ink: var(--mdw-color__on-surface);
  color: rgb(var(--mdw-ink));
}
:host(:first-child) {
  --mdw-shape__size__top-start-size: var(--mdw-shape__full);
  --mdw-shape__size__top-end-size: 0;
  --mdw-shape__size__bottom-start-size: var(--mdw-shape__full);
  --mdw-shape__size__bottom-end-size: 0;
}
:host(:last-child) {
  --mdw-shape__size__top-start-size: 0;
  --mdw-shape__size__top-end-size: var(--mdw-shape__full);
  --mdw-shape__size__bottom-start-size: 0;
  --mdw-shape__size__bottom-end-size: var(--mdw-shape__full);
}
#outline {
  inset-inline-end: calc(-1 * var(--mdw-button__outline__size));
  border-inline-start-width: var(--mdw-button__outline__size);
  border-inline-end-width: var(--mdw-button__outline__size);
}
:host(:first-child) #outline {
  border-inline-start-width: var(--mdw-button__outline__size);
}
:host(:last-child) #outline {
  inset-inline-end: 0;
  border-inline-end-width: var(--mdw-button__outline__size);
}
:host(:focus) {
  --mdw-button__outline__rgb: var(--mdw-color__outline);
}
:host([disabled]:is([checked])) {
  background-color: rgba(var(--mdw-color__on-surface), 0.12);
}
:host([checked]) {
  --mdw-ink: inherit;
  --mdw-bg: inherit;
  background-color: rgb(var(--mdw-bg));
}
:host([type="checkbox"]:not([checked])) {
  --mdw-button__icon__size: 0;
  --mdw-button__icon__opacity: 0;
}
#icon {
  display: none;
}
#check-icon {
  --mdw-icon__font-variation-settings: "FILL" 1;
  --mdw-icon__size: 0;
  --mdw-icon__opacity: 0;
  display: var(--mdw-button__icon__display);
  order: -1;
  margin-inline-start: var(--mdw-button__icon__margin-inline-start);
  margin-inline-end: var(--mdw-button__icon__margin-inline-end);
}
:host([checked]) #check-icon {
  --mdw-icon__size: 18px;
  --mdw-icon__opacity: 1;
}
:host([icon]) #icon {
  display: block;
}
:host([icon]) #check-icon {
  --mdw-icon__size: 18px;
  --mdw-icon__opacity: 0;
  position: absolute;
  inset-inline-start: var(--mdw-button__icon__margin-inline-start);
  overflow: visible;
  margin: 0;
}
:host([icon][checked]) #icon {
  --mdw-icon__opacity: 0;
}
:host([icon][checked]) #check-icon {
  --mdw-icon__size: 18px;
  --mdw-icon__opacity: 1;
}`;
var styles17;
try {
  styles17 = new CSSStyleSheet();
  styles17.replaceSync(contents17);
} catch (e) {
  styles17 = contents17;
}
var MDWSegmentedButton_default = styles17;

// components/segmentedbutton/MDWSegmentedButton.js
var _MDWSegmentedButton = class extends MDWButton {
  constructor() {
    super();
    this.checkIconElement = this.shadowRoot.getElementById("check-icon");
    this.outlined = true;
    this.setAttribute("mdw-overlay-disabled", "focus");
    if (!this.hasAttribute("type")) {
      this.type = "radio";
      this.attributeChangedCallback("type", null, "radio");
    }
    this.inputElement.setAttribute("role", "option");
    this.labelElement.appendChild(this.checkIconElement);
  }
  attributeChangedCallback(name, oldValue, newValue) {
    if (name === "disabled") {
      this.inputElement.setAttribute("aria-disabled", newValue == null ? "false" : "true");
      return;
    }
    super.attributeChangedCallback(name, oldValue, newValue);
    if (name === "checked" || name === "type") {
      const attribute = this.type === "checkbox" ? "aria-checked" : "aria-selected";
      this.inputElement.setAttribute(attribute, this.checked ? "true" : "false");
    }
  }
  static onInputClick(event) {
    const { host } = this.getRootNode();
    if (host.hasAttribute("disabled")) {
      event.preventDefault();
      return;
    }
    if (this.type !== "radio")
      return;
    if (this.required)
      return;
    if (!this.hasAttribute("checked"))
      return;
    this.checked = false;
    host.toggleAttribute("checked", false);
  }
  static onInputKeydown(event) {
    if (event.key !== "Spacebar" && event.key !== " ")
      return;
    const { host } = this.getRootNode();
    if (host.hasAttribute("disabled")) {
      event.preventDefault();
      return;
    }
    if (this.type !== "radio")
      return;
    if (this.required)
      return;
    if (!this.hasAttribute("checked"))
      return;
    event.preventDefault();
    this.checked = false;
    host.toggleAttribute("checked", false);
    event.preventDefault();
  }
  static onInputChange(event) {
    const { host } = this.getRootNode();
    if (host.hasAttribute("disabled")) {
      event.preventDefault();
      return;
    }
    host.toggleAttribute("checked", this.checked);
  }
  connectedCallback() {
    super.connectedCallback();
    attach2(this);
    this.inputElement.addEventListener("click", _MDWSegmentedButton.onInputClick);
    this.inputElement.addEventListener("change", _MDWSegmentedButton.onInputChange);
    this.inputElement.addEventListener("keydown", _MDWSegmentedButton.onInputKeydown);
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    detach(this);
    this.inputElement.removeEventListener("click", _MDWSegmentedButton.onInputClick);
    this.inputElement.removeEventListener("change", _MDWSegmentedButton.onInputChange);
    this.inputElement.removeEventListener("keydown", _MDWSegmentedButton.onInputKeydown);
  }
};
var MDWSegmentedButton = _MDWSegmentedButton;
__name(MDWSegmentedButton, "MDWSegmentedButton");
__publicField(MDWSegmentedButton, "ariaRole", "none");
__publicField(MDWSegmentedButton, "elementName", "mdw-segmented-button");
__publicField(MDWSegmentedButton, "styles", [...__superGet(_MDWSegmentedButton, _MDWSegmentedButton, "styles"), MDWSegmentedButton_default]);
__publicField(MDWSegmentedButton, "fragments", [
  ...__superGet(_MDWSegmentedButton, _MDWSegmentedButton, "fragments"),
  `
      <mdw-icon id=check-icon icon=check aria-hidden="true"></mdw-icon>
    `
]);

// components/segmentedbutton/MDWSegmentedButtonGroup.js
init_polyfills();

// components/segmentedbutton/MDWSegmentedButtonGroup.css
init_polyfills();
var contents18 = `/* components/segmentedbutton/MDWSegmentedButtonGroup.css */
:host {
  --mdw-bg: var(--mdw-color__secondary-container);
  --mdw-ink: var(--mdw-color__on-secondary-container);
  display: flex;
}
:host([color]) {
  background-color: transparent;
}`;
var styles18;
try {
  styles18 = new CSSStyleSheet();
  styles18.replaceSync(contents18);
} catch (e) {
  styles18 = contents18;
}
var MDWSegmentedButtonGroup_default = styles18;

// components/segmentedbutton/MDWSegmentedButtonGroup.js
var _MDWSegmentedButtonGroup = class extends MDWContainer {
  constructor() {
    super();
    this.setAttribute("aria-orientation", "horizontal");
    this.slotElement.addEventListener("slotchange", _MDWSegmentedButtonGroup.onSlotChanged, { passive: true });
  }
  static onSlotChanged(event) {
    const { host } = this.getRootNode();
    setupTabIndexes(host.childSegmentedButtons, true);
  }
  static onKeyDownEvent(event) {
    if (event.ctrlKey)
      return;
    if (event.shiftKey)
      return;
    if (event.altKey)
      return;
    if (event.metaKey)
      return;
    let selectNext2;
    switch (event.key) {
      case "ArrowLeft":
      case "Left":
        selectNext2 = false;
        break;
      case "ArrowRight":
      case "Right":
        selectNext2 = true;
        break;
      case "ArrowUp":
      case "Up":
      case "ArrowDown":
      case "Down":
        break;
      default:
        return;
    }
    event.preventDefault();
    if (selectNext2 == null)
      return;
    if (getComputedStyle(this).direction === "rtl") {
      selectNext2 = !selectNext2;
    }
    this.ariaActiveDescendantElement = selectNext2 ? selectNext(this.childSegmentedButtons) : selectPrevious(this.childSegmentedButtons);
  }
  get childSegmentedButtons() {
    return this.querySelectorAll(MDWSegmentedButton.elementName);
  }
  static onTabIndexZeroed(event) {
    event.stopPropagation();
    const currentItem = event.target;
    removeTabIndex(this.childSegmentedButtons, [currentItem]);
  }
  connectedCallback() {
    this.addEventListener("keydown", _MDWSegmentedButtonGroup.onKeyDownEvent);
    this.addEventListener(TABINDEX_ZEROED, _MDWSegmentedButtonGroup.onTabIndexZeroed);
  }
  disconnectedCallback() {
    this.removeEventListener("keydown", _MDWSegmentedButtonGroup.onKeyDownEvent);
    this.removeEventListener(TABINDEX_ZEROED, _MDWSegmentedButtonGroup.onTabIndexZeroed);
  }
};
var MDWSegmentedButtonGroup = _MDWSegmentedButtonGroup;
__name(MDWSegmentedButtonGroup, "MDWSegmentedButtonGroup");
__publicField(MDWSegmentedButtonGroup, "ariaRole", "listbox");
__publicField(MDWSegmentedButtonGroup, "elementName", "mdw-segmented-button-group");
__publicField(MDWSegmentedButtonGroup, "styles", [...__superGet(_MDWSegmentedButtonGroup, _MDWSegmentedButtonGroup, "styles"), MDWSegmentedButtonGroup_default]);

// core/icon/MDWIcon.js
init_polyfills();

// core/icon/MDWIcon.css
init_polyfills();
var contents19 = `/* core/icon/MDWIcon.css */
:host {
  --mdw-icon__size: 18px;
  --mdw-icon__opacity: 1;
  --mdw-icon__display: block;
  --mdw-icon__margin-inline-start: 12px;
  --mdw-icon__margin-inline-end: 8px;
  --mdw-icon__font-variation-settings: "FILL" 1;
  --mdw-icon__image__opacity: 1;
}
#icon {
  display: var(--mdw-icon__display);
  position: relative;
  order: -1;
  block-size: var(--mdw-icon__size);
  inline-size: var(--mdw-icon__size);
  transition-delay: 1ms;
  transition-duration: 100ms;
  transition-property:
    font-variation-settings,
    inline-size,
    opacity,
    width;
  opacity: var(--mdw-icon__opacity);
  font-size: var(--mdw-icon__size);
  font-variation-settings: var(--mdw-icon__font-variation-settings);
}
#image {
  position: absolute;
  inset: 0;
  block-size: 100%;
  inline-size: 100%;
  opacity: var(--mdw-icon__image__opacity);
  object-fit: cover;
}
#image:not([src]) {
  display: none;
}
.material-symbols-outlined {
  direction: inherit;
}`;
var styles19;
try {
  styles19 = new CSSStyleSheet();
  styles19.replaceSync(contents19);
} catch (e) {
  styles19 = contents19;
}
var MDWIcon_default = styles19;

// core/icon/MDWIcon.js
var _MDWIcon2 = class extends MDWContainer {
  constructor() {
    super();
    this.iconElement = this.shadowRoot.getElementById("icon");
    this.imageElement = this.shadowRoot.getElementById("image");
    this.iconElement.className = _MDWIcon2.fontClassName;
    this.iconElement.appendChild(this.slotElement);
  }
  attributeChangedCallback(name, oldValue, newValue) {
    if (oldValue == null && newValue == null)
      return;
    switch (name) {
      case "icon":
        if (newValue) {
          this.iconElement.textContent = newValue;
        }
        break;
      default:
    }
    if (_MDWIcon2.imageElementAttributes.includes(name)) {
      if (newValue == null) {
        this.imageElement.removeAttribute(name);
      } else {
        this.imageElement.setAttribute(name, newValue);
      }
    }
  }
  static get styles() {
    return [
      ...super.styles,
      new URL(this.fontLibrary),
      MDWIcon_default
    ];
  }
};
var MDWIcon2 = _MDWIcon2;
__name(MDWIcon2, "MDWIcon");
__publicField(MDWIcon2, "imageElementAttributes", [
  "alt",
  "crossorigin",
  "decoding",
  "fetchpriority",
  "loading",
  "referrerpolicy",
  "sizes",
  "src",
  "srcset"
]);
__publicField(MDWIcon2, "observedAttributes", [
  ...__superGet(_MDWIcon2, _MDWIcon2, "observedAttributes"),
  "icon",
  ..._MDWIcon2.imageElementAttributes
]);
__publicField(MDWIcon2, "elementName", "mdw-icon");
__publicField(MDWIcon2, "fontLibrary", "https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:FILL@0..1&text=search");
__publicField(MDWIcon2, "fontClassName", "material-symbols-outlined");
__publicField(MDWIcon2, "fragments", [
  ...__superGet(_MDWIcon2, _MDWIcon2, "fragments"),
  `
      <div id=icon aria-hidden="true">
        <img id=image aria-hidden="true"/>
      </div>
    `
]);

// core/theme/index.js
init_polyfills();

// utils/color_keywords.js
init_polyfills();
var COLOR_KEYWORDS = /* @__PURE__ */ new Map([
  ["black", "#000000"],
  ["silver", "#c0c0c0"],
  ["gray", "#808080"],
  ["white", "#ffffff"],
  ["maroon", "#800000"],
  ["red", "#ff0000"],
  ["purple", "#800080"],
  ["fuchsia", "#ff00ff"],
  ["green", "#008000"],
  ["lime", "#00ff00"],
  ["olive", "#808000"],
  ["yellow", "#ffff00"],
  ["navy", "#000080"],
  ["blue", "#0000ff"],
  ["teal", "#008080"],
  ["aqua", "#00ffff"],
  ["orange", "#ffa500"],
  ["aliceblue", "#f0f8ff"],
  ["antiquewhite", "#faebd7"],
  ["aquamarine", "#7fffd4"],
  ["azure", "#f0ffff"],
  ["beige", "#f5f5dc"],
  ["bisque", "#ffe4c4"],
  ["blanchedalmond", "#ffebcd"],
  ["blueviolet", "#8a2be2"],
  ["brown", "#a52a2a"],
  ["burlywood", "#deb887"],
  ["cadetblue", "#5f9ea0"],
  ["chartreuse", "#7fff00"],
  ["chocolate", "#d2691e"],
  ["coral", "#ff7f50"],
  ["cornflowerblue", "#6495ed"],
  ["cornsilk", "#fff8dc"],
  ["crimson", "#dc143c"],
  ["cyan", "00ffff"],
  ["darkblue", "#00008b"],
  ["darkcyan", "#008b8b"],
  ["darkgoldenrod", "#b8860b"],
  ["darkgray", "#a9a9a9"],
  ["darkgreen", "#006400"],
  ["darkgrey", "#a9a9a9"],
  ["darkkhaki", "#bdb76b"],
  ["darkmagenta", "#8b008b"],
  ["darkolivegreen", "#556b2f"],
  ["darkorange", "#ff8c00"],
  ["darkorchid", "#9932cc"],
  ["darkred", "#8b0000"],
  ["darksalmon", "#e9967a"],
  ["darkseagreen", "#8fbc8f"],
  ["darkslateblue", "#483d8b"],
  ["darkslategray", "#2f4f4f"],
  ["darkslategrey", "#2f4f4f"],
  ["darkturquoise", "#00ced1"],
  ["darkviolet", "#9400d3"],
  ["deeppink", "#ff1493"],
  ["deepskyblue", "#00bfff"],
  ["dimgray", "#696969"],
  ["dimgrey", "#696969"],
  ["dodgerblue", "#1e90ff"],
  ["firebrick", "#b22222"],
  ["floralwhite", "#fffaf0"],
  ["forestgreen", "#228b22"],
  ["gainsboro", "#dcdcdc"],
  ["ghostwhite", "#f8f8ff"],
  ["gold", "#ffd700"],
  ["goldenrod", "#daa520"],
  ["greenyellow", "#adff2f"],
  ["grey", "#808080"],
  ["honeydew", "#f0fff0"],
  ["hotpink", "#ff69b4"],
  ["indianred", "#cd5c5c"],
  ["indigo", "#4b0082"],
  ["ivory", "#fffff0"],
  ["khaki", "#f0e68c"],
  ["lavender", "#e6e6fa"],
  ["lavenderblush", "#fff0f5"],
  ["lawngreen", "#7cfc00"],
  ["lemonchiffon", "#fffacd"],
  ["lightblue", "#add8e6"],
  ["lightcoral", "#f08080"],
  ["lightcyan", "#e0ffff"],
  ["lightgoldenrodyellow", "#fafad2"],
  ["lightgray", "#d3d3d3"],
  ["lightgreen", "#90ee90"],
  ["lightgrey", "#d3d3d3"],
  ["lightpink", "#ffb6c1"],
  ["lightsalmon", "#ffa07a"],
  ["lightseagreen", "#20b2aa"],
  ["lightskyblue", "#87cefa"],
  ["lightslategray", "#778899"],
  ["lightslategrey", "#778899"],
  ["lightsteelblue", "#b0c4de"],
  ["lightyellow", "#ffffe0"],
  ["limegreen", "#32cd32"],
  ["linen", "#faf0e6"],
  ["magenta", "#ff00ff"],
  ["mediumaquamarine", "#66cdaa"],
  ["mediumblue", "#0000cd"],
  ["mediumorchid", "#ba55d3"],
  ["mediumpurple", "#9370db"],
  ["mediumseagreen", "#3cb371"],
  ["mediumslateblue", "#7b68ee"],
  ["mediumspringgreen", "#00fa9a"],
  ["mediumturquoise", "#48d1cc"],
  ["mediumvioletred", "#c71585"],
  ["midnightblue", "#191970"],
  ["mintcream", "#f5fffa"],
  ["mistyrose", "#ffe4e1"],
  ["moccasin", "#ffe4b5"],
  ["navajowhite", "#ffdead"],
  ["oldlace", "#fdf5e6"],
  ["olivedrab", "#6b8e23"],
  ["orangered", "#ff4500"],
  ["orchid", "#da70d6"],
  ["palegoldenrod", "#eee8aa"],
  ["palegreen", "#98fb98"],
  ["paleturquoise", "#afeeee"],
  ["palevioletred", "#db7093"],
  ["papayawhip", "#ffefd5"],
  ["peachpuff", "#ffdab9"],
  ["peru", "#cd853f"],
  ["pink", "#ffc0cb"],
  ["plum", "#dda0dd"],
  ["powderblue", "#b0e0e6"],
  ["rosybrown", "#bc8f8f"],
  ["royalblue", "#4169e1"],
  ["saddlebrown", "#8b4513"],
  ["salmon", "#fa8072"],
  ["sandybrown", "#f4a460"],
  ["seagreen", "#2e8b57"],
  ["seashell", "#fff5ee"],
  ["sienna", "#a0522d"],
  ["skyblue", "#87ceeb"],
  ["slateblue", "#6a5acd"],
  ["slategray", "#708090"],
  ["slategrey", "#708090"],
  ["snow", "#fffafa"],
  ["springgreen", "#00ff7f"],
  ["steelblue", "#4682b4"],
  ["tan", "#d2b48c"],
  ["thistle", "#d8bfd8"],
  ["tomato", "#ff6347"],
  ["turquoise", "#40e0d0"],
  ["violet", "#ee82ee"],
  ["wheat", "#f5deb3"],
  ["whitesmoke", "#f5f5f5"],
  ["yellowgreen", "#9acd32"],
  ["rebeccapurple", "#663399"]
]);

// utils/hct/helper.js
init_polyfills();

// utils/hct/CorePalette.js
init_polyfills();

// utils/hct/Hct.js
init_polyfills();

// utils/hct/Cam16.js
init_polyfills();

// utils/hct/ViewingConditions.js
init_polyfills();

// utils/hct/colorUtils.js
init_polyfills();

// utils/hct/mathUtils.js
init_polyfills();
function signum(num) {
  if (num < 0) {
    return -1;
  }
  if (num === 0) {
    return 0;
  }
  return 1;
}
__name(signum, "signum");
function lerp(start, stop, amount) {
  return (1 - amount) * start + amount * stop;
}
__name(lerp, "lerp");
function clampInt(min, max, input) {
  if (input < min) {
    return min;
  }
  if (input > max) {
    return max;
  }
  return input;
}
__name(clampInt, "clampInt");
function sanitizeDegreesDouble(degrees) {
  degrees %= 360;
  if (degrees < 0) {
    degrees += 360;
  }
  return degrees;
}
__name(sanitizeDegreesDouble, "sanitizeDegreesDouble");
function rotationDirection(from, to) {
  const increasingDifference = sanitizeDegreesDouble(to - from);
  return increasingDifference <= 180 ? 1 : -1;
}
__name(rotationDirection, "rotationDirection");
function differenceDegrees(a, b) {
  return 180 - Math.abs(Math.abs(a - b) - 180);
}
__name(differenceDegrees, "differenceDegrees");
function matrixMultiply(row, matrix) {
  const a = row[0] * matrix[0][0] + row[1] * matrix[0][1] + row[2] * matrix[0][2];
  const b = row[0] * matrix[1][0] + row[1] * matrix[1][1] + row[2] * matrix[1][2];
  const c = row[0] * matrix[2][0] + row[1] * matrix[2][1] + row[2] * matrix[2][2];
  return [a, b, c];
}
__name(matrixMultiply, "matrixMultiply");

// utils/hct/colorUtils.js
var SRGB_TO_XYZ = [
  [0.41233895, 0.35762064, 0.18051042],
  [0.2126, 0.7152, 0.0722],
  [0.01932141, 0.11916382, 0.95034478]
];
var XYZ_TO_SRGB = [
  [
    3.2413774792388685,
    -1.5376652402851851,
    -0.49885366846268053
  ],
  [
    -0.9691452513005321,
    1.8758853451067872,
    0.04156585616912061
  ],
  [
    0.05562093689691305,
    -0.20395524564742123,
    1.0571799111220335
  ]
];
var WHITE_POINT_D65 = [95.047, 100, 108.883];
function argbFromRgb(red, green, blue) {
  return (255 << 24 | (red & 255) << 16 | (green & 255) << 8 | blue & 255) >>> 0;
}
__name(argbFromRgb, "argbFromRgb");
function argbFromLinrgb(linrgb) {
  const r = delinearized(linrgb[0]);
  const g = delinearized(linrgb[1]);
  const b = delinearized(linrgb[2]);
  return argbFromRgb(r, g, b);
}
__name(argbFromLinrgb, "argbFromLinrgb");
function redFromArgb(argb) {
  return argb >> 16 & 255;
}
__name(redFromArgb, "redFromArgb");
function greenFromArgb(argb) {
  return argb >> 8 & 255;
}
__name(greenFromArgb, "greenFromArgb");
function blueFromArgb(argb) {
  return argb & 255;
}
__name(blueFromArgb, "blueFromArgb");
function argbFromXyz(x, y, z) {
  const matrix = XYZ_TO_SRGB;
  const linearR = matrix[0][0] * x + matrix[0][1] * y + matrix[0][2] * z;
  const linearG = matrix[1][0] * x + matrix[1][1] * y + matrix[1][2] * z;
  const linearB = matrix[2][0] * x + matrix[2][1] * y + matrix[2][2] * z;
  const r = delinearized(linearR);
  const g = delinearized(linearG);
  const b = delinearized(linearB);
  return argbFromRgb(r, g, b);
}
__name(argbFromXyz, "argbFromXyz");
function xyzFromArgb(argb) {
  const r = linearized(redFromArgb(argb));
  const g = linearized(greenFromArgb(argb));
  const b = linearized(blueFromArgb(argb));
  return matrixMultiply([r, g, b], SRGB_TO_XYZ);
}
__name(xyzFromArgb, "xyzFromArgb");
function argbFromLstar(lstar) {
  const y = yFromLstar(lstar);
  const component = delinearized(y);
  return argbFromRgb(component, component, component);
}
__name(argbFromLstar, "argbFromLstar");
function lstarFromArgb(argb) {
  const y = xyzFromArgb(argb)[1];
  return 116 * labF(y / 100) - 16;
}
__name(lstarFromArgb, "lstarFromArgb");
function yFromLstar(lstar) {
  return 100 * labInvf((lstar + 16) / 116);
}
__name(yFromLstar, "yFromLstar");
function linearized(rgbComponent) {
  const normalized = rgbComponent / 255;
  if (normalized <= 0.040449936) {
    return normalized / 12.92 * 100;
  }
  return ((normalized + 0.055) / 1.055) ** 2.4 * 100;
}
__name(linearized, "linearized");
function delinearized(rgbComponent) {
  const normalized = rgbComponent / 100;
  let delinearized2 = 0;
  delinearized2 = normalized <= 31308e-7 ? normalized * 12.92 : 1.055 * normalized ** (1 / 2.4) - 0.055;
  return clampInt(0, 255, Math.round(delinearized2 * 255));
}
__name(delinearized, "delinearized");
function whitePointD65() {
  return WHITE_POINT_D65;
}
__name(whitePointD65, "whitePointD65");
function labF(t) {
  const e = 216 / 24389;
  const kappa = 24389 / 27;
  if (t > e) {
    return t ** (1 / 3);
  }
  return (kappa * t + 16) / 116;
}
__name(labF, "labF");
function labInvf(ft) {
  const e = 216 / 24389;
  const kappa = 24389 / 27;
  const ft3 = ft * ft * ft;
  if (ft3 > e) {
    return ft3;
  }
  return (116 * ft - 16) / kappa;
}
__name(labInvf, "labInvf");

// utils/hct/ViewingConditions.js
var _ViewingConditions = class {
  static make(whitePoint = whitePointD65(), adaptingLuminance = 200 / Math.PI * yFromLstar(50) / 100, backgroundLstar = 50, surround = 2, discountingIlluminant = false) {
    const xyz = whitePoint;
    const rW = xyz[0] * 0.401288 + xyz[1] * 0.650173 + xyz[2] * -0.051461;
    const gW = xyz[0] * -0.250268 + xyz[1] * 1.204414 + xyz[2] * 0.045854;
    const bW = xyz[0] * -2079e-6 + xyz[1] * 0.048952 + xyz[2] * 0.953127;
    const f = 0.8 + surround / 10;
    const c = f >= 0.9 ? lerp(0.59, 0.69, (f - 0.9) * 10) : lerp(0.525, 0.59, (f - 0.8) * 10);
    let d = discountingIlluminant ? 1 : f * (1 - 1 / 3.6 * Math.exp((-adaptingLuminance - 42) / 92));
    d = d > 1 ? 1 : d < 0 ? 0 : d;
    const nc = f;
    const rgbD = [
      d * (100 / rW) + 1 - d,
      d * (100 / gW) + 1 - d,
      d * (100 / bW) + 1 - d
    ];
    const k = 1 / (5 * adaptingLuminance + 1);
    const k4 = k * k * k * k;
    const k4F = 1 - k4;
    const fl = k4 * adaptingLuminance + 0.1 * k4F * k4F * Math.cbrt(5 * adaptingLuminance);
    const n = yFromLstar(backgroundLstar) / whitePoint[1];
    const z = 1.48 + Math.sqrt(n);
    const nbb = 0.725 / n ** 0.2;
    const ncb = nbb;
    const rgbAFactors = [
      (fl * rgbD[0] * rW / 100) ** 0.42,
      (fl * rgbD[1] * gW / 100) ** 0.42,
      (fl * rgbD[2] * bW / 100) ** 0.42
    ];
    const rgbA = [
      400 * rgbAFactors[0] / (rgbAFactors[0] + 27.13),
      400 * rgbAFactors[1] / (rgbAFactors[1] + 27.13),
      400 * rgbAFactors[2] / (rgbAFactors[2] + 27.13)
    ];
    const aw = (2 * rgbA[0] + rgbA[1] + 0.05 * rgbA[2]) * nbb;
    return new _ViewingConditions(n, aw, nbb, ncb, c, nc, rgbD, fl, fl ** 0.25, z);
  }
  constructor(n, aw, nbb, ncb, c, nc, rgbD, fl, fLRoot, z) {
    this.n = n;
    this.aw = aw;
    this.nbb = nbb;
    this.ncb = ncb;
    this.c = c;
    this.nc = nc;
    this.rgbD = rgbD;
    this.fl = fl;
    this.fLRoot = fLRoot;
    this.z = z;
  }
};
var ViewingConditions = _ViewingConditions;
__name(ViewingConditions, "ViewingConditions");
__publicField(ViewingConditions, "DEFAULT", _ViewingConditions.make());

// utils/hct/Cam16.js
var Cam16 = class {
  constructor(hue, chroma, j, q, m, s, jstar, astar, bstar) {
    this.hue = hue;
    this.chroma = chroma;
    this.j = j;
    this.q = q;
    this.m = m;
    this.s = s;
    this.jstar = jstar;
    this.astar = astar;
    this.bstar = bstar;
  }
  distance(other) {
    const dJ = this.jstar - other.jstar;
    const dA = this.astar - other.astar;
    const dB = this.bstar - other.bstar;
    const dEPrime = Math.sqrt(dJ * dJ + dA * dA + dB * dB);
    const dE = 1.41 * dEPrime ** 0.63;
    return dE;
  }
  static fromInt(argb) {
    return Cam16.fromIntInViewingConditions(argb, ViewingConditions.DEFAULT);
  }
  static fromIntInViewingConditions(argb, viewingConditions) {
    const red = (argb & 16711680) >> 16;
    const green = (argb & 65280) >> 8;
    const blue = argb & 255;
    const redL = linearized(red);
    const greenL = linearized(green);
    const blueL = linearized(blue);
    const x = 0.41233895 * redL + 0.35762064 * greenL + 0.18051042 * blueL;
    const y = 0.2126 * redL + 0.7152 * greenL + 0.0722 * blueL;
    const z = 0.01932141 * redL + 0.11916382 * greenL + 0.95034478 * blueL;
    const rC = 0.401288 * x + 0.650173 * y - 0.051461 * z;
    const gC = -0.250268 * x + 1.204414 * y + 0.045854 * z;
    const bC = -2079e-6 * x + 0.048952 * y + 0.953127 * z;
    const rD = viewingConditions.rgbD[0] * rC;
    const gD = viewingConditions.rgbD[1] * gC;
    const bD = viewingConditions.rgbD[2] * bC;
    const rAF = (viewingConditions.fl * Math.abs(rD) / 100) ** 0.42;
    const gAF = (viewingConditions.fl * Math.abs(gD) / 100) ** 0.42;
    const bAF = (viewingConditions.fl * Math.abs(bD) / 100) ** 0.42;
    const rA = signum(rD) * 400 * rAF / (rAF + 27.13);
    const gA = signum(gD) * 400 * gAF / (gAF + 27.13);
    const bA = signum(bD) * 400 * bAF / (bAF + 27.13);
    const a = (11 * rA + -12 * gA + bA) / 11;
    const b = (rA + gA - 2 * bA) / 9;
    const u = (20 * rA + 20 * gA + 21 * bA) / 20;
    const p2 = (40 * rA + 20 * gA + bA) / 20;
    const atan2 = Math.atan2(b, a);
    const atanDegrees = atan2 * 180 / Math.PI;
    const hue = atanDegrees < 0 ? atanDegrees + 360 : atanDegrees >= 360 ? atanDegrees - 360 : atanDegrees;
    const hueRadians = hue * Math.PI / 180;
    const ac = p2 * viewingConditions.nbb;
    const j = 100 * (ac / viewingConditions.aw) ** (viewingConditions.c * viewingConditions.z);
    const q = 4 / viewingConditions.c * Math.sqrt(j / 100) * (viewingConditions.aw + 4) * viewingConditions.fLRoot;
    const huePrime = hue < 20.14 ? hue + 360 : hue;
    const eHue = 0.25 * (Math.cos(huePrime * Math.PI / 180 + 2) + 3.8);
    const p1 = 5e4 / 13 * eHue * viewingConditions.nc * viewingConditions.ncb;
    const t = p1 * Math.sqrt(a * a + b * b) / (u + 0.305);
    const alpha = t ** 0.9 * (1.64 - 0.29 ** viewingConditions.n) ** 0.73;
    const c = alpha * Math.sqrt(j / 100);
    const m = c * viewingConditions.fLRoot;
    const s = 50 * Math.sqrt(alpha * viewingConditions.c / (viewingConditions.aw + 4));
    const jstar = (1 + 100 * 7e-3) * j / (1 + 7e-3 * j);
    const mstar = 1 / 0.0228 * Math.log(1 + 0.0228 * m);
    const astar = mstar * Math.cos(hueRadians);
    const bstar = mstar * Math.sin(hueRadians);
    return new Cam16(hue, c, j, q, m, s, jstar, astar, bstar);
  }
  static fromJch(j, c, h) {
    return Cam16.fromJchInViewingConditions(j, c, h, ViewingConditions.DEFAULT);
  }
  static fromJchInViewingConditions(j, c, h, viewingConditions) {
    const q = 4 / viewingConditions.c * Math.sqrt(j / 100) * (viewingConditions.aw + 4) * viewingConditions.fLRoot;
    const m = c * viewingConditions.fLRoot;
    const alpha = c / Math.sqrt(j / 100);
    const s = 50 * Math.sqrt(alpha * viewingConditions.c / (viewingConditions.aw + 4));
    const hueRadians = h * Math.PI / 180;
    const jstar = (1 + 100 * 7e-3) * j / (1 + 7e-3 * j);
    const mstar = 1 / 0.0228 * Math.log(1 + 0.0228 * m);
    const astar = mstar * Math.cos(hueRadians);
    const bstar = mstar * Math.sin(hueRadians);
    return new Cam16(h, c, j, q, m, s, jstar, astar, bstar);
  }
  static fromUcs(jstar, astar, bstar) {
    return Cam16.fromUcsInViewingConditions(jstar, astar, bstar, ViewingConditions.DEFAULT);
  }
  static fromUcsInViewingConditions(jstar, astar, bstar, viewingConditions) {
    const a = astar;
    const b = bstar;
    const m = Math.sqrt(a * a + b * b);
    const M = (Math.exp(m * 0.0228) - 1) / 0.0228;
    const c = M / viewingConditions.fLRoot;
    let h = Math.atan2(b, a) * (180 / Math.PI);
    if (h < 0) {
      h += 360;
    }
    const j = jstar / (1 - (jstar - 100) * 7e-3);
    return Cam16.fromJchInViewingConditions(j, c, h, viewingConditions);
  }
  toInt() {
    return this.viewed(ViewingConditions.DEFAULT);
  }
  viewed(viewingConditions) {
    const alpha = this.chroma === 0 || this.j === 0 ? 0 : this.chroma / Math.sqrt(this.j / 100);
    const t = (alpha / (1.64 - 0.29 ** viewingConditions.n) ** 0.73) ** (1 / 0.9);
    const hRad = this.hue * Math.PI / 180;
    const eHue = 0.25 * (Math.cos(hRad + 2) + 3.8);
    const ac = viewingConditions.aw * (this.j / 100) ** (1 / viewingConditions.c / viewingConditions.z);
    const p1 = eHue * (5e4 / 13) * viewingConditions.nc * viewingConditions.ncb;
    const p2 = ac / viewingConditions.nbb;
    const hSin = Math.sin(hRad);
    const hCos = Math.cos(hRad);
    const gamma = 23 * (p2 + 0.305) * t / (23 * p1 + 11 * t * hCos + 108 * t * hSin);
    const a = gamma * hCos;
    const b = gamma * hSin;
    const rA = (460 * p2 + 451 * a + 288 * b) / 1403;
    const gA = (460 * p2 - 891 * a - 261 * b) / 1403;
    const bA = (460 * p2 - 220 * a - 6300 * b) / 1403;
    const rCBase = Math.max(0, 27.13 * Math.abs(rA) / (400 - Math.abs(rA)));
    const rC = signum(rA) * (100 / viewingConditions.fl) * rCBase ** (1 / 0.42);
    const gCBase = Math.max(0, 27.13 * Math.abs(gA) / (400 - Math.abs(gA)));
    const gC = signum(gA) * (100 / viewingConditions.fl) * gCBase ** (1 / 0.42);
    const bCBase = Math.max(0, 27.13 * Math.abs(bA) / (400 - Math.abs(bA)));
    const bC = signum(bA) * (100 / viewingConditions.fl) * bCBase ** (1 / 0.42);
    const rF = rC / viewingConditions.rgbD[0];
    const gF = gC / viewingConditions.rgbD[1];
    const bF = bC / viewingConditions.rgbD[2];
    const x = 1.86206786 * rF - 1.01125463 * gF + 0.14918677 * bF;
    const y = 0.38752654 * rF + 0.62144744 * gF - 897398e-8 * bF;
    const z = -0.0158415 * rF - 0.03412294 * gF + 1.04996444 * bF;
    const argb = argbFromXyz(x, y, z);
    return argb;
  }
};
__name(Cam16, "Cam16");

// utils/hct/hctSolver.js
init_polyfills();
var SCALED_DISCOUNT_FROM_LINRGB = [
  [
    0.001200833568784504,
    0.002389694492170889,
    2795742885861124e-19
  ],
  [
    5891086651375999e-19,
    0.0029785502573438758,
    3270666104008398e-19
  ],
  [
    10146692491640572e-20,
    5364214359186694e-19,
    0.0032979401770712076
  ]
];
var LINRGB_FROM_SCALED_DISCOUNT = [
  [
    1373.2198709594231,
    -1100.4251190754821,
    -7.278681089101213
  ],
  [
    -271.815969077903,
    559.6580465940733,
    -32.46047482791194
  ],
  [
    1.9622899599665666,
    -57.173814538844006,
    308.7233197812385
  ]
];
var Y_FROM_LINRGB = [0.2126, 0.7152, 0.0722];
var CRITICAL_PLANES = [
  0.015176349177441876,
  0.045529047532325624,
  0.07588174588720938,
  0.10623444424209313,
  0.13658714259697685,
  0.16693984095186062,
  0.19729253930674434,
  0.2276452376616281,
  0.2579979360165119,
  0.28835063437139563,
  0.3188300904430532,
  0.350925934958123,
  0.3848314933096426,
  0.42057480301049466,
  0.458183274052838,
  0.4976837250274023,
  0.5391024159806381,
  0.5824650784040898,
  0.6277969426914107,
  0.6751227633498623,
  0.7244668422128921,
  0.775853049866786,
  0.829304845476233,
  0.8848452951698498,
  0.942497089126609,
  1.0022825574869039,
  1.0642236851973577,
  1.1283421258858297,
  1.1946592148522128,
  1.2631959812511864,
  1.3339731595349034,
  1.407011200216447,
  1.4823302800086415,
  1.5599503113873272,
  1.6398909516233677,
  1.7221716113234105,
  1.8068114625156377,
  1.8938294463134073,
  1.9832442801866852,
  2.075074464868551,
  2.1693382909216234,
  2.2660538449872063,
  2.36523901573795,
  2.4669114995532007,
  2.5710888059345764,
  2.6777882626779785,
  2.7870270208169257,
  2.898822059350997,
  3.0131901897720907,
  3.1301480604002863,
  3.2497121605402226,
  3.3718988244681087,
  3.4967242352587946,
  3.624204428461639,
  3.754355295633311,
  3.887192587735158,
  4.022731918402185,
  4.160988767090289,
  4.301978482107941,
  4.445716283538092,
  4.592217266055746,
  4.741496401646282,
  4.893568542229298,
  5.048448422192488,
  5.20615066083972,
  5.3666897647573375,
  5.5300801301023865,
  5.696336044816294,
  5.865471690767354,
  6.037501145825082,
  6.212438385869475,
  6.390297286737924,
  6.571091626112461,
  6.7548350853498045,
  6.941541251256611,
  7.131223617812143,
  7.323895587840543,
  7.5195704746346665,
  7.7182615035334345,
  7.919981813454504,
  8.124744458384042,
  8.332562408825165,
  8.543448553206703,
  8.757415699253682,
  8.974476575321063,
  9.194643831691977,
  9.417930041841839,
  9.644347703669503,
  9.873909240696694,
  10.106627003236781,
  10.342513269534024,
  10.58158024687427,
  10.8238400726681,
  11.069304815507364,
  11.317986476196008,
  11.569896988756009,
  11.825048221409341,
  12.083451977536606,
  12.345119996613247,
  12.610063955123938,
  12.878295467455942,
  13.149826086772048,
  13.42466730586372,
  13.702830557985108,
  13.984327217668513,
  14.269168601521828,
  14.55736596900856,
  14.848930523210871,
  15.143873411576273,
  15.44220572664832,
  15.743938506781891,
  16.04908273684337,
  16.35764934889634,
  16.66964922287304,
  16.985093187232053,
  17.30399201960269,
  17.62635644741625,
  17.95219714852476,
  18.281524751807332,
  18.614349837764564,
  18.95068293910138,
  19.290534541298456,
  19.633915083172692,
  19.98083495742689,
  20.331304511189067,
  20.685334046541502,
  21.042933821039977,
  21.404114048223256,
  21.76888489811322,
  22.137256497705877,
  22.50923893145328,
  22.884842241736916,
  23.264076429332462,
  23.6469514538663,
  24.033477234264016,
  24.42366364919083,
  24.817520537484558,
  25.21505769858089,
  25.61628489293138,
  26.021211842414342,
  26.429848230738664,
  26.842203703840827,
  27.258287870275353,
  27.678110301598522,
  28.10168053274597,
  28.529008062403893,
  28.96010235337422,
  29.39497283293396,
  29.83362889318845,
  30.276079891419332,
  30.722335150426627,
  31.172403958865512,
  31.62629557157785,
  32.08401920991837,
  32.54558406207592,
  33.010999283389665,
  33.4802739966603,
  33.953417292456834,
  34.430438229418264,
  34.911345834551085,
  35.39614910352207,
  35.88485700094671,
  36.37747846067349,
  36.87402238606382,
  37.37449765026789,
  37.87891309649659,
  38.38727753828926,
  38.89959975977785,
  39.41588851594697,
  39.93615253289054,
  40.460400508064545,
  40.98864111053629,
  41.520882981230194,
  42.05713473317016,
  42.597404951718396,
  43.141702194811224,
  43.6900349931913,
  44.24241185063697,
  44.798841244188324,
  45.35933162437017,
  45.92389141541209,
  46.49252901546552,
  47.065252796817916,
  47.64207110610409,
  48.22299226451468,
  48.808024568002054,
  49.3971762874833,
  49.9904556690408,
  50.587870934119984,
  51.189430279724725,
  51.79514187861014,
  52.40501387947288,
  53.0190544071392,
  53.637271562750364,
  54.259673423945976,
  54.88626804504493,
  55.517063457223934,
  56.15206766869424,
  56.79128866487574,
  57.43473440856916,
  58.08241284012621,
  58.734331877617365,
  59.39049941699807,
  60.05092333227251,
  60.715611475655585,
  61.38457167773311,
  62.057811747619894,
  62.7353394731159,
  63.417162620860914,
  64.10328893648692,
  64.79372614476921,
  65.48848194977529,
  66.18756403501224,
  66.89098006357258,
  67.59873767827808,
  68.31084450182222,
  69.02730813691093,
  69.74813616640164,
  70.47333615344107,
  71.20291564160104,
  71.93688215501312,
  72.67524319850172,
  73.41800625771542,
  74.16517879925733,
  74.9167682708136,
  75.67278210128072,
  76.43322770089146,
  77.1981124613393,
  77.96744375590167,
  78.74122893956174,
  79.51947534912904,
  80.30219030335869,
  81.08938110306934,
  81.88105503125999,
  82.67721935322541,
  83.4778813166706,
  84.28304815182372,
  85.09272707154808,
  85.90692527145302,
  86.72564993000343,
  87.54890820862819,
  88.3767072518277,
  89.2090541872801,
  90.04595612594655,
  90.88742016217518,
  91.73345337380438,
  92.58406282226491,
  93.43925555268066,
  94.29903859396902,
  95.16341895893969,
  96.03240364439274,
  96.9059996312159,
  97.78421388448044,
  98.6670533535366,
  99.55452497210776
];
function sanitizeRadians(angle) {
  return (angle + Math.PI * 8) % (Math.PI * 2);
}
__name(sanitizeRadians, "sanitizeRadians");
function trueDelinearized(rgbComponent) {
  const normalized = rgbComponent / 100;
  let delinearized2 = 0;
  delinearized2 = normalized <= 31308e-7 ? normalized * 12.92 : 1.055 * normalized ** (1 / 2.4) - 0.055;
  return delinearized2 * 255;
}
__name(trueDelinearized, "trueDelinearized");
function chromaticAdaptation(component) {
  const af = Math.abs(component) ** 0.42;
  return signum(component) * 400 * af / (af + 27.13);
}
__name(chromaticAdaptation, "chromaticAdaptation");
function hueOf(linrgb) {
  const scaledDiscount = matrixMultiply(linrgb, SCALED_DISCOUNT_FROM_LINRGB);
  const rA = chromaticAdaptation(scaledDiscount[0]);
  const gA = chromaticAdaptation(scaledDiscount[1]);
  const bA = chromaticAdaptation(scaledDiscount[2]);
  const a = (11 * rA + -12 * gA + bA) / 11;
  const b = (rA + gA - 2 * bA) / 9;
  return Math.atan2(b, a);
}
__name(hueOf, "hueOf");
function areInCyclicOrder(a, b, c) {
  const deltaAB = sanitizeRadians(b - a);
  const deltaAC = sanitizeRadians(c - a);
  return deltaAB < deltaAC;
}
__name(areInCyclicOrder, "areInCyclicOrder");
function intercept(source, mid, target) {
  return (mid - source) / (target - source);
}
__name(intercept, "intercept");
function lerpPoint(source, t, target) {
  return [
    source[0] + (target[0] - source[0]) * t,
    source[1] + (target[1] - source[1]) * t,
    source[2] + (target[2] - source[2]) * t
  ];
}
__name(lerpPoint, "lerpPoint");
function setCoordinate(source, coordinate, target, axis) {
  const t = intercept(source[axis], coordinate, target[axis]);
  return lerpPoint(source, t, target);
}
__name(setCoordinate, "setCoordinate");
function isBounded(x) {
  return x >= 0 && x <= 100;
}
__name(isBounded, "isBounded");
function nthVertex(y, n) {
  const kR = Y_FROM_LINRGB[0];
  const kG = Y_FROM_LINRGB[1];
  const kB = Y_FROM_LINRGB[2];
  const coordA = n % 4 <= 1 ? 0 : 100;
  const coordB = n % 2 === 0 ? 0 : 100;
  if (n < 4) {
    const g2 = coordA;
    const b2 = coordB;
    const r2 = (y - g2 * kG - b2 * kB) / kR;
    if (isBounded(r2)) {
      return [r2, g2, b2];
    }
    return [-1, -1, -1];
  }
  if (n < 8) {
    const b2 = coordA;
    const r2 = coordB;
    const g2 = (y - r2 * kR - b2 * kB) / kG;
    if (isBounded(g2)) {
      return [r2, g2, b2];
    }
    return [-1, -1, -1];
  }
  const r = coordA;
  const g = coordB;
  const b = (y - r * kR - g * kG) / kB;
  if (isBounded(b)) {
    return [r, g, b];
  }
  return [-1, -1, -1];
}
__name(nthVertex, "nthVertex");
function bisectToSegment(y, targetHue) {
  let left = [-1, -1, -1];
  let right = left;
  let leftHue = 0;
  let rightHue = 0;
  let initialized = false;
  let uncut = true;
  for (let n = 0; n < 12; n++) {
    const mid = nthVertex(y, n);
    if (mid[0] < 0) {
      continue;
    }
    const midHue = hueOf(mid);
    if (!initialized) {
      left = mid;
      right = mid;
      leftHue = midHue;
      rightHue = midHue;
      initialized = true;
      continue;
    }
    if (uncut || areInCyclicOrder(leftHue, midHue, rightHue)) {
      uncut = false;
      if (areInCyclicOrder(leftHue, targetHue, midHue)) {
        right = mid;
        rightHue = midHue;
      } else {
        left = mid;
        leftHue = midHue;
      }
    }
  }
  return [left, right];
}
__name(bisectToSegment, "bisectToSegment");
function midpoint(a, b) {
  return [
    (a[0] + b[0]) / 2,
    (a[1] + b[1]) / 2,
    (a[2] + b[2]) / 2
  ];
}
__name(midpoint, "midpoint");
function criticalPlaneBelow(x) {
  return Math.floor(x - 0.5);
}
__name(criticalPlaneBelow, "criticalPlaneBelow");
function criticalPlaneAbove(x) {
  return Math.ceil(x - 0.5);
}
__name(criticalPlaneAbove, "criticalPlaneAbove");
function bisectToLimit(y, targetHue) {
  const segment = bisectToSegment(y, targetHue);
  let left = segment[0];
  let leftHue = hueOf(left);
  let right = segment[1];
  for (let axis = 0; axis < 3; axis++) {
    if (left[axis] !== right[axis]) {
      let lPlane = -1;
      let rPlane = 255;
      if (left[axis] < right[axis]) {
        lPlane = criticalPlaneBelow(
          trueDelinearized(left[axis])
        );
        rPlane = criticalPlaneAbove(
          trueDelinearized(right[axis])
        );
      } else {
        lPlane = criticalPlaneAbove(
          trueDelinearized(left[axis])
        );
        rPlane = criticalPlaneBelow(
          trueDelinearized(right[axis])
        );
      }
      for (let i = 0; i < 8; i++) {
        if (Math.abs(rPlane - lPlane) <= 1) {
          break;
        } else {
          const mPlane = Math.floor((lPlane + rPlane) / 2);
          const midPlaneCoordinate = CRITICAL_PLANES[mPlane];
          const mid = setCoordinate(left, midPlaneCoordinate, right, axis);
          const midHue = hueOf(mid);
          if (areInCyclicOrder(leftHue, targetHue, midHue)) {
            right = mid;
            rPlane = mPlane;
          } else {
            left = mid;
            leftHue = midHue;
            lPlane = mPlane;
          }
        }
      }
    }
  }
  return midpoint(left, right);
}
__name(bisectToLimit, "bisectToLimit");
function inverseChromaticAdaptation(adapted) {
  const adaptedAbs = Math.abs(adapted);
  const base = Math.max(0, 27.13 * adaptedAbs / (400 - adaptedAbs));
  return signum(adapted) * base ** (1 / 0.42);
}
__name(inverseChromaticAdaptation, "inverseChromaticAdaptation");
function findResultByJ(hueRadians, chroma, y) {
  let j = Math.sqrt(y) * 11;
  const viewingConditions = ViewingConditions.DEFAULT;
  const tInnerCoeff = 1 / (1.64 - 0.29 ** viewingConditions.n) ** 0.73;
  const eHue = 0.25 * (Math.cos(hueRadians + 2) + 3.8);
  const p1 = eHue * (5e4 / 13) * viewingConditions.nc * viewingConditions.ncb;
  const hSin = Math.sin(hueRadians);
  const hCos = Math.cos(hueRadians);
  for (let iterationRound = 0; iterationRound < 5; iterationRound++) {
    const jNormalized = j / 100;
    const alpha = chroma === 0 || j === 0 ? 0 : chroma / Math.sqrt(jNormalized);
    const t = (alpha * tInnerCoeff) ** (1 / 0.9);
    const ac = viewingConditions.aw * jNormalized ** (1 / viewingConditions.c / viewingConditions.z);
    const p2 = ac / viewingConditions.nbb;
    const gamma = 23 * (p2 + 0.305) * t / (23 * p1 + 11 * t * hCos + 108 * t * hSin);
    const a = gamma * hCos;
    const b = gamma * hSin;
    const rA = (460 * p2 + 451 * a + 288 * b) / 1403;
    const gA = (460 * p2 - 891 * a - 261 * b) / 1403;
    const bA = (460 * p2 - 220 * a - 6300 * b) / 1403;
    const rCScaled = inverseChromaticAdaptation(rA);
    const gCScaled = inverseChromaticAdaptation(gA);
    const bCScaled = inverseChromaticAdaptation(bA);
    const linrgb = matrixMultiply(
      [rCScaled, gCScaled, bCScaled],
      LINRGB_FROM_SCALED_DISCOUNT
    );
    if (linrgb[0] < 0 || linrgb[1] < 0 || linrgb[2] < 0) {
      return 0;
    }
    const kR = Y_FROM_LINRGB[0];
    const kG = Y_FROM_LINRGB[1];
    const kB = Y_FROM_LINRGB[2];
    const fnj = kR * linrgb[0] + kG * linrgb[1] + kB * linrgb[2];
    if (fnj <= 0) {
      return 0;
    }
    if (iterationRound === 4 || Math.abs(fnj - y) < 2e-3) {
      if (linrgb[0] > 100.01 || linrgb[1] > 100.01 || linrgb[2] > 100.01) {
        return 0;
      }
      return argbFromLinrgb(linrgb);
    }
    j -= (fnj - y) * j / (2 * fnj);
  }
  return 0;
}
__name(findResultByJ, "findResultByJ");
function solveToInt(hueDegrees, chroma, lstar) {
  if (chroma < 1e-4 || lstar < 1e-4 || lstar > 99.9999) {
    return argbFromLstar(lstar);
  }
  hueDegrees = sanitizeDegreesDouble(hueDegrees);
  const hueRadians = hueDegrees / 180 * Math.PI;
  const y = yFromLstar(lstar);
  const exactAnswer = findResultByJ(hueRadians, chroma, y);
  if (exactAnswer !== 0) {
    return exactAnswer;
  }
  const linrgb = bisectToLimit(y, hueRadians);
  return argbFromLinrgb(linrgb);
}
__name(solveToInt, "solveToInt");

// utils/hct/Hct.js
var Hct = class {
  internalHue;
  internalChroma;
  internalTone;
  static from(hue, chroma, tone) {
    return new Hct(solveToInt(hue, chroma, tone));
  }
  static fromInt(argb) {
    return new Hct(argb);
  }
  toInt() {
    return this.argb;
  }
  get hue() {
    return this.internalHue;
  }
  set hue(newHue) {
    this.setInternalState(
      solveToInt(
        newHue,
        this.internalChroma,
        this.internalTone
      )
    );
  }
  get chroma() {
    return this.internalChroma;
  }
  set chroma(newChroma) {
    this.setInternalState(
      solveToInt(
        this.internalHue,
        newChroma,
        this.internalTone
      )
    );
  }
  get tone() {
    return this.internalTone;
  }
  set tone(newTone) {
    this.setInternalState(
      solveToInt(
        this.internalHue,
        this.internalChroma,
        newTone
      )
    );
  }
  constructor(argb) {
    const cam = Cam16.fromInt(argb);
    this.internalHue = cam.hue;
    this.internalChroma = cam.chroma;
    this.internalTone = lstarFromArgb(argb);
    this.argb = argb;
  }
  setInternalState(argb) {
    const cam = Cam16.fromInt(argb);
    this.internalHue = cam.hue;
    this.internalChroma = cam.chroma;
    this.internalTone = lstarFromArgb(argb);
    this.argb = argb;
  }
};
__name(Hct, "Hct");

// utils/hct/TonalPalette.js
init_polyfills();
var _cache;
var _TonalPalette = class {
  constructor(hue, chroma) {
    __privateAdd(this, _cache, /* @__PURE__ */ new Map());
    this.hue = hue;
    this.chroma = chroma;
  }
  static fromInt(argb) {
    const hct = Hct.fromInt(argb);
    return _TonalPalette.fromHueAndChroma(hct.hue, hct.chroma);
  }
  static fromHueAndChroma(hue, chroma) {
    return new _TonalPalette(hue, chroma);
  }
  tone(tone) {
    let argb = __privateGet(this, _cache).get(tone);
    if (argb === void 0) {
      argb = Hct.from(this.hue, this.chroma, tone).toInt();
      __privateGet(this, _cache).set(tone, argb);
    }
    return argb;
  }
};
var TonalPalette = _TonalPalette;
__name(TonalPalette, "TonalPalette");
_cache = new WeakMap();

// utils/hct/CorePalette.js
var CorePalette = class {
  a1;
  a2;
  a3;
  n1;
  n2;
  error;
  static of(argb) {
    return new CorePalette(argb, false);
  }
  static contentOf(argb) {
    return new CorePalette(argb, true);
  }
  constructor(argb, isContent) {
    const hct = Hct.fromInt(argb);
    const { hue } = hct;
    const { chroma } = hct;
    if (isContent) {
      this.a1 = TonalPalette.fromHueAndChroma(hue, chroma);
      this.a2 = TonalPalette.fromHueAndChroma(hue, chroma / 3);
      this.a3 = TonalPalette.fromHueAndChroma(hue + 60, chroma / 2);
      this.n1 = TonalPalette.fromHueAndChroma(hue, Math.min(chroma / 12, 4));
      this.n2 = TonalPalette.fromHueAndChroma(hue, Math.min(chroma / 6, 8));
    } else {
      this.a1 = TonalPalette.fromHueAndChroma(hue, Math.max(48, chroma));
      this.a2 = TonalPalette.fromHueAndChroma(hue, 16);
      this.a3 = TonalPalette.fromHueAndChroma(hue + 60, 24);
      this.n1 = TonalPalette.fromHueAndChroma(hue, 4);
      this.n2 = TonalPalette.fromHueAndChroma(hue, 8);
    }
    this.error = TonalPalette.fromHueAndChroma(25, 84);
  }
};
__name(CorePalette, "CorePalette");

// utils/hct/Scheme.js
init_polyfills();
var _lightFromCorePalette, lightFromCorePalette_fn, _darkFromCorePalette, darkFromCorePalette_fn;
var _Scheme = class {
  constructor(primary, onPrimary, primaryContainer, onPrimaryContainer, secondary, onSecondary, secondaryContainer, onSecondaryContainer, tertiary, onTertiary, tertiaryContainer, onTertiaryContainer, error, onError, errorContainer, onErrorContainer, background, onBackground, surface, onSurface, surfaceVariant, onSurfaceVariant, outline, shadow, inverseSurface, inverseOnSurface, inversePrimary) {
    this.primary = primary;
    this.onPrimary = onPrimary;
    this.primaryContainer = primaryContainer;
    this.onPrimaryContainer = onPrimaryContainer;
    this.secondary = secondary;
    this.onSecondary = onSecondary;
    this.secondaryContainer = secondaryContainer;
    this.onSecondaryContainer = onSecondaryContainer;
    this.tertiary = tertiary;
    this.onTertiary = onTertiary;
    this.tertiaryContainer = tertiaryContainer;
    this.onTertiaryContainer = onTertiaryContainer;
    this.error = error;
    this.onError = onError;
    this.errorContainer = errorContainer;
    this.onErrorContainer = onErrorContainer;
    this.background = background;
    this.onBackground = onBackground;
    this.surface = surface;
    this.onSurface = onSurface;
    this.surfaceVariant = surfaceVariant;
    this.onSurfaceVariant = onSurfaceVariant;
    this.outline = outline;
    this.shadow = shadow;
    this.inverseSurface = inverseSurface;
    this.inverseOnSurface = inverseOnSurface;
    this.inversePrimary = inversePrimary;
  }
  static light(argb) {
    var _a;
    return __privateMethod(_a = _Scheme, _lightFromCorePalette, lightFromCorePalette_fn).call(_a, CorePalette.of(argb));
  }
  static dark(argb) {
    var _a;
    return __privateMethod(_a = _Scheme, _darkFromCorePalette, darkFromCorePalette_fn).call(_a, CorePalette.of(argb));
  }
  static lightContent(argb) {
    var _a;
    return __privateMethod(_a = _Scheme, _lightFromCorePalette, lightFromCorePalette_fn).call(_a, CorePalette.contentOf(argb));
  }
  static darkContent(argb) {
    var _a;
    return __privateMethod(_a = _Scheme, _darkFromCorePalette, darkFromCorePalette_fn).call(_a, CorePalette.contentOf(argb));
  }
  withPrimary(primary) {
    this.primary = primary;
    return this;
  }
  withOnPrimary(onPrimary) {
    this.onPrimary = onPrimary;
    return this;
  }
  withPrimaryContainer(primaryContainer) {
    this.primaryContainer = primaryContainer;
    return this;
  }
  withOnPrimaryContainer(onPrimaryContainer) {
    this.onPrimaryContainer = onPrimaryContainer;
    return this;
  }
  withSecondary(secondary) {
    this.secondary = secondary;
    return this;
  }
  withOnSecondary(onSecondary) {
    this.onSecondary = onSecondary;
    return this;
  }
  withSecondaryContainer(secondaryContainer) {
    this.secondaryContainer = secondaryContainer;
    return this;
  }
  withOnSecondaryContainer(onSecondaryContainer) {
    this.onSecondaryContainer = onSecondaryContainer;
    return this;
  }
  withTertiary(tertiary) {
    this.tertiary = tertiary;
    return this;
  }
  withOnTertiary(onTertiary) {
    this.onTertiary = onTertiary;
    return this;
  }
  withTertiaryContainer(tertiaryContainer) {
    this.tertiaryContainer = tertiaryContainer;
    return this;
  }
  withOnTertiaryContainer(onTertiaryContainer) {
    this.onTertiaryContainer = onTertiaryContainer;
    return this;
  }
  withError(error) {
    this.error = error;
    return this;
  }
  withOnError(onError) {
    this.onError = onError;
    return this;
  }
  withErrorContainer(errorContainer) {
    this.errorContainer = errorContainer;
    return this;
  }
  withOnErrorContainer(onErrorContainer) {
    this.onErrorContainer = onErrorContainer;
    return this;
  }
  withBackground(background) {
    this.background = background;
    return this;
  }
  withOnBackground(onBackground) {
    this.onBackground = onBackground;
    return this;
  }
  withSurface(surface) {
    this.surface = surface;
    return this;
  }
  withOnSurface(onSurface) {
    this.onSurface = onSurface;
    return this;
  }
  withSurfaceVariant(surfaceVariant) {
    this.surfaceVariant = surfaceVariant;
    return this;
  }
  withOnSurfaceVariant(onSurfaceVariant) {
    this.onSurfaceVariant = onSurfaceVariant;
    return this;
  }
  withOutline(outline) {
    this.outline = outline;
    return this;
  }
  withShadow(shadow) {
    this.shadow = shadow;
    return this;
  }
  withInverseSurface(inverseSurface) {
    this.inverseSurface = inverseSurface;
    return this;
  }
  withInverseOnSurface(inverseOnSurface) {
    this.inverseOnSurface = inverseOnSurface;
    return this;
  }
  withInversePrimary(inversePrimary) {
    this.inversePrimary = inversePrimary;
    return this;
  }
  equals(object) {
    if (this === object) {
      return true;
    }
    if (!(object instanceof _Scheme)) {
      return false;
    }
    const scheme = object;
    if (this.primary !== scheme.primary) {
      return false;
    }
    if (this.onPrimary !== scheme.onPrimary) {
      return false;
    }
    if (this.primaryContainer !== scheme.primaryContainer) {
      return false;
    }
    if (this.onPrimaryContainer !== scheme.onPrimaryContainer) {
      return false;
    }
    if (this.secondary !== scheme.secondary) {
      return false;
    }
    if (this.onSecondary !== scheme.onSecondary) {
      return false;
    }
    if (this.secondaryContainer !== scheme.secondaryContainer) {
      return false;
    }
    if (this.onSecondaryContainer !== scheme.onSecondaryContainer) {
      return false;
    }
    if (this.tertiary !== scheme.tertiary) {
      return false;
    }
    if (this.onTertiary !== scheme.onTertiary) {
      return false;
    }
    if (this.tertiaryContainer !== scheme.tertiaryContainer) {
      return false;
    }
    if (this.onTertiaryContainer !== scheme.onTertiaryContainer) {
      return false;
    }
    if (this.error !== scheme.error) {
      return false;
    }
    if (this.onError !== scheme.onError) {
      return false;
    }
    if (this.errorContainer !== scheme.errorContainer) {
      return false;
    }
    if (this.onErrorContainer !== scheme.onErrorContainer) {
      return false;
    }
    if (this.background !== scheme.background) {
      return false;
    }
    if (this.onBackground !== scheme.onBackground) {
      return false;
    }
    if (this.surface !== scheme.surface) {
      return false;
    }
    if (this.onSurface !== scheme.onSurface) {
      return false;
    }
    if (this.surfaceVariant !== scheme.surfaceVariant) {
      return false;
    }
    if (this.onSurfaceVariant !== scheme.onSurfaceVariant) {
      return false;
    }
    if (this.outline !== scheme.outline) {
      return false;
    }
    if (this.shadow !== scheme.shadow) {
      return false;
    }
    if (this.inverseSurface !== scheme.inverseSurface) {
      return false;
    }
    if (this.inverseOnSurface !== scheme.inverseOnSurface) {
      return false;
    }
    if (this.inversePrimary !== scheme.inversePrimary) {
      return false;
    }
    return true;
  }
};
var Scheme = _Scheme;
__name(Scheme, "Scheme");
_lightFromCorePalette = new WeakSet();
lightFromCorePalette_fn = /* @__PURE__ */ __name(function(core) {
  return new _Scheme().withPrimary(core.a1.tone(40)).withOnPrimary(core.a1.tone(100)).withPrimaryContainer(core.a1.tone(90)).withOnPrimaryContainer(core.a1.tone(10)).withSecondary(core.a2.tone(40)).withOnSecondary(core.a2.tone(100)).withSecondaryContainer(core.a2.tone(90)).withOnSecondaryContainer(core.a2.tone(10)).withTertiary(core.a3.tone(40)).withOnTertiary(core.a3.tone(100)).withTertiaryContainer(core.a3.tone(90)).withOnTertiaryContainer(core.a3.tone(10)).withError(core.error.tone(40)).withOnError(core.error.tone(100)).withErrorContainer(core.error.tone(90)).withOnErrorContainer(core.error.tone(10)).withBackground(core.n1.tone(99)).withOnBackground(core.n1.tone(10)).withSurface(core.n1.tone(99)).withOnSurface(core.n1.tone(10)).withSurfaceVariant(core.n2.tone(90)).withOnSurfaceVariant(core.n2.tone(30)).withOutline(core.n2.tone(50)).withShadow(core.n1.tone(0)).withInverseSurface(core.n1.tone(20)).withInverseOnSurface(core.n1.tone(95)).withInversePrimary(core.a1.tone(80));
}, "#lightFromCorePalette");
_darkFromCorePalette = new WeakSet();
darkFromCorePalette_fn = /* @__PURE__ */ __name(function(core) {
  return new _Scheme().withPrimary(core.a1.tone(80)).withOnPrimary(core.a1.tone(20)).withPrimaryContainer(core.a1.tone(30)).withOnPrimaryContainer(core.a1.tone(90)).withSecondary(core.a2.tone(80)).withOnSecondary(core.a2.tone(20)).withSecondaryContainer(core.a2.tone(30)).withOnSecondaryContainer(core.a2.tone(90)).withTertiary(core.a3.tone(80)).withOnTertiary(core.a3.tone(20)).withTertiaryContainer(core.a3.tone(30)).withOnTertiaryContainer(core.a3.tone(90)).withError(core.error.tone(80)).withOnError(core.error.tone(20)).withErrorContainer(core.error.tone(30)).withOnErrorContainer(core.error.tone(80)).withBackground(core.n1.tone(10)).withOnBackground(core.n1.tone(90)).withSurface(core.n1.tone(10)).withOnSurface(core.n1.tone(90)).withSurfaceVariant(core.n2.tone(30)).withOnSurfaceVariant(core.n2.tone(80)).withOutline(core.n2.tone(60)).withShadow(core.n1.tone(0)).withInverseSurface(core.n1.tone(90)).withInverseOnSurface(core.n1.tone(20)).withInversePrimary(core.a1.tone(40));
}, "#darkFromCorePalette");
__privateAdd(Scheme, _lightFromCorePalette);
__privateAdd(Scheme, _darkFromCorePalette);

// utils/hct/blend.js
init_polyfills();
function harmonize(designColor, sourceColor) {
  const fromHct = Hct.fromInt(designColor);
  const toHct = Hct.fromInt(sourceColor);
  const differenceDegrees2 = differenceDegrees(fromHct.hue, toHct.hue);
  const rotationDegrees = Math.min(differenceDegrees2 * 0.5, 15);
  const outputHue = sanitizeDegreesDouble(
    fromHct.hue + rotationDegrees * rotationDirection(fromHct.hue, toHct.hue)
  );
  return Hct.from(outputHue, fromHct.chroma, fromHct.tone).toInt();
}
__name(harmonize, "harmonize");

// utils/hct/helper.js
function parseIntHex(value) {
  return Number.parseInt(value, 16);
}
__name(parseIntHex, "parseIntHex");
function argbFromHex(hex) {
  hex = hex.replace("#", "");
  const isThree = hex.length === 3;
  const isSix = hex.length === 6;
  const isEight = hex.length === 8;
  if (!isThree && !isSix && !isEight) {
    throw new Error(`unexpected hex ${hex}`);
  }
  let r = 0;
  let g = 0;
  let b = 0;
  if (isThree) {
    r = parseIntHex(hex.slice(0, 1).repeat(2));
    g = parseIntHex(hex.slice(1, 2).repeat(2));
    b = parseIntHex(hex.slice(2, 3).repeat(2));
  } else if (isSix) {
    r = parseIntHex(hex.slice(0, 2));
    g = parseIntHex(hex.slice(2, 4));
    b = parseIntHex(hex.slice(4, 6));
  } else if (isEight) {
    r = parseIntHex(hex.slice(2, 4));
    g = parseIntHex(hex.slice(4, 6));
    b = parseIntHex(hex.slice(6, 8));
  }
  return (255 << 24 | (r & 255) << 16 | (g & 255) << 8 | b & 255) >>> 0;
}
__name(argbFromHex, "argbFromHex");
function cssVarFromArgb(argb) {
  return [
    redFromArgb(argb),
    greenFromArgb(argb),
    blueFromArgb(argb)
  ].join(",");
}
__name(cssVarFromArgb, "cssVarFromArgb");
function cssVariablesFromScheme(scheme) {
  return `
    :root {
      --mdw-color__primary: ${cssVarFromArgb(scheme.primary)};
      --mdw-color__on-primary: ${cssVarFromArgb(scheme.onPrimary)};
      --mdw-color__primary-container: ${cssVarFromArgb(scheme.primaryContainer)};
      --mdw-color__on-primary-container: ${cssVarFromArgb(scheme.onPrimaryContainer)};
      --mdw-color__secondary: ${cssVarFromArgb(scheme.secondary)};
      --mdw-color__on-secondary: ${cssVarFromArgb(scheme.onSecondary)};
      --mdw-color__secondary-container: ${cssVarFromArgb(scheme.secondaryContainer)};
      --mdw-color__on-secondary-container: ${cssVarFromArgb(scheme.onSecondaryContainer)};
      --mdw-color__tertiary: ${cssVarFromArgb(scheme.tertiary)};
      --mdw-color__on-tertiary: ${cssVarFromArgb(scheme.onTertiary)};
      --mdw-color__tertiary-container: ${cssVarFromArgb(scheme.tertiaryContainer)};
      --mdw-color__on-tertiary-container: ${cssVarFromArgb(scheme.onTertiaryContainer)};
      --mdw-color__error: ${cssVarFromArgb(scheme.error)};
      --mdw-color__on-error: ${cssVarFromArgb(scheme.onError)};
      --mdw-color__error-container: ${cssVarFromArgb(scheme.errorContainer)};
      --mdw-color__on-error-container: ${cssVarFromArgb(scheme.onErrorContainer)};
      --mdw-color__background: ${cssVarFromArgb(scheme.background)};
      --mdw-color__on-background: ${cssVarFromArgb(scheme.onBackground)};
      --mdw-color__surface: ${cssVarFromArgb(scheme.surface)};
      --mdw-color__on-surface: ${cssVarFromArgb(scheme.onSurface)};
      --mdw-color__surface-variant: ${cssVarFromArgb(scheme.surfaceVariant)};
      --mdw-color__on-surface-variant: ${cssVarFromArgb(scheme.onSurfaceVariant)};
      --mdw-color__outline: ${cssVarFromArgb(scheme.outline)};
      --mdw-color__shadow: ${cssVarFromArgb(scheme.shadow)};
      --mdw-color__inverse-surface: ${cssVarFromArgb(scheme.inverseSurface)};
      --mdw-color__inverse-on-surface: ${cssVarFromArgb(scheme.inverseOnSurface)};
      --mdw-color__inverse-primary: ${cssVarFromArgb(scheme.inversePrimary)};
    }
  `;
}
__name(cssVariablesFromScheme, "cssVariablesFromScheme");
function cssVariablesFromCustom(name, tonalPalette, isDark) {
  return `
    :root {
      --mdw-color__${name}: ${cssVarFromArgb(tonalPalette.tone(isDark ? 80 : 40))};
      --mdw-color__on-${name}: ${cssVarFromArgb(tonalPalette.tone(isDark ? 20 : 100))};
      --mdw-color__${name}-container: ${cssVarFromArgb(tonalPalette.tone(isDark ? 30 : 90))};
      --mdw-color__on-${name}-container: ${cssVarFromArgb(tonalPalette.tone(isDark ? 90 : 10))};
    }
    .mdw-custom[color="${name}"] {
      --mdw-bg: var(--mdw-color__${name});
      --mdw-ink: var(--mdw-color__on-${name});
    }
    .mdw-custom[color="${name}-container"] {
      --mdw-bg: var(--mdw-color__${name}-container);
      --mdw-ink: var(--mdw-color__on-${name}-container);
    }
    .mdw-custom[ink="${name}"] {
      --mdw-ink: var(--mdw-color__${name});
    }
    
    
  `;
}
__name(cssVariablesFromCustom, "cssVariablesFromCustom");
function getScheme(mainColor, customColors = []) {
  const argbColor = argbFromHex(mainColor);
  const lightRules = [cssVariablesFromScheme(Scheme.light(argbColor))];
  const darkRules = [cssVariablesFromScheme(Scheme.dark(argbColor))];
  const lightContentRules = [cssVariablesFromScheme(Scheme.lightContent(argbColor))];
  const darkContentRules = [cssVariablesFromScheme(Scheme.darkContent(argbColor))];
  for (const [name, color2] of customColors) {
    const argbCustom = argbFromHex(color2);
    const blended = harmonize(argbCustom, argbColor);
    const { a1: tp } = CorePalette.of(blended);
    const { a1: ctp } = CorePalette.contentOf(blended);
    lightRules.push(cssVariablesFromCustom(name, tp));
    darkRules.push(cssVariablesFromCustom(name, tp, true));
    lightContentRules.push(cssVariablesFromCustom(name, ctp));
    darkContentRules.push(cssVariablesFromCustom(name, ctp, true));
  }
  return {
    light: lightRules.join("\n"),
    dark: darkRules.join("\n"),
    lightContent: lightContentRules.join("\n"),
    darkContent: darkContentRules.join("\n")
  };
}
__name(getScheme, "getScheme");

// core/theme/index.js
function cornerCutClipPath() {
  const TOP = 0;
  const END = "100%";
  const BOTTOM = "100%";
  const START = 0;
  const TOP_START_SIZE = "var(--mdw-shape__size__top-start-size)";
  const TOP_END_SIZE = "var(--mdw-shape__size__top-end-size)";
  const BOTTOM_START_SIZE = "var(--mdw-shape__size__bottom-start-size)";
  const BOTTOM_END_SIZE = "var(--mdw-shape__size__bottom-end-size)";
  const TOP_INSET = /* @__PURE__ */ __name((size) => `min(${size},50%)`, "TOP_INSET");
  const START_INSET = /* @__PURE__ */ __name((size) => `min(${size},50%)`, "START_INSET");
  const END_INSET = /* @__PURE__ */ __name((size) => `calc(100% - min(${size},50%))`, "END_INSET");
  const BOTTOM_INSET = /* @__PURE__ */ __name((size) => `calc(100% - min(${size},50%))`, "BOTTOM_INSET");
  return `polygon(${[
    [TOP, TOP_INSET(TOP_START_SIZE)],
    [TOP, END_INSET(TOP_END_SIZE)],
    [TOP_INSET(TOP_END_SIZE), END],
    [BOTTOM_INSET(BOTTOM_END_SIZE), END],
    [BOTTOM, END_INSET(BOTTOM_END_SIZE)],
    [BOTTOM, START_INSET(BOTTOM_START_SIZE)],
    [BOTTOM_INSET(BOTTOM_START_SIZE), START],
    [TOP_INSET(TOP_START_SIZE), START]
  ].map((coordinates) => coordinates.join(" ")).join(", ")})`;
}
__name(cornerCutClipPath, "cornerCutClipPath");
var SHAPE_ROUNDED_DEFAULT = {
  size: {
    extraSmall: "4px",
    small: "8px",
    medium: "12px",
    large: "16px",
    extraLarge: "28px",
    full: "999px"
  },
  clipPath: void 0
};
var SHAPE_CUT_DEFAULT = {
  size: {
    extraSmall: "4px",
    small: "8px",
    medium: "12px",
    large: "16px",
    extraLarge: "28px",
    full: "999px"
  },
  clipPath: cornerCutClipPath()
};
var SP = 1 / 16;
var TYPOGRAPHY_DEFAULT = {
  face: {
    brand: '"Roboto", sans-serif',
    plain: '"Roboto", sans-serif',
    weight: {
      regular: 400,
      medium: 500
    }
  },
  scale: {
    display: {
      large: {
        fontFamily: "var(--mdw-typeface__brand)",
        lineHeight: 64,
        fontSize: 57,
        letterSpacing: -0.25,
        weight: "var(--mdw-typeface__weight-regular)"
      },
      medium: {
        fontFamily: "var(--mdw-typeface__brand)",
        lineHeight: 52,
        fontSize: 45,
        letterSpacing: 0,
        weight: "var(--mdw-typeface__weight-regular)"
      },
      small: {
        fontFamily: "var(--mdw-typeface__brand)",
        lineHeight: 44,
        fontSize: 36,
        letterSpacing: 0,
        weight: "var(--mdw-typeface__weight-regular)"
      }
    },
    headline: {
      large: {
        fontFamily: "var(--mdw-typeface__brand)",
        lineHeight: 40,
        fontSize: 32,
        letterSpacing: 0,
        weight: "var(--mdw-typeface__weight-regular)"
      },
      medium: {
        fontFamily: "var(--mdw-typeface__brand)",
        lineHeight: 36,
        fontSize: 28,
        letterSpacing: 0,
        weight: "var(--mdw-typeface__weight-regular)"
      },
      small: {
        fontFamily: "var(--mdw-typeface__brand)",
        lineHeight: 32,
        fontSize: 24,
        letterSpacing: 0,
        weight: "var(--mdw-typeface__weight-regular)"
      }
    },
    title: {
      large: {
        fontFamily: "var(--mdw-typeface__brand)",
        lineHeight: 28,
        fontSize: 22,
        letterSpacing: 0,
        weight: "var(--mdw-typeface__weight-regular)"
      },
      medium: {
        fontFamily: "var(--mdw-typeface__plain)",
        lineHeight: 24,
        fontSize: 16,
        letterSpacing: 0.1,
        weight: "var(--mdw-typeface__weight-medium)"
      },
      small: {
        fontFamily: "var(--mdw-typeface__plain)",
        lineHeight: 20,
        fontSize: 14,
        letterSpacing: 0.1,
        weight: "var(--mdw-typeface__weight-medium)"
      }
    },
    label: {
      large: {
        fontFamily: "var(--mdw-typeface__plain)",
        lineHeight: 20,
        fontSize: 14,
        letterSpacing: 0.1,
        weight: "var(--mdw-typeface__weight-medium)"
      },
      medium: {
        fontFamily: "var(--mdw-typeface__plain)",
        lineHeight: 16,
        fontSize: 12,
        letterSpacing: 0.5,
        weight: "var(--mdw-typeface__weight-medium)"
      },
      small: {
        fontFamily: "var(--mdw-typeface__plain)",
        lineHeight: 16,
        fontSize: 11,
        letterSpacing: 0.5,
        weight: "var(--mdw-typeface__weight-medium)"
      }
    },
    body: {
      large: {
        fontFamily: "var(--mdw-typeface__plain)",
        lineHeight: 24,
        fontSize: 16,
        letterSpacing: 0.5,
        weight: "var(--mdw-typeface__weight-regular)"
      },
      medium: {
        fontFamily: "var(--mdw-typeface__plain)",
        lineHeight: 20,
        fontSize: 14,
        letterSpacing: 0.25,
        weight: "var(--mdw-typeface__weight-regular)"
      },
      small: {
        fontFamily: "var(--mdw-typeface__brand)",
        lineHeight: 16,
        fontSize: 12,
        letterSpacing: 0.4,
        weight: "var(--mdw-typeface__weight-regular)"
      }
    }
  }
};
function getTypographyStyle(config = TYPOGRAPHY_DEFAULT) {
  return `
    :root {
      --mdw-typeface__brand: ${config.face.brand};
      --mdw-typeface__weight-regular: ${config.face.weight.regular};
      --mdw-typeface__weight-medium: ${config.face.weight.medium};
      --mdw-typeface__plain: ${config.face.plain};

      --mdw-typescale__display-large__font-family: ${config.scale.display.large.fontFamily};
      --mdw-typescale__display-large__line-height: calc(${config.scale.display.large.lineHeight} * 0.0625rem);
      --mdw-typescale__display-large__font-size: calc(${config.scale.display.large.fontSize} * 0.0625rem);
      --mdw-typescale__display-large__letter-spacing: calc(${config.scale.display.large.letterSpacing} * 0.0625rem);
      --mdw-typescale__display-large__font-weight: ${config.scale.display.large.weight};

      --mdw-typescale__display-medium__font-family: ${config.scale.display.medium.fontFamily};
      --mdw-typescale__display-medium__line-height: calc(${config.scale.display.medium.lineHeight} * 0.0625rem);
      --mdw-typescale__display-medium__font-size: calc(${config.scale.display.medium.fontSize} * 0.0625rem);
      --mdw-typescale__display-medium__letter-spacing: calc(${config.scale.display.medium.letterSpacing} * 0.0625rem);
      --mdw-typescale__display-medium__font-weight: ${config.scale.display.medium.weight};

      --mdw-typescale__display-small__font-family: ${config.scale.display.small.fontFamily};
      --mdw-typescale__display-small__line-height: calc(${config.scale.display.small.lineHeight} * 0.0625rem);
      --mdw-typescale__display-small__font-size: calc(${config.scale.display.small.fontSize} * 0.0625rem);
      --mdw-typescale__display-small__letter-spacing: calc(${config.scale.display.small.letterSpacing} * 0.0625rem);
      --mdw-typescale__display-small__font-weight: ${config.scale.display.small.weight};

      --mdw-typescale__headline-large__font-family: ${config.scale.headline.large.fontFamily};
      --mdw-typescale__headline-large__line-height: calc(${config.scale.headline.large.lineHeight} * 0.0625rem);
      --mdw-typescale__headline-large__font-size: calc(${config.scale.headline.large.fontSize} * 0.0625rem);
      --mdw-typescale__headline-large__letter-spacing: calc(${config.scale.headline.large.letterSpacing} * 0.0625rem);
      --mdw-typescale__headline-large__font-weight: ${config.scale.headline.large.weight};

      --mdw-typescale__headline-medium__font-family: ${config.scale.headline.medium.fontFamily};
      --mdw-typescale__headline-medium__line-height: calc(${config.scale.headline.medium.lineHeight} * 0.0625rem);
      --mdw-typescale__headline-medium__font-size: calc(${config.scale.headline.medium.fontSize} * 0.0625rem);
      --mdw-typescale__headline-medium__letter-spacing: calc(${config.scale.headline.medium.letterSpacing} * 0.0625rem);
      --mdw-typescale__headline-medium__font-weight: ${config.scale.headline.medium.weight};

      --mdw-typescale__headline-small__font-family: ${config.scale.headline.small.fontFamily};
      --mdw-typescale__headline-small__line-height: calc(${config.scale.headline.small.lineHeight} * 0.0625rem);
      --mdw-typescale__headline-small__font-size: calc(${config.scale.headline.small.fontSize} * 0.0625rem);
      --mdw-typescale__headline-small__letter-spacing: calc(${config.scale.headline.small.letterSpacing} * 0.0625rem);
      --mdw-typescale__headline-small__font-weight: ${config.scale.headline.small.weight};

      --mdw-typescale__title-large__font-family: ${config.scale.title.large.fontFamily};
      --mdw-typescale__title-large__line-height: calc(${config.scale.title.large.lineHeight} * 0.0625rem);
      --mdw-typescale__title-large__font-size: calc(${config.scale.title.large.fontSize} * 0.0625rem);
      --mdw-typescale__title-large__letter-spacing: calc(${config.scale.title.large.letterSpacing} * 0.0625rem);
      --mdw-typescale__title-large__font-weight: ${config.scale.title.large.weight};

      --mdw-typescale__title-medium__font-family: ${config.scale.title.medium.fontFamily};
      --mdw-typescale__title-medium__line-height: calc(${config.scale.title.medium.lineHeight} * 0.0625rem);
      --mdw-typescale__title-medium__font-size: calc(${config.scale.title.medium.fontSize} * 0.0625rem);
      --mdw-typescale__title-medium__letter-spacing: calc(${config.scale.title.medium.letterSpacing} * 0.0625rem);
      --mdw-typescale__title-medium__font-weight: ${config.scale.title.medium.weight};

      --mdw-typescale__title-small__font-family: ${config.scale.title.small.fontFamily};
      --mdw-typescale__title-small__line-height: calc(${config.scale.title.small.lineHeight} * 0.0625rem);
      --mdw-typescale__title-small__font-size: calc(${config.scale.title.small.fontSize} * 0.0625rem);
      --mdw-typescale__title-small__letter-spacing: calc(${config.scale.title.small.letterSpacing} * 0.0625rem);
      --mdw-typescale__title-small__font-weight: ${config.scale.title.small.weight};

      --mdw-typescale__label-large__font-family: ${config.scale.label.large.fontFamily};
      --mdw-typescale__label-large__line-height: calc(${config.scale.label.large.lineHeight} * 0.0625rem);
      --mdw-typescale__label-large__font-size: calc(${config.scale.label.large.fontSize} * 0.0625rem);
      --mdw-typescale__label-large__letter-spacing: calc(${config.scale.label.large.letterSpacing} * 0.0625rem);
      --mdw-typescale__label-large__font-weight: ${config.scale.label.large.weight};

      --mdw-typescale__label-medium__font-family: ${config.scale.label.medium.fontFamily};
      --mdw-typescale__label-medium__line-height: calc(${config.scale.label.medium.lineHeight} * 0.0625rem);
      --mdw-typescale__label-medium__font-size: calc(${config.scale.label.medium.fontSize} * 0.0625rem);
      --mdw-typescale__label-medium__letter-spacing: calc(${config.scale.label.medium.letterSpacing} * 0.0625rem);
      --mdw-typescale__label-medium__font-weight: ${config.scale.label.medium.weight};

      --mdw-typescale__label-small__font-family: ${config.scale.label.small.fontFamily};
      --mdw-typescale__label-small__line-height: calc(${config.scale.label.small.lineHeight} * 0.0625rem);
      --mdw-typescale__label-small__font-size: calc(${config.scale.label.small.fontSize} * 0.0625rem);
      --mdw-typescale__label-small__letter-spacing: calc(${config.scale.label.small.letterSpacing} * 0.0625rem);
      --mdw-typescale__label-small__font-weight: ${config.scale.label.small.weight};

      --mdw-typescale__body-large__font-family: ${config.scale.body.large.fontFamily};
      --mdw-typescale__body-large__line-height: calc(${config.scale.body.large.lineHeight} * 0.0625rem);
      --mdw-typescale__body-large__font-size: calc(${config.scale.body.large.fontSize} * 0.0625rem);
      --mdw-typescale__body-large__letter-spacing: calc(${config.scale.body.large.letterSpacing} * 0.0625rem);
      --mdw-typescale__body-large__font-weight: ${config.scale.body.large.weight};

      --mdw-typescale__body-medium__font-family: ${config.scale.body.medium.fontFamily};
      --mdw-typescale__body-medium__line-height: calc(${config.scale.body.medium.lineHeight} * 0.0625rem);
      --mdw-typescale__body-medium__font-size: calc(${config.scale.body.medium.fontSize} * 0.0625rem);
      --mdw-typescale__body-medium__letter-spacing: calc(${config.scale.body.medium.letterSpacing} * 0.0625rem);
      --mdw-typescale__body-medium__font-weight: ${config.scale.body.medium.weight};

      --mdw-typescale__body-small__font-family: ${config.scale.body.small.fontFamily};
      --mdw-typescale__body-small__line-height: calc(${config.scale.body.small.lineHeight} * 0.0625rem);
      --mdw-typescale__body-small__font-size: calc(${config.scale.body.small.fontSize} * 0.0625rem);
      --mdw-typescale__body-small__letter-spacing: calc(${config.scale.body.small.letterSpacing} * 0.0625rem);
      --mdw-typescale__body-small__font-weight: ${config.scale.body.small.weight};
    }
  `;
}
__name(getTypographyStyle, "getTypographyStyle");
function getShapeStyle(config = SHAPE_ROUNDED_DEFAULT) {
  return `
    :root {
      --mdw-shape__extra-small: ${config.size.extraSmall};
      --mdw-shape__small: ${config.size.small};
      --mdw-shape__medium: ${config.size.medium};
      --mdw-shape__large: ${config.size.large};
      --mdw-shape__extra-large: ${config.size.extraLarge};
      --mdw-shape__full: ${config.size.full};
    }
  `;
}
__name(getShapeStyle, "getShapeStyle");
function addStyle(content) {
  const element = document.createElement("style");
  element.textContent = content;
  document.head.append(element);
  return element;
}
__name(addStyle, "addStyle");
function setupTheme({ color: color2 = "#6750A4", custom: custom2 = [], lightness = "auto" }) {
  const parsedColors = [...custom2].map(([name, hex]) => [name, COLOR_KEYWORDS.get(hex) || hex || COLOR_KEYWORDS.get(name)]);
  const scheme = getScheme(color2, parsedColors);
  if (lightness === "dark") {
    addStyle(scheme.dark);
  } else {
    addStyle(scheme.light);
    if (lightness !== "light") {
      addStyle(scheme.dark).media = "(prefers-color-scheme:dark)";
    }
  }
  addStyle(getShapeStyle());
  addStyle(getTypographyStyle());
}
__name(setupTheme, "setupTheme");

// index.js
MDWText.register();
MDWContainer.register();
MDWOverlay.register();
MDWIcon2.register();
MDWButton.register();
MDWFab.register();
MDWExtendedFab.register();
MDWIconButton.register();
MDWSegmentedButtonGroup.register();
MDWSegmentedButton.register();
MDWBottomAppBar.register();
MDWCard.register();
MDWCardActionArea.register();
MDWChip.register();
MDWFilterChip.register();
MDWDialog.register();
MDWIcon.register();
var { searchParams } = new URL(import.meta.url);
var color = searchParams.get("color") || "#6750A4";
var custom = searchParams.getAll("custom").flatMap((c) => c.split(",")).map((c) => c.split(":"));
setupTheme({
  color,
  custom,
  lightness: searchParams.get("lightness")
});
/*! For license information please see index.min.js.LEGAL.txt */
//# sourceMappingURL=index.min.js.map
