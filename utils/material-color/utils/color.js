/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// This file is automatically generated. Do not modify it.

import * as mathUtils from './math.js';

/**
 * Color science utilities.
 *
 * Utility methods for color science constants and color space
 * conversions that aren't HCT or CAM16.
 */

const SRGB_TO_XYZ = [
  [0.412_338_95, 0.357_620_64, 0.180_510_42],
  [0.2126, 0.7152, 0.0722],
  [0.019_321_41, 0.119_163_82, 0.950_344_78],
];

const XYZ_TO_SRGB = [
  [
    3.241_377_479_238_868_5,
    -1.537_665_240_285_185_1,
    -0.498_853_668_462_680_53,
  ],
  [
    -0.969_145_251_300_532_1,
    1.875_885_345_106_787_2,
    0.041_565_856_169_120_61,
  ],
  [
    0.055_620_936_896_913_05,
    -0.203_955_245_647_421_23,
    1.057_179_911_122_033_5,
  ],
];

const WHITE_POINT_D65 = [95.047, 100, 108.883];

/**
 * Converts a color from RGB components to ARGB format.
 * @param {number} red
 * @param {number} green
 * @param {number} blue
 * @return {number}
 */
export function argbFromRgb(red, green, blue) {
  return (255 << 24 | (red & 255) << 16 | (green & 255) << 8 | blue & 255)
      >>> 0;
}

/**
 * Converts a color from linear RGB components to ARGB format.
 * @param {number[]} linrgb
 * @return {number}
 */
export function argbFromLinrgb(linrgb) {
  const r = delinearized(linrgb[0]);
  const g = delinearized(linrgb[1]);
  const b = delinearized(linrgb[2]);
  return argbFromRgb(r, g, b);
}

/**
 * Returns the alpha component of a color in ARGB format.
 * @param {number} argb
 * @return {number}
 */
export function alphaFromArgb(argb) {
  return argb >> 24 & 255;
}

/**
 * Returns the red component of a color in ARGB format.
 * @param {number} argb
 * @return {number}
 */
export function redFromArgb(argb) {
  return argb >> 16 & 255;
}

/**
 * Returns the green component of a color in ARGB format.
 * @param {number} argb
 * @return {number}
 */
export function greenFromArgb(argb) {
  return argb >> 8 & 255;
}

/**
 * Returns the blue component of a color in ARGB format.
 * @param {number} argb
 * @return {number}
 */
export function blueFromArgb(argb) {
  return argb & 255;
}

/**
 * Returns whether a color in ARGB format is opaque.
 * @param {number} argb
 * @return {boolean}
 */
export function isOpaque(argb) {
  return alphaFromArgb(argb) >= 255;
}

/**
 * Converts a color from ARGB to XYZ.
 * @param {number} x
 * @param {number} y
 * @param {number} z
 * @return {number}
 */
export function argbFromXyz(x, y, z) {
  const matrix = XYZ_TO_SRGB;
  const linearR = matrix[0][0] * x + matrix[0][1] * y + matrix[0][2] * z;
  const linearG = matrix[1][0] * x + matrix[1][1] * y + matrix[1][2] * z;
  const linearB = matrix[2][0] * x + matrix[2][1] * y + matrix[2][2] * z;
  const r = delinearized(linearR);
  const g = delinearized(linearG);
  const b = delinearized(linearB);
  return argbFromRgb(r, g, b);
}

/**
 * Converts a color from XYZ to ARGB.
 * @param {number} argb
 * @return {number[]}
 */
export function xyzFromArgb(argb) {
  const r = linearized(redFromArgb(argb));
  const g = linearized(greenFromArgb(argb));
  const b = linearized(blueFromArgb(argb));
  return mathUtils.matrixMultiply([r, g, b], SRGB_TO_XYZ);
}

/**
 * Converts a color represented in Lab color space into an ARGB
 * integer.
 * @param {number} l
 * @param {number} a
 * @param {number} b
 * @return {number}
 */
export function argbFromLab(l, a, b) {
  const whitePoint = WHITE_POINT_D65;
  const fy = (l + 16) / 116;
  const fx = a / 500 + fy;
  const fz = fy - b / 200;
  const xNormalized = labInvf(fx);
  const yNormalized = labInvf(fy);
  const zNormalized = labInvf(fz);
  const x = xNormalized * whitePoint[0];
  const y = yNormalized * whitePoint[1];
  const z = zNormalized * whitePoint[2];
  return argbFromXyz(x, y, z);
}

/**
 * Converts a color from ARGB representation to L*a*b*
 * representation.
 * @param {number} argb the ARGB representation of a color
 * @return {number[]} a Lab object representing the color
 */
export function labFromArgb(argb) {
  const linearR = linearized(redFromArgb(argb));
  const linearG = linearized(greenFromArgb(argb));
  const linearB = linearized(blueFromArgb(argb));
  const matrix = SRGB_TO_XYZ;
  const x = matrix[0][0] * linearR + matrix[0][1] * linearG + matrix[0][2] * linearB;
  const y = matrix[1][0] * linearR + matrix[1][1] * linearG + matrix[1][2] * linearB;
  const z = matrix[2][0] * linearR + matrix[2][1] * linearG + matrix[2][2] * linearB;
  const whitePoint = WHITE_POINT_D65;
  const xNormalized = x / whitePoint[0];
  const yNormalized = y / whitePoint[1];
  const zNormalized = z / whitePoint[2];
  const fx = labF(xNormalized);
  const fy = labF(yNormalized);
  const fz = labF(zNormalized);
  const l = 116 * fy - 16;
  const a = 500 * (fx - fy);
  const b = 200 * (fy - fz);
  return [l, a, b];
}

/**
 * Converts an L* value to an ARGB representation.
 * @param {number} lstar L* in L*a*b*
 * @return {number} ARGB representation of grayscale color with lightness
 * matching L*
 */
export function argbFromLstar(lstar) {
  const y = yFromLstar(lstar);
  const component = delinearized(y);
  return argbFromRgb(component, component, component);
}

/**
 * Computes the L* value of a color in ARGB representation.
 * @param {number} argb ARGB representation of a color
 * @return {number} L*, from L*a*b*, coordinate of the color
 */
export function lstarFromArgb(argb) {
  const y = xyzFromArgb(argb)[1];
  return 116 * labF(y / 100) - 16;
}

/**
 * Converts an L* value to a Y value.
 *
 * L* in L*a*b* and Y in XYZ measure the same quantity, luminance.
 *
 * L* measures perceptual luminance, a linear scale. Y in XYZ
 * measures relative luminance, a logarithmic scale.
 * @param {number} lstar L* in L*a*b*
 * @return {number} Y in XYZ
 */
export function yFromLstar(lstar) {
  return 100 * labInvf((lstar + 16) / 116);
}

/**
 * Converts a Y value to an L* value.
 *
 * L* in L*a*b* and Y in XYZ measure the same quantity, luminance.
 *
 * L* measures perceptual luminance, a linear scale. Y in XYZ
 * measures relative luminance, a logarithmic scale.
 * @param {number} y Y in XYZ
 * @return {number} L* in L*a*b*
 */
export function lstarFromY(y) {
  return labF(y / 100) * 116 - 16;
}

/**
 * Linearizes an RGB component.
 * @param {number} rgbComponent 0 <= rgb_component <= 255, represents R/G/B
 * channel
 * @return {number} 0.0 <= output <= 100.0, color channel converted to
 * linear RGB space
 */
export function linearized(rgbComponent) {
  const normalized = rgbComponent / 255;
  if (normalized <= 0.040_449_936) {
    return (normalized / 12.92) * 100;
  }
  return ((normalized + 0.055) / 1.055) ** 2.4 * 100;
}

/**
 * Delinearizes an RGB component.
 * @param {number} rgbComponent 0.0 <= rgb_component <= 100.0, represents
 * linear R/G/B channel
 * @return {number} 0 <= output <= 255, color channel converted to regular
 * RGB space
 */
export function delinearized(rgbComponent) {
  const normalized = rgbComponent / 100;
  let delinearized = 0;
  delinearized = normalized <= 0.003_130_8 ? normalized * 12.92 : 1.055 * normalized ** (1 / 2.4) - 0.055;
  return mathUtils.clampInt(0, 255, Math.round(delinearized * 255));
}

/**
 * Returns the standard white point; white on a sunny day.
 * @return {number[]} The white point
 */
export function whitePointD65() {
  return WHITE_POINT_D65;
}

/**
 * RGBA component
 * @typedef Rgba
 * @prop {number} r Red value should be between 0-255
 * @prop {number} g Green value should be between 0-255
 * @prop {number} b Blue value should be between 0-255
 * @prop {number} a Alpha value should be between 0-255
 */

/**
 * Return RGBA from a given int32 color
 * @param {number} argb ARGB representation of a int32 color.
 * @return {Rgba} RGBA representation of a int32 color.
 */
export function rgbaFromArgb(argb) {
  const r = redFromArgb(argb);
  const g = greenFromArgb(argb);
  const b = blueFromArgb(argb);
  const a = alphaFromArgb(argb);
  return { r, g, b, a };
}

/**
 * Return int32 color from a given RGBA component
 * @param {Rgba} rgba RGBA representation of a int32 color.
 * @return {number} ARGB representation of a int32 color.
 */
export function argbFromRgba({ r, g, b, a }) {
  const rValue = clampComponent(r);
  const gValue = clampComponent(g);
  const bValue = clampComponent(b);
  const aValue = clampComponent(a);
  return (aValue << 24) | (rValue << 16) | (gValue << 8) | bValue;
}

/**
 * @param {number} value
 * @return {number}
 */
function clampComponent(value) {
  if (value < 0) return 0;
  if (value > 255) return 255;
  return value;
}

/**
 *
 * @param {number} t
 * @return {number}
 */
function labF(t) {
  const e = 216 / 24_389;
  const kappa = 24_389 / 27;
  if (t > e) {
    return t ** (1 / 3);
  }
  return (kappa * t + 16) / 116;
}

/**
 *
 * @param {number} ft
 * @return {number}
 */
function labInvf(ft) {
  const e = 216 / 24_389;
  const kappa = 24_389 / 27;
  const ft3 = ft * ft * ft;
  if (ft3 > e) {
    return ft3;
  }
  return (116 * ft - 16) / kappa;
}
