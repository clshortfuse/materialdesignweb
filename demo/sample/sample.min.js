
    new EventSource('/esbuild').addEventListener('change', () => window.location.reload());
  
(() => {
  // core/optimizations.js
  var BLANK_TEXT;
  var BLANK_COMMENT;
  function createEmptyTextNode() {
    return (BLANK_TEXT ??= new Text()).cloneNode();
  }
  function createEmptyComment() {
    return (BLANK_COMMENT ??= new Comment()).cloneNode();
  }

  // core/CompositionAdapter.js
  var CompositionAdapter = class {
    /** @param {DomAdapterCreateOptions<T>} options */
    constructor(options) {
      this.anchorNode = options.anchorNode;
      this.metadata = [];
      this.keys = [];
      this.needsArrayKeyFastPath = false;
      this.composition = options.composition;
      this.renderOptions = options.renderOptions;
      this.metadataCache = null;
      this.queuedElements = [];
      this.batchStartIndex = null;
      this.batchEndIndex = null;
    }
    /**
     * @param {Partial<T>} changes
     * @param {T} data
     * @return {import('./Composition.js').RenderDraw<T>}
     */
    render(changes, data) {
      return this.composition.render(changes, data, this.renderOptions);
    }
    startBatch() {
      this.needsArrayKeyFastPath = true;
    }
    writeBatch() {
      var _a5;
      if (!this.queuedElements.length) return;
      const previousSibling = ((_a5 = this.metadata[this.batchStartIndex - 1]) == null ? void 0 : _a5.domNode) ?? this.anchorNode;
      previousSibling.after(...this.queuedElements);
      this.queuedElements.length = 0;
    }
    stopBatch() {
      this.writeBatch();
      this.needsArrayKeyFastPath = false;
      this.batchStartIndex = null;
      this.batchEndIndex = null;
      if (this.metadataCache) {
        for (const { domNode } of this.metadataCache.values()) {
          domNode.remove();
        }
        this.metadataCache.clear();
      }
    }
    /** @param {number} index */
    removeByIndex(index) {
      const [metadata] = this.metadata.splice(index, 1);
      const { domNode, key } = metadata;
      this.keys.splice(index, 1);
      domNode.remove();
      if (this.metadataCache) {
        this.metadataCache.set(key, metadata);
      } else {
        this.metadataCache = /* @__PURE__ */ new Map([[key, metadata]]);
      }
    }
    /**
     * Worst case scenario
     * @param {number} newIndex expectedIndex
     * @param {*} changes
     * @param {*} data
     * @param {*} key
     * @param {*} change
     * @param {boolean} [skipOnMatch]
     * JSON Merge has no way to express sort change and data change. Best
     * performance is done via invoking render on sort change and another on
     * inner change. Can't skip if mixing change types.
     */
    renderData(newIndex, changes, data, key, change, skipOnMatch) {
      var _a5;
      if (newIndex < this.metadata.length) {
        const metadataAtIndex = this.metadata[newIndex];
        const currentKey = metadataAtIndex.key;
        const sameKey = currentKey === key;
        const isPartial = change !== key;
        if (sameKey) {
          if (isPartial) {
            metadataAtIndex.render(changes, data);
          } else if (skipOnMatch) {
          } else {
            metadataAtIndex.render(changes, data);
          }
          return;
        }
        const metadataCache = this.metadataCache ??= /* @__PURE__ */ new Map();
        let failedFastPath = false;
        if (this.needsArrayKeyFastPath) {
          failedFastPath = !this.keys.includes(key);
          this.needsArrayFastPath = false;
        }
        const oldIndex = failedFastPath ? -1 : this.keys.indexOf(key, newIndex + 1);
        if (oldIndex === -1) {
          if (metadataCache.has(key)) {
            const previousMetadata = metadataCache.get(key);
            this.metadata.splice(newIndex, 0, previousMetadata);
            this.keys.splice(newIndex, 0, key);
            const previousSibling = ((_a5 = this.metadata[newIndex - 1]) == null ? void 0 : _a5.domNode) ?? this.anchorNode;
            previousSibling.after(previousMetadata.domNode);
            metadataCache.delete(key);
            return;
          }
          metadataCache.set(currentKey, metadataAtIndex);
        } else {
          if (newIndex - oldIndex === -1) {
            this.removeByIndex(newIndex);
            return;
          }
          const correctMetadata = this.metadata[oldIndex];
          this.metadata[newIndex] = correctMetadata;
          this.metadata.splice(oldIndex, 1);
          const { domNode: domNodeToRemove } = metadataAtIndex;
          domNodeToRemove.replaceWith(correctMetadata.domNode);
          if (!skipOnMatch) {
            console.warn("no skip on match on swap", newIndex);
            correctMetadata.render(changes, data);
          }
          this.keys[newIndex] = key;
          this.keys.splice(oldIndex, 1);
          domNodeToRemove.remove();
          metadataCache.set(currentKey, metadataAtIndex);
          return;
        }
      }
      const render = this.render(changes, data);
      const element = (
        /** @type {Element} */
        render.target
      );
      this.metadata[newIndex] = {
        render,
        element,
        key,
        domNode: element
      };
      this.keys[newIndex] = key;
      if (this.batchEndIndex === null || this.batchEndIndex !== newIndex - 1) {
        this.writeBatch();
        this.batchStartIndex = newIndex;
      }
      this.batchEndIndex = newIndex;
      this.queuedElements.push(element);
    }
    removeEntries(startIndex = 0) {
      const { length } = this.metadata;
      for (let index = length - 1; index >= startIndex; index--) {
        this.metadata[index].domNode.remove();
      }
      this.metadata.length = startIndex;
      this.keys.length = startIndex;
    }
    /**
     * @param {number} [index]
     * @param {ItemMetadata} [metadata]
     * @param {any} [key]
     * @return {boolean} changed
     */
    hide(index, metadata, key) {
      if (!metadata) {
        if (index == null) {
          index = this.keys.indexOf(key);
        }
        metadata = this.metadata[index];
        if (!metadata) {
          return false;
        }
      }
      if (metadata.hidden) return false;
      let { comment, element } = metadata;
      if (!comment) {
        comment = createEmptyComment();
        metadata.comment = comment;
      }
      element.replaceWith(comment);
      metadata.domNode = comment;
      metadata.hidden = true;
      return true;
    }
    /**
     * @param {number} [index]
     * @param {ItemMetadata} [metadata]
     * @param {any} [key]
     * @return {boolean} changed
     */
    show(index, metadata, key) {
      if (!metadata) {
        if (index == null) {
          index = this.keys.indexOf(key);
        }
        metadata = this.metadata[index];
        if (!metadata) {
          return false;
        }
      }
      if (!metadata.hidden) return false;
      const { comment, element } = metadata;
      comment.replaceWith(element);
      metadata.domNode = element;
      metadata.hidden = false;
      return true;
    }
  };

  // core/css.js
  var cssStyleSheetsCache = /* @__PURE__ */ new Map();
  function createCSSStyleSheet(content, useCache = true) {
    if (useCache && cssStyleSheetsCache.has(content)) {
      return cssStyleSheetsCache.get(content);
    }
    const sheet = new CSSStyleSheet();
    sheet.replaceSync(content);
    if (useCache) {
      cssStyleSheetsCache.set(content, sheet);
    }
    return sheet;
  }
  var styleElementCache = /* @__PURE__ */ new Map();
  var _inactiveDocument;
  function createHTMLStyleElement(content, useCache = true) {
    let style;
    if (useCache && styleElementCache.has(content)) {
      style = styleElementCache.get(content);
    } else {
      _inactiveDocument ??= document.implementation.createHTMLDocument();
      style = _inactiveDocument.createElement("style");
      style.textContent = content;
      if (useCache) {
        styleElementCache.set(content, style);
      }
    }
    return (
      /** @type {HTMLStyleElement} */
      style.cloneNode(true)
    );
  }
  var _cssStyleSheetConstructable;
  function createCSS(content, useCache = true) {
    if (_cssStyleSheetConstructable == null) {
      try {
        const sheet = createCSSStyleSheet(content, useCache);
        _cssStyleSheetConstructable = true;
        return sheet;
      } catch {
        _cssStyleSheetConstructable = false;
      }
    }
    return _cssStyleSheetConstructable ? createCSSStyleSheet(content, useCache) : createHTMLStyleElement(content, useCache);
  }
  function* generateCSSStyleSheets(styles, useCache = true) {
    for (const style of styles) {
      if (style instanceof HTMLStyleElement) {
        yield createCSSStyleSheet(style.textContent, useCache);
      } else if (style.ownerNode) {
        console.warn("Stylesheet is part of style");
        yield createCSSStyleSheet([...style.cssRules].map((r) => r.cssText).join(""), useCache);
      } else {
        yield style;
      }
    }
  }
  var styleElementFromStyleSheetCache = /* @__PURE__ */ new WeakMap();
  function* generateHTMLStyleElements(styles, useCache = true) {
    for (const style of styles) {
      if (style instanceof HTMLStyleElement) {
        yield style;
      } else if (style.ownerNode instanceof HTMLStyleElement) {
        yield style.ownerNode.cloneNode(true);
      } else if (useCache && styleElementFromStyleSheetCache.has(style)) {
        yield styleElementFromStyleSheetCache.get(style).cloneNode(true);
      } else {
        console.warn("Manually constructing HTMLStyleElement", [...style.cssRules].map((r) => r.cssText).join("\n"));
        const styleElement = document.createElement("style");
        styleElement.textContent = [...style.cssRules].map((r) => r.cssText).join("");
        if (useCache) {
          styleElementFromStyleSheetCache.set(style, styleElement);
        }
        yield styleElement.cloneNode(true);
      }
    }
  }
  function css(array, ...substitutions) {
    if (typeof array === "string") return createCSS(array);
    return createCSS(String.raw({ raw: array }, ...substitutions));
  }
  function addGlobalCss(styles, ...substitutions) {
    let compiled;
    if (typeof styles === "string") {
      compiled = css(styles);
    } else if (Array.isArray(styles)) {
      compiled = css(
        /** @type {TemplateStringsArray} */
        styles,
        ...substitutions
      );
    } else {
      compiled = /** @type {HTMLStyleElement|CSSStyleSheet} */
      styles;
    }
    if (compiled instanceof HTMLStyleElement) {
      document.head.append(compiled);
    } else {
      document.adoptedStyleSheets = [
        ...document.adoptedStyleSheets,
        compiled
      ];
    }
    return compiled;
  }

  // core/dom.js
  function attrValueFromDataValue(value) {
    switch (value) {
      case void 0:
      case null:
      case false:
        return null;
      case true:
        return "";
      default:
        return `${value}`;
    }
  }
  var attrNameFromPropNameCache;
  function attrNameFromPropName(name) {
    attrNameFromPropNameCache ??= /* @__PURE__ */ new Map();
    if (attrNameFromPropNameCache.has(name)) {
      return attrNameFromPropNameCache.get(name);
    }
    const value = name.replace(/[A-Z]/g, (match) => `-${match.toLowerCase()}`);
    attrNameFromPropNameCache.set(name, value);
    return value;
  }
  var _a;
  var CHROME_VERSION = Number.parseFloat((_a = navigator.userAgent.match(/Chrome\/([\d.]+)/)) == null ? void 0 : _a[1]);
  var _a2;
  var FIREFOX_VERSION = Number.parseFloat((_a2 = navigator.userAgent.match(/Firefox\/([\d.]+)/)) == null ? void 0 : _a2[1]);
  var _a3;
  var SAFARI_VERSION = CHROME_VERSION || !navigator.userAgent.includes("AppleWebKit") ? Number.NaN : Number.parseFloat((_a3 = navigator.userAgent.match(/Version\/([\d.]+)/)) == null ? void 0 : _a3[1]);
  function isFocused(element) {
    if (!element) return false;
    if (FIREFOX_VERSION < 113 && element.constructor.formAssociated && element.hasAttribute("disabled")) {
      console.warn("Firefox bug 1818287: Disabled form associated custom element cannot receive focus.");
      return false;
    }
    if (document.activeElement === element) return true;
    if (!element.isConnected) return false;
    if ((element == null ? void 0 : element.getRootNode()) === document) return false;
    return element.matches(":focus");
  }
  function attemptFocus(element, ...options) {
    if (!element) return false;
    try {
      element.focus(...options);
    } catch (e) {
      console.error(e);
      return false;
    }
    return isFocused(element);
  }
  function isRtl(element) {
    return getComputedStyle(element).direction === "rtl";
  }

  // core/jsonMergePatch.js
  function applyMergePatch(target, patch) {
    if (target === patch) return target;
    if (target == null || patch == null || typeof patch !== "object") return patch;
    if (typeof target !== "object") {
      target = {};
    }
    for (const [key, value] of Object.entries(patch)) {
      if (value == null) {
        if (key in target) {
          delete target[key];
        }
      } else {
        target[key] = applyMergePatch(target[key], value);
      }
    }
    return target;
  }
  function buildMergePatch(previous, current, arrayStrategy = "reference") {
    if (previous === current) return null;
    if (current == null || typeof current !== "object") return current;
    if (previous == null || typeof previous !== "object") {
      return structuredClone(current);
    }
    const patch = {};
    if (Array.isArray(current)) {
      if (arrayStrategy === "reference") {
        return current;
      }
      if (arrayStrategy === "clone") {
        return structuredClone(current);
      }
      for (const [index, value] of current.entries()) {
        if (value === null) {
          patch[index] = null;
          continue;
        }
        if (value == null) {
          continue;
        }
        const changes = buildMergePatch(previous[index], value, arrayStrategy);
        if (changes !== null) {
          patch[index] = changes;
        }
      }
      if (current.length !== previous.length) {
        patch.length = current.length;
      }
      return patch;
    }
    const previousKeys = new Set(Object.keys(previous));
    for (const [key, value] of Object.entries(current)) {
      previousKeys.delete(key);
      if (value === null) {
        patch[key] = null;
        continue;
      }
      if (value == null) {
        continue;
      }
      const changes = buildMergePatch(previous[key], value, arrayStrategy);
      if (changes !== null) {
        patch[key] = changes;
      }
    }
    for (const key of previousKeys) {
      patch[key] = null;
    }
    return patch;
  }
  function hasMergePatch(target, patch) {
    if (target === patch) return false;
    if (patch == null || typeof patch !== "object") return true;
    if (target != null && typeof target !== "object") {
      return true;
    }
    for (const [key, value] of Object.entries(patch)) {
      if (value == null) {
        if (key in target) {
          return true;
        }
      } else if (hasMergePatch(target[key], value)) {
        return true;
      }
    }
    return false;
  }

  // core/observe.js
  function emptyFromType(type) {
    switch (type) {
      case "boolean":
        return false;
      case "integer":
      case "float":
        return 0;
      case "map":
        return /* @__PURE__ */ new Map();
      case "set":
        return /* @__PURE__ */ new Set();
      case "array":
        return [];
      case "object":
        return null;
      default:
      case "string":
        return "";
    }
  }
  function buildProxy(proxyTarget, set, deepSet, prefix) {
    proxyTarget ??= {};
    return new Proxy(proxyTarget, {
      get(target, p) {
        const value = target[p];
        if (typeof p !== "symbol") {
          const arg = prefix ? `${prefix}.${p}` : p;
          if (prefix) {
            deepSet.add(arg);
          } else {
            set.add(arg);
          }
          if (typeof value === "object" && value != null) {
            return buildProxy(value, set, deepSet, arg);
          }
        }
        return value;
      },
      has(target, p) {
        const value = Reflect.has(target, p);
        if (typeof p !== "symbol") {
          const arg = prefix ? `${prefix}.p` : p;
          if (prefix) {
            deepSet.add(arg);
          } else {
            set.add(arg);
          }
        }
        return value;
      }
    });
  }
  function defaultParserFromType(type) {
    switch (type) {
      case "boolean":
        return (v) => !!v;
      case "integer":
        return Math.round;
      case "float":
        return (v) => +v;
      case "map":
        return Map;
      case "set":
        return Set;
      case "object":
      case "array":
        return (o) => o;
      default:
      case "string":
        return (v) => `${v}`;
    }
  }
  function observeFunction(fn, ...args) {
    const thisPoked = /* @__PURE__ */ new Set();
    const thisPokedDeep = /* @__PURE__ */ new Set();
    const argWatchers = args.map((arg) => {
      const poked = /* @__PURE__ */ new Set();
      const pokedDeep = /* @__PURE__ */ new Set();
      const proxy = buildProxy(arg, poked, pokedDeep);
      return { poked, pokedDeep, proxy };
    });
    const thisProxy = buildProxy(this ?? {}, thisPoked, thisPokedDeep);
    const defaultValue = fn.apply(thisProxy, argWatchers.map((watcher) => watcher.proxy));
    const reusable = fn.name ? true : !thisPoked.size;
    return {
      props: {
        this: [...thisPoked],
        args: argWatchers.map((watcher) => [...watcher.poked])
      },
      deepPropStrings: {
        this: [...thisPokedDeep],
        args: argWatchers.map((watcher) => [...watcher.pokedDeep])
      },
      deepProps: {
        this: [...thisPokedDeep].map((deepPropString) => deepPropString.split(".")),
        args: argWatchers.map((watcher) => [...watcher.pokedDeep].map((deepPropString) => deepPropString.split(".")))
      },
      defaultValue,
      reusable
    };
  }
  function defaultNullParser() {
    return null;
  }
  function parseObserverOptions(name, typeOrOptions, object) {
    const options = typeof typeOrOptions === "string" ? { type: typeOrOptions } : typeOrOptions;
    let {
      watchers,
      value,
      readonly,
      empty,
      type,
      enumerable,
      reflect,
      attr,
      nullable,
      parser,
      nullParser,
      get,
      is,
      diff,
      props
    } = options;
    watchers ??= [];
    readonly ??= false;
    if (empty === void 0) {
      empty = null;
    }
    value ??= empty;
    if (get && !props) {
      const observeResult = observeFunction(get.bind(object), object, () => value);
      value ??= observeResult.defaultValue;
      const uniqueProps = /* @__PURE__ */ new Set([
        ...observeResult.props.this,
        ...observeResult.props.args[0]
      ]);
      props = uniqueProps;
    }
    if (!type) {
      if (value == null) {
        type = "string";
      } else {
        const parsed = typeof value;
        type = parsed === "number" ? Number.isInteger(value) ? "integer" : "number" : parsed;
      }
    }
    enumerable ??= name[0] !== "_";
    nullable ??= type === "boolean" ? false : empty == null;
    if (!nullable) {
      empty ??= emptyFromType(type);
      value ??= empty;
    }
    reflect ??= enumerable ? type !== "object" : attr ? "write" : false;
    attr ??= reflect ? attrNameFromPropName(name) : null;
    parser ??= defaultParserFromType(type);
    if (!nullParser) {
      if (nullable) {
        nullParser = defaultNullParser;
      } else {
        nullParser = empty === null ? () => emptyFromType(type) : () => empty;
      }
    }
    is ??= type === "object" ? (a, b) => !hasMergePatch(a, b) : type === "array" ? () => false : Object.is;
    if (diff === void 0) {
      diff = type === "object" ? (a, b) => buildMergePatch(a, b, "reference") : null;
    }
    return {
      ...options,
      type,
      is,
      diff,
      attr,
      reflect,
      readonly,
      enumerable,
      value,
      parser,
      nullParser,
      key: name,
      // @ts-ignore Can't cast
      props,
      // @ts-ignore Can't cast
      watchers
    };
  }
  function detectChange(config, oldValue, value) {
    var _a5, _b;
    if (config.get) {
    }
    const newValue = value == null ? config.nullParser.call(this, value) : config.parser.call(this, value);
    let changes = newValue;
    if (oldValue == null) {
      if (newValue == null) {
        return false;
      }
    } else if (newValue != null) {
      if (config.diff) {
        changes = config.diff.call(this, oldValue, newValue);
        if (changes == null) {
          return false;
        }
      } else if (config.is.call(this, oldValue, newValue)) {
        return false;
      }
    }
    if (config.values) {
      config.values.set(this, newValue);
    } else {
      config.values = new WeakMap([[this, newValue]]);
    }
    (_a5 = config.propChangedCallback) == null ? void 0 : _a5.call(this, config.key, oldValue, newValue, changes);
    (_b = config.changedCallback) == null ? void 0 : _b.call(this, oldValue, newValue, changes);
    return true;
  }
  function defineObservableProperty(object, key, options) {
    const config = (
      /** @type {ObserverConfiguration<T1,T2,C,K>} */
      parseObserverOptions(key, options, object)
    );
    function internalGet() {
      var _a5;
      return ((_a5 = config.values) == null ? void 0 : _a5.has(this)) ? config.values.get(this) : config.value;
    }
    function internalSet(value) {
      const oldValue = this[key];
      detectChange.call(this, config, oldValue, value);
    }
    function onInvalidate() {
      var _a5, _b;
      const oldValue = (_a5 = config.computedValues) == null ? void 0 : _a5.get(this);
      const newValue = this[key];
      (_b = config.needsSelfInvalidation) == null ? void 0 : _b.delete(this);
      detectChange.call(this, config, oldValue, newValue);
    }
    if (config.props) {
      for (const prop of config.props) {
        config.watchers.push([prop, onInvalidate]);
      }
    }
    function cachedGet() {
      const newValue = config.get.call(this, this, internalGet.bind(this));
      const computedValues = config.computedValues ??= /* @__PURE__ */ new WeakMap();
      computedValues.set(this, newValue);
      return newValue;
    }
    function cachedSet(value) {
      if (config.needsSelfInvalidation) {
        config.needsSelfInvalidation.add(this);
      } else {
        config.needsSelfInvalidation = new WeakSet([this]);
      }
      const oldValue = this[key];
      config.set.call(this, value, internalSet.bind(this));
      const newValue = this[key];
      if (!config.needsSelfInvalidation.has(this)) return;
      config.needsSelfInvalidation.delete(this);
      detectChange.call(this, config, oldValue, newValue);
    }
    const descriptor = {
      enumerable: config.enumerable,
      configurable: true,
      get: config.get ? cachedGet : internalGet,
      set: config.set ? cachedSet : internalSet
    };
    Object.defineProperty(object, key, descriptor);
    return config;
  }

  // core/uid.js
  var generatedUIDs = /* @__PURE__ */ new Set();
  function generateUID(prefix = "mdw_", n = 4) {
    let id;
    while (generatedUIDs.has(id = Math.random().toString(36).slice(2, n + 2))) ;
    generatedUIDs.add(id);
    return `${prefix}${id}`;
  }

  // core/template.js
  var _inactiveDocument2;
  var _blankFragment;
  var _fragmentRange;
  function generateFragment(fromString) {
    _inactiveDocument2 ??= document.implementation.createHTMLDocument();
    if (!fromString) {
      _blankFragment ??= _inactiveDocument2.createDocumentFragment();
      return (
        /** @type {DocumentFragment} */
        _blankFragment.cloneNode()
      );
    }
    _fragmentRange ??= _inactiveDocument2.createRange();
    return _fragmentRange.createContextualFragment(fromString);
  }
  var inlineFunctions = /* @__PURE__ */ new Map();
  function addInlineFunction(fn) {
    const internalName = `#${generateUID()}`;
    inlineFunctions.set(internalName, { fn });
    return `{${internalName}}`;
  }
  var fragmentCache = /* @__PURE__ */ new Map();
  function html(strings, ...substitutions) {
    let tempSlots;
    const replacements = substitutions.map((sub) => {
      switch (typeof sub) {
        case "string":
          return sub;
        case "function":
          return addInlineFunction(sub);
        case "object": {
          if (sub == null) {
            console.warn(sub, "is null", strings);
            return "";
          }
          const tempId = generateUID();
          tempSlots ??= /* @__PURE__ */ new Map();
          tempSlots.set(tempId, sub);
          return `<div id="${tempId}"></div>`;
        }
        default:
          throw new Error(`Unexpected substitution: ${sub}`);
      }
    });
    const compiledString = String.raw({ raw: strings }, ...replacements);
    if (tempSlots) {
      const fragment2 = generateFragment(compiledString);
      for (const [id, element] of tempSlots) {
        const slot = fragment2.getElementById(id);
        slot.replaceWith(element);
      }
      return fragment2;
    }
    let fragment;
    if (fragmentCache.has(compiledString)) {
      fragment = fragmentCache.get(compiledString);
    } else {
      fragment = generateFragment(compiledString);
      fragmentCache.set(compiledString, fragment);
    }
    return (
      /** @type {DocumentFragment} */
      fragment.cloneNode(true)
    );
  }

  // core/Composition.js
  function writeDOMAttribute({ nodes }, value) {
    const { nodeIndex, attrName } = this;
    const element = (
      /** @type {Element} */
      nodes[nodeIndex]
    );
    switch (value) {
      case void 0:
      case null:
      case false:
        element.removeAttribute(attrName);
        return false;
      case true:
        element.setAttribute(attrName, "");
        return "";
      default:
        element.setAttribute(attrName, value);
        return value;
    }
  }
  function writeDynamicNode({ nodeStates, comments, nodes }, value) {
    const { commentIndex, nodeIndex } = this;
    const nodeState = nodeStates[nodeIndex];
    const hidden = nodeState & 1;
    const show = value != null && value !== false;
    if (!show) {
      if (hidden) return;
      let comment = comments[commentIndex];
      if (!comment) {
        comment = createEmptyComment();
        comments[commentIndex] = comment;
      }
      nodes[nodeIndex].replaceWith(comment);
      nodeStates[nodeIndex] |= 1;
      return;
    }
    const node = nodes[nodeIndex];
    const isDynamicNode = nodeState & 2;
    if (typeof value === "object") {
      console.warn("Dynamic nodes not supported yet");
    } else if (isDynamicNode) {
      const textNode = new Text(value);
      node.replaceWith(textNode);
      nodes[nodeIndex] = textNode;
      nodeStates[nodeIndex] &= ~2;
    } else {
      node.data = value;
    }
    if (hidden) {
      const comment = comments[commentIndex];
      comment.replaceWith(node);
      nodeStates[nodeIndex] &= ~1;
    }
  }
  function writeDOMElementAttachedState({ nodeStates, nodes, comments }, value) {
    const { commentIndex, nodeIndex } = this;
    const hidden = nodeStates[nodeIndex] & 1;
    const show = value != null && value !== false;
    if (show === !hidden) return;
    const element = nodes[nodeIndex];
    let comment = comments[commentIndex];
    if (!comment) {
      comment = createEmptyComment();
      comments[commentIndex] = comment;
    }
    if (show) {
      comment.replaceWith(element);
      nodeStates[nodeIndex] &= ~1;
    } else {
      element.replaceWith(comment);
      nodeStates[nodeIndex] |= 1;
    }
  }
  function writeDOMHideNodeOnInit({ comments, nodeStates, nodes }) {
    const { commentIndex, nodeIndex } = this;
    const comment = createEmptyComment();
    comments[commentIndex] = comment;
    nodeStates[nodeIndex] |= 1;
    nodes[nodeIndex].replaceWith(comment);
  }
  function executeSearch(search, ...args) {
    const [{ caches, searchStates }] = args;
    const { cacheIndex, searchIndex, subSearch, invocation } = search;
    const cachedValue = caches[cacheIndex];
    const searchState = searchStates[searchIndex];
    if (searchState & 1) {
      return {
        value: cachedValue,
        // eslint-disable-next-line no-bitwise
        dirty: (searchState & 2) === 2
      };
    }
    searchStates[searchIndex] |= 1;
    let result;
    if (invocation) {
      if (subSearch) {
        const subResult = executeSearch(subSearch, ...args);
        if (!subResult.dirty && cachedValue !== void 0) {
          searchStates[searchIndex] &= ~2;
          return { value: cachedValue, dirty: false };
        }
        result = search.invocation(subResult.value);
      } else {
        result = search.invocation(...args);
      }
      if (result === void 0 || cachedValue === result) {
        return { value: result, dirty: false };
      }
    }
    caches[cacheIndex] = result;
    searchStates[searchIndex] |= 2;
    return { value: result, dirty: true };
  }
  function searchWithExpression({ options: { context, store, injections } }, changes, data) {
    return this.expression.call(
      context,
      store ?? data,
      injections
    );
  }
  function searchWithProp(state, changes) {
    return changes[this.prop];
  }
  function searchWithDeepProp(state, changes, data) {
    let scope = changes;
    for (const prop of this.deepProp) {
      if (scope === null) return null;
      if (prop in scope === false) return void 0;
      scope = scope[prop];
    }
    return scope;
  }
  var STRING_INTERPOLATION_REGEX = /{([^}]*)}/g;
  function propFromObject(prop, source) {
    if (source) {
      return source[prop];
    }
    return void 0;
  }
  function deepPropFromObject(nameArray, source) {
    if (!source) return void 0;
    let scope = source;
    let prop;
    for (prop of nameArray) {
      if (typeof scope === "object") {
        if (scope === null) return null;
        if (!(prop in scope)) return void 0;
        scope = scope[prop];
      } else {
        return scope[prop];
      }
    }
    return scope;
  }
  function valueFromPropName(prop, source) {
    let value = source;
    for (const child of prop.split(".")) {
      if (!child) return null;
      value = value[child];
      if (value == null) return null;
    }
    if (value === source) return null;
    return value;
  }
  var compositionCache = /* @__PURE__ */ new Map();
  var Composition = class _Composition {
    static EVENT_PREFIX_REGEX = /^([*1~]+)?(.*)$/;
    _interpolationState = {
      nodeIndex: -1,
      searchIndex: 0,
      cacheIndex: 0,
      commentIndex: 0,
      /** @type {this['nodesToBind'][0]} */
      nodeEntry: null
    };
    // eslint-disable-next-line symbol-description
    static shadowRootTag = Symbol();
    /** @type {{tag:string, textNodes: number[]}[]} */
    nodesToBind = [];
    /** @type {string[]} */
    props = [];
    /** @type {RenderGraphSearch[]} */
    searches = [];
    /** @type {any[]} */
    initCache = [];
    /**
     * Index of searches by query (dotted notation for deep props)
     * @type {Map<Function|string, RenderGraphSearch>}
     */
    searchByQuery;
    /**
     * Index of searches by query (dotted notation for deep props)
     * @type {Map<string, RenderGraphAction[]>}
     */
    actionsByPropsUsed;
    /** @type {RenderGraphAction[]} */
    postInitActions = [];
    /** @type {Set<string>} */
    tagsWithBindings;
    /**
     * Array of element tags
     * @type {string[]}
     */
    tags = [];
    /**
     * Data of arrays used in templates
     * Usage of a [mdw-for] will create an ArrayLike expectation based on key
     * Only store metadata, not actual data. Currently only needs length.
     * TBD if more is needed later
     * Referenced by property key (string)
     * @type {CompositionAdapter<T>}
     */
    adapter;
    /**
     * Collection of events to bind.
     * Indexed by ID
     * @type {Map<string|symbol, CompositionEventListener<any>[]>}
     */
    events;
    /**
     * Snapshot of composition at initial state.
     * This fragment can be cloned for first rendering, instead of calling
     * of using `render()` to construct the initial DOM tree.
     * @type {DocumentFragment}
     */
    cloneable;
    /** @type {(HTMLStyleElement|CSSStyleSheet)[]} */
    styles = [];
    /** @type {CSSStyleSheet[]} */
    adoptedStyleSheets = [];
    /** @type {DocumentFragment} */
    stylesFragment;
    /**
     * List of IDs used by template elements
     * May be needed to be removed when adding to non-DocumentFragment
     * @type {string[]}
     */
    allIds = [];
    /**
     * Collection of IDs used for referencing elements
     * Not meant for live DOM. Removed before attaching to document
     */
    /** @type {Set<string>} */
    temporaryIds;
    /** Flag set when template and styles have been interpolated */
    interpolated = false;
    /**
     * @param {(CompositionPart<T>)[]} parts
     */
    constructor(...parts) {
      this.template = generateFragment();
      this.append(...parts);
    }
    *[Symbol.iterator]() {
      for (const part of this.styles) {
        yield part;
      }
      yield this.template;
    }
    /**
     * @template T
     * @param  {ConstructorParameters<typeof Composition<T>>} parts
     * @return {Composition<T>}
     */
    static compose(...parts) {
      for (const [cache, comp] of compositionCache) {
        if (cache.length !== parts.length) continue;
        if (parts.every((part, index) => part === cache[index])) {
          return comp;
        }
      }
      const composition = new _Composition(...parts);
      compositionCache.set(parts, composition);
      return composition;
    }
    /**
     * @param {CompositionPart<T>[]} parts
     */
    append(...parts) {
      for (const part of parts) {
        if (typeof part === "string") {
          this.append(generateFragment(part.trim()));
        } else if (part instanceof _Composition) {
          this.append(...part);
        } else if (part instanceof DocumentFragment) {
          this.template.append(part);
        } else if (part instanceof CSSStyleSheet || part instanceof HTMLStyleElement) {
          this.styles.push(part);
        }
      }
      return this;
    }
    /** @param {CompositionEventListener<T>} listener */
    addCompositionEventListener(listener) {
      const key = listener.tag ?? "";
      const events = this.events ??= /* @__PURE__ */ new Map();
      if (events.has(key)) {
        events.get(key).push(listener);
      } else {
        events.set(key, [listener]);
      }
      return this;
    }
    /**
     * @param {string|symbol} tag
     * @param {EventTarget} target
     * @param {any} [context]
     * @return {void}
     */
    #bindCompositionEventListeners(tag, target, context) {
      var _a5;
      if (!((_a5 = this.events) == null ? void 0 : _a5.has(tag))) return;
      for (const event of this.events.get(tag)) {
        let listener;
        if (event.handleEvent) {
          listener = event.handleEvent;
        } else if (event.deepProp.length) {
          listener = deepPropFromObject(event.deepProp, this.interpolateOptions.defaults);
        } else {
          listener = propFromObject(event.prop, this.interpolateOptions.defaults);
        }
        target.addEventListener(event.type, context ? listener.bind(context) : listener, event);
      }
    }
    /**
     * TODO: Add types and clean up closure leak
     * Updates component nodes based on data.
     * Expects data in JSON Merge Patch format
     * @see https://www.rfc-editor.org/rfc/rfc7386
     * @template {Object} T
     * @param {Partial<T>} changes what specifically
     * @param {T} [data]
     * @param {RenderOptions<T>} [options]
     * @return {RenderDraw<T>} anchor
     */
    render(changes, data, options = {}) {
      if (!this.interpolated) {
        this.interpolate({
          defaults: data ?? changes,
          ...options
        });
      }
      const instanceFragment = (
        /** @type {DocumentFragment} */
        this.cloneable.cloneNode(true)
      );
      const shadowRoot = options.shadowRoot;
      const target = shadowRoot ?? options.target ?? instanceFragment.firstElementChild;
      const initState = {
        lastChildNode: null,
        lastChildNodeIndex: 0,
        lastElement: null,
        nodeStates: new Uint8Array(this._interpolationState.nodeIndex + 1),
        searchStates: new Uint8Array(this._interpolationState.searchIndex),
        comments: [],
        nodes: [],
        caches: this.initCache.slice(),
        refs: [],
        options
      };
      const { nodes, refs, searchStates, caches } = initState;
      for (const { tag, textNodes } of this.nodesToBind) {
        let textNode;
        if (tag === "") {
          if (!textNodes.length) {
            console.warn("why was root tagged?");
            continue;
          }
          console.warn("found empty tag??");
          refs.push(null);
          nodes.push(null);
          textNode = /** @type {Text} */
          instanceFragment.firstChild;
        } else {
          const element = instanceFragment.getElementById(tag);
          refs.push(element);
          nodes.push(element);
          this.#bindCompositionEventListeners(tag, element, options.context);
          if (!textNodes.length) continue;
          textNode = /** @type {Text} */
          element.firstChild;
        }
        let currentIndex = 0;
        for (const index of textNodes) {
          while (index !== currentIndex) {
            textNode = /** @type {Text} */
            textNode.nextSibling;
            currentIndex++;
          }
          nodes.push(textNode);
        }
      }
      this.#bindCompositionEventListeners("", options.context);
      this.#bindCompositionEventListeners(_Composition.shadowRootTag, options.context.shadowRoot, options.context);
      for (const action of this.postInitActions) {
        action.invocation(initState);
      }
      const draw = (changes2, data2) => {
        var _a5;
        let ranSearch = false;
        for (const prop of this.props) {
          if (!((_a5 = this.actionsByPropsUsed) == null ? void 0 : _a5.has(prop))) continue;
          if (!(prop in changes2)) continue;
          const actions = this.actionsByPropsUsed.get(prop);
          for (const action of actions) {
            ranSearch = true;
            const { dirty, value } = executeSearch(action.search, initState, changes2, data2);
            if (dirty) {
              action.invocation(initState, value, changes2, data2);
            }
          }
        }
        if (!ranSearch) return;
        searchStates.fill(0);
      };
      if (shadowRoot) {
        options.context ??= shadowRoot.host;
        if ("adoptedStyleSheets" in shadowRoot) {
          if (this.adoptedStyleSheets.length) {
            shadowRoot.adoptedStyleSheets = [
              ...shadowRoot.adoptedStyleSheets,
              ...this.adoptedStyleSheets
            ];
          }
        } else if (this.stylesFragment.hasChildNodes()) {
          instanceFragment.prepend(this.stylesFragment.cloneNode(true));
        }
      } else {
        options.context ??= target;
      }
      if (changes !== this.interpolateOptions.defaults) {
        draw(changes, data);
      }
      if (shadowRoot) {
        shadowRoot.append(instanceFragment);
        customElements.upgrade(shadowRoot);
      }
      draw.target = target;
      draw.byProp = (prop, value, data2) => {
        var _a5, _b;
        if (!((_a5 = this.actionsByPropsUsed) == null ? void 0 : _a5.has(prop))) return;
        let ranSearch = false;
        if ((_b = this.searchByQuery) == null ? void 0 : _b.has(prop)) {
          ranSearch = true;
          const search = this.searchByQuery.get(prop);
          const cachedValue = caches[search.cacheIndex];
          if (cachedValue === value) {
            return;
          }
          caches[search.cacheIndex] = value;
          searchStates[search.searchIndex] = 3;
        }
        let changes2;
        const actions = this.actionsByPropsUsed.get(prop);
        for (const action of actions) {
          if (action.search.query === prop) {
            action.invocation(initState, value);
          } else {
            changes2 ??= { [prop]: value };
            data2 ??= changes2;
            ranSearch = true;
            const result = executeSearch(action.search, initState, changes2, data2);
            if (result.dirty) {
              action.invocation(initState, result.value, changes2, data2);
            }
          }
        }
        if (!ranSearch) return;
        searchStates.fill(0);
      };
      draw.state = initState;
      return draw;
    }
    /**
     * @param {Attr|Text} node
     * @param {Element|null} [element]
     * @param {InterpolateOptions} [options]
     * @param {string} [parsedValue]
     * @return {true|undefined} remove node
     */
    #interpolateNode(node, element, options, parsedValue) {
      var _a5, _b;
      const { nodeValue, nodeName, nodeType } = node;
      let attr;
      let text;
      if (nodeType === Node.ATTRIBUTE_NODE) {
        attr = /** @type {Attr} */
        node;
      } else {
        text = /** @type {Text} */
        node;
      }
      if (parsedValue == null) {
        if (!nodeValue) return;
        const trimmed = nodeValue.trim();
        if (!trimmed) return;
        if (attr || (element == null ? void 0 : element.tagName) === "STYLE") {
          if (trimmed[0] !== "{") return;
          const { length } = trimmed;
          if (trimmed[length - 1] !== "}") return;
          parsedValue = trimmed.slice(1, -1);
        } else {
          const segments = trimmed.split(STRING_INTERPOLATION_REGEX);
          if (segments.length < 3) return;
          if (segments.length === 3 && !segments[0] && !segments[2]) {
            parsedValue = segments[1];
          } else {
            for (const [index, segment] of segments.entries()) {
              if (index % 2) {
                const newNode = createEmptyTextNode();
                text.before(newNode);
                this.#interpolateNode(newNode, element, options, segment);
              } else if (segment) {
                text.before(segment);
              }
            }
            return true;
          }
        }
      }
      const query = parsedValue;
      const negate = parsedValue[0] === "!";
      let doubleNegate = false;
      if (negate) {
        parsedValue = parsedValue.slice(1);
        doubleNegate = parsedValue[0] === "!";
        if (doubleNegate) {
          parsedValue = parsedValue.slice(1);
        }
      }
      let isEvent;
      let textNodeIndex;
      if (text) {
        if (element !== text.parentElement) {
          console.warn("mismatch?");
          element = text.parentElement;
        }
        textNodeIndex = 0;
        let prev = text;
        while (prev = prev.previousSibling) {
          textNodeIndex++;
        }
      } else {
        if (element !== attr.ownerElement) {
          console.warn("mismatch?");
          element = attr.ownerElement;
        }
        if (nodeName.startsWith("on")) {
          const hyphenIndex = nodeName.indexOf("-");
          if (hyphenIndex === -1) return;
          isEvent = hyphenIndex === 2;
        }
      }
      if (isEvent) {
        element.removeAttribute(nodeName);
        const tag2 = this.#tagElement(element);
        const eventType = nodeName.slice(3);
        const [, flags, type] = eventType.match(/^([*1~]+)?(.*)$/);
        let handleEvent;
        let prop;
        let deepProp = [];
        if (parsedValue.startsWith("#")) {
          handleEvent = inlineFunctions.get(parsedValue).fn;
        } else {
          const parsedProps = parsedValue.split(".");
          if (parsedProps.length === 1) {
            prop = parsedValue;
            deepProp = [];
          } else {
            prop = parsedProps[0];
            deepProp = parsedProps;
          }
        }
        this.addCompositionEventListener({
          tag: tag2,
          type,
          handleEvent,
          prop,
          deepProp,
          once: flags == null ? void 0 : flags.includes("1"),
          passive: flags == null ? void 0 : flags.includes("~"),
          capture: flags == null ? void 0 : flags.includes("*")
        });
        return;
      }
      let search;
      if ((_a5 = this.searchByQuery) == null ? void 0 : _a5.has(query)) {
        search = this.searchByQuery.get(query);
      } else {
        const subquery = parsedValue;
        const isSubquery = subquery !== query;
        let subSearch;
        if (isSubquery && ((_b = this.searchByQuery) == null ? void 0 : _b.has(subquery))) {
          subSearch = this.searchByQuery.get(subquery);
        } else {
          let expression;
          let propsUsed;
          let deepPropsUsed;
          let defaultValue2;
          let prop;
          let deepProp;
          let invocation;
          let inlineFunctionOptions;
          if (parsedValue.startsWith("#")) {
            inlineFunctionOptions = inlineFunctions.get(parsedValue);
            if (!inlineFunctionOptions) {
              console.warn(`Invalid interpolation value: ${parsedValue}`);
              return;
            }
            expression = inlineFunctionOptions.fn;
            invocation = searchWithExpression;
            if (inlineFunctionOptions.props) {
              propsUsed = inlineFunctionOptions.props;
              deepPropsUsed = inlineFunctionOptions.deepProps;
              defaultValue2 = inlineFunctionOptions.defaultValue ?? null;
            } else {
              defaultValue2 = inlineFunctionOptions.fn;
            }
          } else {
            defaultValue2 = null;
            if (options == null ? void 0 : options.defaults) {
              defaultValue2 = deepPropFromObject(parsedValue.split("."), options.defaults) ?? null;
            }
            if (defaultValue2 == null && (options == null ? void 0 : options.injections)) {
              defaultValue2 = valueFromPropName(parsedValue, options.injections);
            }
          }
          if (!propsUsed) {
            if (typeof defaultValue2 === "function") {
              const observeResult = observeFunction.call(this, defaultValue2, options == null ? void 0 : options.defaults, options == null ? void 0 : options.injections);
              const uniqueProps = /* @__PURE__ */ new Set([
                ...observeResult.props.this,
                ...observeResult.props.args[0],
                ...observeResult.props.args[1]
              ]);
              const uniqueDeepProps = /* @__PURE__ */ new Set([
                ...observeResult.deepPropStrings.this,
                ...observeResult.deepPropStrings.args[0]
              ]);
              expression = defaultValue2;
              defaultValue2 = observeResult.defaultValue;
              propsUsed = [...uniqueProps];
              deepPropsUsed = [...uniqueDeepProps].map((deepPropString) => deepPropString.split("."));
              invocation = searchWithExpression;
            } else {
              const parsedProps = parsedValue.split(".");
              if (parsedProps.length === 1) {
                prop = parsedValue;
                propsUsed = [prop];
                invocation = searchWithProp;
              } else {
                propsUsed = [parsedProps[0]];
                deepProp = parsedProps;
                deepPropsUsed = [parsedProps];
                invocation = searchWithDeepProp;
              }
            }
          }
          if (inlineFunctionOptions) {
            inlineFunctionOptions.defaultValue = defaultValue2;
            inlineFunctionOptions.props = propsUsed;
            inlineFunctionOptions.deepProps = deepPropsUsed;
          }
          subSearch = {
            cacheIndex: this._interpolationState.cacheIndex++,
            searchIndex: this._interpolationState.searchIndex++,
            query: subquery,
            defaultValue: defaultValue2,
            subSearch: null,
            prop,
            propsUsed,
            deepProp,
            deepPropsUsed,
            invocation,
            expression
          };
          this.addSearch(subSearch);
        }
        if (isSubquery) {
          search = {
            cacheIndex: this._interpolationState.cacheIndex++,
            searchIndex: this._interpolationState.searchIndex++,
            query,
            subSearch,
            negate,
            doubleNegate,
            prop: subSearch.prop,
            deepProp: subSearch.deepProp,
            propsUsed: subSearch.propsUsed,
            deepPropsUsed: subSearch.deepPropsUsed,
            defaultValue: doubleNegate ? !!subSearch.defaultValue : negate ? !subSearch.defaultValue : subSearch.defaultValue,
            invocation(value) {
              if (this.doubleNegate) return !!value;
              if (this.negate) return !value;
              console.warn("Unknown query mutation", this.query);
              return value;
            }
          };
          this.addSearch(search);
        } else {
          search = subSearch;
        }
      }
      let tag;
      let subnode = null;
      let defaultValue = search.defaultValue;
      if (text) {
        subnode = textNodeIndex;
      } else if (nodeName === "mdw-if") {
        tag = this.#tagElement(element);
        element.removeAttribute(nodeName);
        defaultValue = defaultValue != null && defaultValue !== false;
      } else {
        subnode = nodeName;
        if (nodeName === "id" || defaultValue == null || defaultValue === false) {
          element.removeAttribute(nodeName);
        } else {
          element.setAttribute(nodeName, defaultValue === true ? "" : defaultValue);
        }
      }
      tag ??= this.#tagElement(element);
      let nodeEntry = this._interpolationState.nodeEntry;
      if (!nodeEntry || nodeEntry.tag !== tag) {
        nodeEntry = {
          tag,
          textNodes: []
        };
        this._interpolationState.nodeEntry = nodeEntry;
        this.nodesToBind.push(nodeEntry);
        this._interpolationState.nodeIndex++;
      }
      let action;
      if (text) {
        nodeEntry.textNodes.push(textNodeIndex);
        this._interpolationState.nodeIndex++;
        action = {
          nodeIndex: this._interpolationState.nodeIndex,
          commentIndex: this._interpolationState.commentIndex++,
          invocation: writeDynamicNode,
          defaultValue,
          search
        };
        switch (typeof defaultValue) {
          case "string":
            text.data = defaultValue;
            break;
          case "number":
            text.data = `${defaultValue}`;
            break;
          default:
            text.data = "";
            break;
        }
      } else if (subnode) {
        action = {
          nodeIndex: this._interpolationState.nodeIndex,
          attrName: (
            /** @type {string} */
            subnode
          ),
          defaultValue,
          invocation: writeDOMAttribute,
          search
        };
      } else {
        action = {
          nodeIndex: this._interpolationState.nodeIndex,
          commentIndex: this._interpolationState.commentIndex++,
          defaultValue,
          invocation: writeDOMElementAttachedState,
          search
        };
        if (!defaultValue) {
          this.postInitActions.push({
            ...action,
            invocation: writeDOMHideNodeOnInit
          });
        }
      }
      this.addAction(action);
      const tagsWithBindings = this.tagsWithBindings ??= /* @__PURE__ */ new Set();
      tagsWithBindings.add(tag);
    }
    /**
     * @param {Element} element
     * @return {string}
     */
    #tagElement(element) {
      if (!element) return "";
      let id = element.id;
      if (id) {
        if (!this.allIds.includes(id)) {
          this.allIds.push(id);
        }
      } else {
        id = generateUID();
        const temporaryIds = this.temporaryIds ??= /* @__PURE__ */ new Set();
        temporaryIds.add(id);
        this.allIds.push(id);
        element.id = id;
      }
      return id;
    }
    /**
     * TODO: Subtemplating lacks optimization, though functional.
     * - Would benefit from custom type handler for arrays
     * to avoid multi-iteration change-detection.
     * - Could benefit from debounced/throttled render
     * - Consider remap of {item.prop} as {array[index].prop}
     * @param {Element} element
     * @param {InterpolateOptions} options
     * @return {?Composition<?>}
     */
    #interpolateIterable(element, options) {
      const forAttr = element.getAttribute("mdw-for");
      const trimmed = forAttr == null ? void 0 : forAttr.trim();
      if (!trimmed) {
        console.warn("Malformed mdw-for found at", element);
        return null;
      }
      if (trimmed[0] !== "{") {
        console.warn("Malformed mdw-for found at", element);
        return null;
      }
      const { length } = trimmed;
      if (trimmed[length - 1] !== "}") {
        console.warn("Malformed mdw-for found at", element);
        return null;
      }
      const parsedValue = trimmed.slice(1, -1);
      const [valueName, iterableName] = parsedValue.split(/\s+of\s+/);
      element.removeAttribute("mdw-for");
      const elementAnchor = element.ownerDocument.createElement("template");
      element.replaceWith(elementAnchor);
      const tag = this.#tagElement(elementAnchor);
      let nodeEntry = this._interpolationState.nodeEntry;
      if (!nodeEntry || nodeEntry.tag !== tag) {
        nodeEntry = {
          tag,
          textNodes: []
        };
        this._interpolationState.nodeEntry = nodeEntry;
        this.nodesToBind.push(nodeEntry);
        this._interpolationState.nodeIndex++;
      }
      const newComposition = new _Composition();
      newComposition.template.append(element);
      const injections = {
        ...options.injections,
        [valueName]: null,
        index: null
      };
      const propsUsed = [iterableName];
      const search = {
        cacheIndex: this._interpolationState.cacheIndex++,
        searchIndex: this._interpolationState.searchIndex++,
        query: null,
        prop: null,
        deepProp: null,
        propsUsed,
        deepPropsUsed: [[iterableName]],
        defaultValue: {},
        invocation: null
      };
      const action = {
        defaultValue: null,
        nodeIndex: this._interpolationState.nodeIndex,
        search,
        commentIndex: this._interpolationState.commentIndex++,
        injections,
        invocation(state, value, changes, data) {
          if (!newComposition.adapter) {
            const instanceAnchorElement = state.nodes[this.nodeIndex];
            const anchorNode = createEmptyComment();
            state.comments[this.commentIndex] = anchorNode;
            instanceAnchorElement.replaceWith(anchorNode);
            newComposition.adapter = new CompositionAdapter({
              anchorNode,
              composition: newComposition,
              renderOptions: {
                target: null,
                context: state.options.context,
                store: state.options.store,
                injections: this.injections
              }
            });
          }
          const { adapter } = newComposition;
          const iterable = (data ?? state.options.store)[iterableName];
          if (!iterable || iterable.length === 0) {
            adapter.removeEntries();
            return;
          }
          const changeList = changes[iterableName];
          const innerChanges = { ...changes };
          const needTargetAll = newComposition.props.some((prop) => prop !== iterableName && prop in changes);
          adapter.startBatch();
          let isArray;
          if (!needTargetAll && !(isArray = Array.isArray(changeList))) {
            const iterator = isArray ? changeList.entries() : Object.entries(changeList);
            for (const [key, change] of iterator) {
              if (key === "length") continue;
              if (change === null) {
                continue;
              }
              const index = +key;
              const resource = iterable[index];
              innerChanges[valueName] = change;
              this.injections[valueName] = resource;
              this.injections.index = index;
              adapter.renderData(index, innerChanges, data, resource, change);
            }
          } else {
            if (!changeList) {
              delete innerChanges[valueName];
            }
            for (const [index, resource] of iterable.entries()) {
              let change;
              if (changeList) {
                if (!needTargetAll && !(index in changeList)) {
                  console.warn("huh?");
                  continue;
                }
                change = changeList[index];
                if (change === null) {
                  continue;
                }
                innerChanges[valueName] = change;
              }
              this.injections[valueName] = resource;
              this.injections.index = index;
              adapter.renderData(index, innerChanges, data, resource, change);
            }
          }
          adapter.stopBatch();
          adapter.removeEntries(iterable.length);
        }
      };
      newComposition.interpolate({
        defaults: options.defaults,
        injections
      });
      propsUsed.push(...newComposition.props);
      this.addSearch(search);
      this.addAction(action);
      const tagsWithBindings = this.tagsWithBindings ??= /* @__PURE__ */ new Set();
      tagsWithBindings.add(tag);
      return newComposition;
    }
    /**
     * @param {InterpolateOptions} [options]
     */
    interpolate(options) {
      var _a5;
      this.interpolateOptions = options;
      this.cloneable = /** @type {DocumentFragment} */
      this.template.cloneNode(true);
      const TREE_WALKER_FILTER = 5;
      const treeWalker = document.createTreeWalker(this.cloneable, TREE_WALKER_FILTER);
      let node = treeWalker.nextNode();
      while (node) {
        let element = null;
        switch (node.nodeType) {
          case Node.ELEMENT_NODE:
            element = /** @type {Element} */
            node;
            if (element.tagName === "TEMPLATE") {
              while (element.contains(node = treeWalker.nextNode())) ;
              continue;
            }
            if (element.tagName === "SCRIPT") {
              console.warn("<script> element found.");
              while (element.contains(node = treeWalker.nextNode())) ;
              continue;
            }
            if (element.hasAttribute("mdw-for")) {
              while (element.contains(node = treeWalker.nextNode())) ;
              this.#interpolateIterable(element, options);
              continue;
            } else {
              const idAttr = element.attributes.id;
              if (idAttr) {
                this.#interpolateNode(idAttr, element, options);
                this.#tagElement(element);
              }
              for (const attr of [...element.attributes].reverse()) {
                if (attr.nodeName === "id") continue;
                this.#interpolateNode(attr, element, options);
              }
            }
            break;
          case Node.TEXT_NODE:
            element = node.parentElement;
            if (this.#interpolateNode(
              /** @type {Text} */
              node,
              element,
              options
            )) {
              const nextNode = treeWalker.nextNode();
              node.remove();
              node = nextNode;
              continue;
            }
            break;
          default:
            throw new Error(`Unexpected node type: ${node.nodeType}`);
        }
        node = treeWalker.nextNode();
      }
      if ("adoptedStyleSheets" in document) {
        this.adoptedStyleSheets = [
          ...generateCSSStyleSheets(this.styles)
        ];
      } else {
        this.stylesFragment = generateFragment();
        this.stylesFragment.append(
          ...generateHTMLStyleElements(this.styles)
        );
      }
      this.props = this.actionsByPropsUsed ? [...this.actionsByPropsUsed.keys()] : [];
      for (const id of this.allIds) {
        if (!((_a5 = this.tagsWithBindings) == null ? void 0 : _a5.has(id))) {
          this.nodesToBind.push({
            tag: id,
            textNodes: []
          });
        }
      }
      this.tags = this.nodesToBind.map((n) => n.tag);
      this.interpolated = true;
    }
    /**
     * @param {RenderGraphSearch} search
     * @return {RenderGraphSearch}
     */
    addSearch(search) {
      this.searches.push(search);
      if (search.query) {
        const searchByQuery = this.searchByQuery ??= /* @__PURE__ */ new Map();
        searchByQuery.set(search.query, search);
        this.initCache[search.cacheIndex] = search.defaultValue;
      }
      return search;
    }
    /**
     * @param {RenderGraphAction} action
     * @return {RenderGraphAction}
     */
    addAction(action) {
      const actionsByPropsUsed = this.actionsByPropsUsed ??= /* @__PURE__ */ new Map();
      for (const prop of action.search.propsUsed) {
        if (actionsByPropsUsed.has(prop)) {
          actionsByPropsUsed.get(prop).push(action);
        } else {
          actionsByPropsUsed.set(prop, [action]);
        }
      }
      return action;
    }
  };

  // core/CustomElement.js
  function cloneAttributeCallback(name, target) {
    return (oldValue, newValue, element) => {
      if (newValue == null) {
        element.refs[target].removeAttribute(name);
      } else {
        element.refs[target].setAttribute(name, newValue);
      }
    };
  }
  var CustomElement = class _CustomElement extends HTMLElement {
    /** @type {string} */
    static elementName;
    /** @return {Iterable<string>} */
    static get observedAttributes() {
      return this.attrList.keys();
    }
    /** @type {import('./Composition.js').Compositor<?>} */
    compose() {
      return this.#composition ??= new Composition();
    }
    /** @type {Composition<?>} */
    static _composition = null;
    /** @type {Map<string, import('./observe.js').ObserverConfiguration<?,?,?>>} */
    static _props = /* @__PURE__ */ new Map();
    /** @type {Map<string, import('./observe.js').ObserverConfiguration<?,?,?>>} */
    static _attrs = /* @__PURE__ */ new Map();
    /** @type {Map<string, Array<(this: any, ...args: any[]) => any>>} */
    static _propChangedCallbacks = /* @__PURE__ */ new Map();
    /** @type {Map<string, Array<(this: any, ...args: any[]) => any>>} */
    static _attributeChangedCallbacks = /* @__PURE__ */ new Map();
    /** @type {Array<(callback: CallbackArguments) => any>} */
    static _onComposeCallbacks = [];
    /** @type {Array<(callback: CallbackArguments) => any>} */
    static _onConnectedCallbacks = [];
    /** @type {Array<(callback: CallbackArguments) => any>} */
    static _onDisconnectedCallbacks = [];
    /** @type {Array<(callback: CallbackArguments) => any>} */
    static _onConstructedCallbacks = [];
    static interpolatesTemplate = true;
    static supportsElementInternals = "attachInternals" in HTMLElement.prototype;
    static supportsElementInternalsRole = _CustomElement.supportsElementInternals && "role" in ElementInternals.prototype;
    /** @type {boolean} */
    static templatable = null;
    static defined = false;
    static autoRegistration = true;
    /** @type {Map<string, typeof CustomElement>} */
    static registrations = /* @__PURE__ */ new Map();
    /**
     * Expressions are idempotent functions that are selectively called whenever
     * a render is requested.
     * Expressions are constructed exactly as methods though differ in expected
     * arguments. The first argument should be destructured to ensure each used
     * property is accessed at least once in order to inspect used properties.
     *
     * The Composition API will inspect this function with a proxy for `this` to
     * catalog what observables are used by the expression. This allows the
     * Composition API to build a cache as well as selective invoke the expression
     * only when needed.
     *
     * When used with in element templates, the element itself will be passed as
     * its first argument.
     * ````js
     *    Button
     *      .prop('filled', 'boolean')
     *      .prop('outlined', 'boolean')
     *      .expresssions({
     *        _isFilledOrOutlined({filled, outlined}) {
     *          return (filled || outlined)
     *        },
     *      })
     *      .html`<div custom={_isFilledOrOutlined}></div>`;
     * ````
     *
     * When used with external data source, that data source
     * will be passed to the expression with all properties being `null` at first
     * inspection.
     * ````js
     *    const externalData = {first: 'John', last: 'Doe'};
     *    ContactCard
     *      .expresssions({
     *        _fullName({first, last}) {
     *          return [first, last].filter(Boolean).join(' ');
     *        },
     *      })
     *   myButton.render(externalData);
     * ````
     *
     * Expressions may be support argumentless calls by using default
     * parameters with `this`.
     * ````js
     *    Button
     *      .expresssions({
     *        isFilledOrOutlined({filled, outlined} = this) {
     *          return (filled || outlined)
     *        },
     *      });
     *    myButton.isFilledorOutlined();
     * ````
     * @type {{
     * <
     *  CLASS extends typeof CustomElement,
     *  ARGS extends ConstructorParameters<CLASS>,
     *  INSTANCE extends InstanceType<CLASS>,
     *  PROPS extends {
     *    [K in keyof any]: K extends `_${any}` ? ((data: INSTANCE, state?: Record<string, any>) => string|boolean|null)
     *      : ((data?: INSTANCE, state?: Record<string, any>) => string|boolean|null)
     *  } & ThisType<INSTANCE>
     *  >(this: CLASS, expressions: PROPS & ThisType<INSTANCE & PROPS>):
     *  CLASS & Class<{
     *    [K in keyof PROPS]: K extends `_${any}` ? never : () =>  ReturnType<PROPS[K]> }
     *    ,ARGS>
     * }}
     */
    static expressions = (
      /** @type {any} */
      this.set
    );
    static methods = this.set;
    /**
     * @type {{
     * <
     * CLASS extends typeof CustomElement,
     * ARGS extends ConstructorParameters<CLASS>,
     * INSTANCE extends InstanceType<CLASS>,
     * PROPS extends Partial<INSTANCE>>
     * (this: CLASS, source: PROPS & ThisType<PROPS & INSTANCE>, options?: Partial<PropertyDescriptor>)
     * : CLASS & Class<PROPS,ARGS>
     * }}
     */
    static overrides = (
      /** @type {any} */
      this.set
    );
    /**
     * @type {{
     * <
     *  CLASS extends typeof CustomElement,
     *  ARGS extends ConstructorParameters<CLASS>,
     *  INSTANCE extends InstanceType<CLASS>,
     *  KEY extends string,
     *  OPTIONS extends ObserverPropertyType
     *    | ObserverOptions<ObserverPropertyType, unknown, INSTANCE>
     *    | ((this:INSTANCE, data:Partial<INSTANCE>, fn?: () => any) => any),
     *  VALUE extends Record<KEY, OPTIONS extends (...args2:any[]) => infer R ? R
     *      : OPTIONS extends ObserverPropertyType ? import('./observe.js').ParsedObserverPropertyType<OPTIONS>
     *      : OPTIONS extends {type: 'object'} & ObserverOptions<any, infer R> ? (unknown extends R ? object : R)
     *      : OPTIONS extends {type: ObserverPropertyType} ? import('./observe.js').ParsedObserverPropertyType<OPTIONS['type']>
     *      : OPTIONS extends ObserverOptions<any, infer R> ? (unknown extends R ? string : R)
     *      : never
     *      >
     *  > (this: CLASS, name: KEY, options: OPTIONS)
     *    : CLASS & Class<VALUE,ARGS>;
     * }}
     */
    static props = (
      /** @type {any} */
      this.observe
    );
    static idl = this.prop;
    /**
     * @this T
     * @template {typeof CustomElement} T
     * @template {keyof T} K
     * @param {K} collection
     * @param {Function} callback
     */
    static _addCallback(collection, callback) {
      if (!this.hasOwnProperty(collection)) {
        this[collection] = [...this[collection], callback];
        return;
      }
      this[collection].push(callback);
    }
    /**
     * Append parts to composition
     * @type {{
     * <
     *  T extends typeof CustomElement,
     *  >
     *  (this: T, ...parts: ConstructorParameters<typeof Composition<InstanceType<T>>>): T;
     * }}
     */
    static append(...parts) {
      this._onComposeCallbacks.push(({ composition }) => {
        composition.append(...parts);
      });
      this._addCallback(
        "_onComposeCallbacks",
        /** @type {(opts: CallbackArguments) => unknown} */
        ((opts) => {
          const { composition } = opts;
          composition.append(...parts);
        })
      );
      return this;
    }
    /**
     * After composition, invokes callback.
     * May be called multiple times.
     * @type {{
     * <
     *  T1 extends (typeof CustomElement),
     *  T2 extends InstanceType<T1>,
     *  T3 extends CompositionCallback<T2, T2>['composed'],
     *  >
     *  (this: T1, callback: T3): T1
     * }}
     */
    static recompose(callback) {
      this._addCallback("_onComposeCallbacks", callback);
      return this;
    }
    /**
     * Appends styles to composition
     * @type {{
     * <
     *   T1 extends (typeof CustomElement),
     *   T2 extends TemplateStringsArray|HTMLStyleElement|CSSStyleSheet|string>(
     *   this: T1,
     *   array: T2,
     *   ...rest: T2 extends string ? any : T2 extends TemplateStringsArray ? any[] : (HTMLStyleElement|CSSStyleSheet)[]
     * ): T1
     * }}
     */
    static css(array, ...substitutions) {
      this._addCallback(
        "_onComposeCallbacks",
        /** @type {(opts: CallbackArguments) => unknown} */
        ((opts) => {
          const { composition } = opts;
          if (typeof array === "string" || Array.isArray(array)) {
            composition.append(css(array, ...substitutions));
          } else {
            composition.append(array, ...substitutions);
          }
        })
      );
      return this;
    }
    /**
     * Registers class with customElements. If class is registered before then,
     * does nothing.
     * @type {{
     * <T extends typeof CustomElement>(this: T, elementName: string): T;
     * }}
     */
    static autoRegister(elementName) {
      if (this.hasOwnProperty("defined") && this.defined) {
        console.warn(this.elementName, "already registered.");
        return this;
      }
      this.register(elementName);
      return this;
    }
    /**
     * Appends DocumentFragment to composition
     * @type {{
     * <T extends typeof CustomElement>(
     *  this: T,
     *  string: TemplateStringsArray,
     *  ...substitutions: (string|Element|((this:InstanceType<T>, data:InstanceType<T>, injections?:any) => any))[]
     *  ): T
     * }}
     */
    static html(strings, ...substitutions) {
      this._addCallback(
        "_onComposeCallbacks",
        /** @type {(opts: CallbackArguments) => unknown} */
        ((opts) => {
          const { composition } = opts;
          composition.append(html(strings, ...substitutions));
        })
      );
      return this;
    }
    /**
     * Extends base class into a new class.
     * Use to avoid mutating base class.
     * @type {{
     * <T1 extends typeof CustomElement, T2 extends T1, T3 extends (Base:T1) => T2>
     * (this: T1,customExtender?: T3|null): T3 extends null ? T1 : T2;
     * }}
     */
    static extend(customExtender) {
      return customExtender ? customExtender(this) : class extends this {
      };
    }
    /**
     * Assigns static values to class
     * @type {{
     * <
     *  T1 extends typeof CustomElement,
     *  T2 extends {
     *    [K in keyof any]: (
     *      ((this:T1, ...args:any[]) => any)
     *      |string|number|boolean|any[]|object)}
     *  >
     *  (this: T1, source: T2 & ThisType<T1 & T2>):T1 & T2;
     * }}
     */
    static setStatic(source) {
      Object.assign(this, source);
      return this;
    }
    /**
     * Assigns values directly to all instances (via prototype)
     * @type {{
     * <
     *  CLASS extends typeof CustomElement,
     *  ARGS extends ConstructorParameters<CLASS>,
     *  INSTANCE extends InstanceType<CLASS>,
     *  PROPS extends object>
     *  (this: CLASS, source: PROPS & ThisType<PROPS & INSTANCE>, options?: Partial<PropertyDescriptor>)
     *  : CLASS & Class<PROPS,ARGS>
     * }}
     */
    static readonly(source, options) {
      return this.set(source, { ...options, writable: false });
    }
    /**
     * Assigns values directly to all instances (via prototype)
     * @type {{
     * <
     * CLASS extends typeof CustomElement,
     * ARGS extends ConstructorParameters<CLASS>,
     * INSTANCE extends InstanceType<CLASS>,
     * PROPS extends object>
     * (this: CLASS, source: PROPS & ThisType<PROPS & INSTANCE>, options?: Partial<PropertyDescriptor>)
     * : CLASS & Class<PROPS,ARGS>
     * }}
     */
    static set(source, options) {
      Object.defineProperties(
        this.prototype,
        Object.fromEntries([
          ...Object.entries(source).map(([name, value]) => {
            this.undefine(name);
            return [
              name,
              {
                enumerable: name[0] !== "_",
                configurable: true,
                value,
                writable: true,
                ...options
              }
            ];
          }),
          ...Object.getOwnPropertySymbols(source).map((symbol) => [
            symbol,
            {
              enumerable: false,
              configurable: true,
              // @ts-expect-error Can't index by symbol
              value: source[symbol],
              writable: true,
              ...options
            }
          ])
        ])
      );
      return this;
    }
    /**
     * Returns result of calling mixin with current class
     * @type {{
     * <
     *  BASE extends typeof CustomElement,
     *  FN extends (...args:any[]) => any,
     *  RETURN extends ReturnType<FN>,
     *  SUBCLASS extends ClassOf<RETURN>,
     *  >(this: BASE, mixin: FN): SUBCLASS & BASE
     * }}
     */
    static mixin(mixin) {
      return mixin(this);
    }
    /**
     * Registers class with window.customElements synchronously
     * @type {{
     * <T extends typeof CustomElement>(this: T, elementName?: string, force?: boolean): T;
     * }}
     */
    static register(elementName) {
      if (elementName) {
        this.elementName = elementName;
      }
      customElements.define(this.elementName, this);
      _CustomElement.registrations.set(this.elementName, this);
      this.defined = true;
      return this;
    }
    static get propList() {
      if (!this.hasOwnProperty("_props")) {
        this._props = new Map(this._props);
      }
      return this._props;
    }
    static get attrList() {
      if (!this.hasOwnProperty("_attrs")) {
        this._attrs = new Map(this._attrs);
      }
      return this._attrs;
    }
    static get propChangedCallbacks() {
      if (!this.hasOwnProperty("_propChangedCallbacks")) {
        this._propChangedCallbacks = new Map(
          [
            ...this._propChangedCallbacks
          ].map(([name, array]) => [name, array.slice()])
        );
      }
      return this._propChangedCallbacks;
    }
    static get attributeChangedCallbacks() {
      if (!this.hasOwnProperty("_attributeChangedCallbacks")) {
        this._attributeChangedCallbacks = new Map(
          [
            ...this._attributeChangedCallbacks
          ].map(([name, array]) => [name, array.slice()])
        );
      }
      return this._attributeChangedCallbacks;
    }
    /**
     * Creates observable property on instances (via prototype)
     * @type {{
     * <
     *  CLASS extends typeof CustomElement,
     *  ARGS extends ConstructorParameters<CLASS>,
     *  INSTANCE extends InstanceType<CLASS>,
     *  KEY extends string,
     *  OPTIONS extends ObserverPropertyType
     *    | ObserverOptions<ObserverPropertyType, unknown, INSTANCE>
     *    | ((this:INSTANCE, data:Partial<INSTANCE>, fn?: () => any) => any),
     *  VALUE extends Record<KEY, OPTIONS extends (...args2:any[]) => infer R ? R
     *      : OPTIONS extends ObserverPropertyType ? import('./observe').ParsedObserverPropertyType<OPTIONS>
     *      : OPTIONS extends {type: 'object'} & ObserverOptions<any, infer R> ? (unknown extends R ? object : R)
     *      : OPTIONS extends {type: ObserverPropertyType} ? import('./observe').ParsedObserverPropertyType<OPTIONS['type']>
     *      : OPTIONS extends ObserverOptions<any, infer R> ? (unknown extends R ? string : R)
     *      : never
     *      >
     *  > (this: CLASS, name: KEY, options: OPTIONS)
     *    : CLASS & Class<VALUE,ARGS>
     * }}
     */
    static prop(name, typeOrOptions) {
      const config = defineObservableProperty(
        /** @type {any} */
        this.prototype,
        name,
        /** @type {any} */
        typeOrOptions
      );
      const { changedCallback, attr, reflect, watchers } = config;
      if (changedCallback) {
        watchers.push([name, changedCallback]);
      }
      config.changedCallback = function wrappedChangedCallback(oldValue, newValue, changes) {
        this._onObserverPropertyChanged.call(this, name, oldValue, newValue, changes);
      };
      this.propList.set(name, config);
      if (attr && (reflect === true || reflect === "read") && (config.enumerable || !this.attrList.has(attr) || !this.attrList.get(attr).enumerable)) {
        this.attrList.set(attr, config);
      }
      this.onPropChanged(watchers);
      return this;
    }
    /**
     * Define properties on instances via Object.defineProperties().
     * Automatically sets property non-enumerable if name begins with `_`.
     * Functions will be remapped as getters
     * @type {{
     * <
     *  CLASS extends typeof CustomElement,
     *  ARGS extends ConstructorParameters<CLASS>,
     *  INSTANCE extends InstanceType<CLASS>,
     *  PROPS extends {
     *      [P in keyof any] :
     *        {
     *          enumerable?: boolean;
     *          configurable?: boolean;
     *          writable?: boolean;
     *          value?: any;
     *          get?: ((this: INSTANCE) => any);
     *          set?: (this: INSTANCE, value: any) => void;
     *        } | ((this: INSTANCE, ...args:any[]) => any)
     *    },
     *  VALUE extends {
     *    [KEY in keyof PROPS]: PROPS[KEY] extends (...args2:any[]) => infer R ? R
     *      : PROPS[KEY] extends TypedPropertyDescriptor<infer R> ? R : never
     *  }>
     *  (this: CLASS, props: PROPS & ThisType<PROPS & INSTANCE>): CLASS
     *    & Class<VALUE,ARGS>
     * }}
     */
    static define(props) {
      Object.defineProperties(
        this.prototype,
        Object.fromEntries(
          Object.entries(props).map(([name, options]) => {
            this.undefine(name);
            return [
              name,
              {
                enumerable: name[0] !== "_",
                configurable: true,
                ...typeof options === "function" ? { get: options } : options
              }
            ];
          })
        )
      );
      return this;
    }
    /**
     * Assigns values directly to all instances (via prototype)
     * @type {{
     * <
     *  CLASS extends typeof CustomElement,
     *  ARGS extends ConstructorParameters<CLASS>,
     *  INSTANCE extends InstanceType<CLASS>,
     *  PROP extends string,
     *  PROPS extends INSTANCE & Record<PROP, never>
     *  >(this: CLASS, name: PROP):
     *  CLASS & Class<PROPS,ARGS>
     * }}
     */
    static undefine(name) {
      Reflect.deleteProperty(this.prototype, name);
      if (this.propList.has(name)) {
        const { watchers, attr, reflect } = this.propList.get(name);
        if (watchers.length && this.propChangedCallbacks.has(name)) {
          const propWatchers = this.propChangedCallbacks.get(name);
          for (const [prop, watcher] of watchers) {
            const index = propWatchers.indexOf(watcher);
            if (index !== -1) {
              console.warn("Unwatching", name);
              propWatchers.splice(index, 1);
            }
          }
        }
        if (attr && (reflect === true || reflect === "read")) {
          this.attrList.delete(attr);
        }
        this.propList.delete(name);
      }
      return this;
    }
    /**
     * Creates observable properties on instances
     * @type {{
     * <
     *  CLASS extends typeof CustomElement,
     *  ARGS extends ConstructorParameters<CLASS>,
     *  INSTANCE extends InstanceType<CLASS>,
     *  PROPS extends IDLParameter<INSTANCE & VALUE>,
     *  VALUE extends {
     *    [KEY in keyof PROPS]:
     *    PROPS[KEY] extends (...args2:any[]) => infer R ? R
     *        : PROPS[KEY] extends ObserverPropertyType ? import('./observe').ParsedObserverPropertyType<PROPS[KEY]>
     *        : PROPS[KEY] extends {type: 'object'} & ObserverOptions<any, infer R> ? (unknown extends R ? object : R)
     *        : PROPS[KEY] extends {type: ObserverPropertyType} ? import('./observe').ParsedObserverPropertyType<PROPS[KEY]['type']>
     *        : PROPS[KEY] extends ObserverOptions<any, infer R> ? (unknown extends R ? string : R)
     *        : never
     *  },
     *  > (this: CLASS, props: PROPS)
     *    : CLASS & Class<VALUE,ARGS>
     * }}
     */
    static observe(props) {
      for (const [name, typeOrOptions] of Object.entries(props ?? {})) {
        const options = typeof typeOrOptions === "function" ? { reflect: false, get: typeOrOptions } : typeOrOptions;
        this.prop(name, options);
      }
      return this;
    }
    /**
     * @type {{
     * <
     *  T1 extends typeof CustomElement,
     *  T2 extends IDLParameter<T1>>
     *  (this: T1, props: T2):T1 & ParsedProps<T2>
     * }}
     */
    static defineStatic(props) {
      for (const [name, typeOrOptions] of Object.entries(props ?? {})) {
        const options = typeof typeOrOptions === "function" ? { get: typeOrOptions } : typeof typeOrOptions === "string" ? { type: typeOrOptions } : typeOrOptions;
        defineObservableProperty(this, name, {
          reflect: false,
          ...options
        });
      }
      return this;
    }
    /**
     * @type {{
     * <T extends typeof CustomElement>
     *  (
     *    this: T,
     *    listeners?: import('./Composition').CompositionEventListenerObject<InstanceType<T>>,
     *    options?: Partial<import('./Composition').CompositionEventListener<InstanceType<T>>>,
     *  ): T;
     * }}
     */
    static events(listeners, options) {
      this.on({
        composed({ composition }) {
          for (const [key, listenerOptions] of Object.entries(listeners)) {
            const [, flags, type] = key.match(/^([*1~]+)?(.*)$/);
            let prop;
            let deepProp = [];
            if (typeof listenerOptions === "string") {
              const parsedProps = listenerOptions.split(".");
              if (parsedProps.length === 1) {
                prop = listenerOptions;
                deepProp = [];
              } else {
                prop = parsedProps[0];
                deepProp = parsedProps;
              }
            }
            composition.addCompositionEventListener({
              type,
              once: flags == null ? void 0 : flags.includes("1"),
              passive: flags == null ? void 0 : flags.includes("~"),
              capture: flags == null ? void 0 : flags.includes("*"),
              ...typeof listenerOptions === "function" ? { handleEvent: listenerOptions } : typeof listenerOptions === "string" ? { prop, deepProp } : listenerOptions,
              ...options
            });
          }
        }
      });
      return this;
    }
    /**
     * @type {{
     * <T extends typeof CustomElement>
     *  (
     *    this: T,
     *    listenerMap: {
     *      [P in keyof any]: import('./Composition').CompositionEventListenerObject<InstanceType<T>>
     *    },
     *    options?: Partial<import('./Composition').CompositionEventListener<InstanceType<T>>>,
     *  ): T;
     * }}
     */
    static childEvents(listenerMap, options) {
      for (const [tag, listeners] of Object.entries(listenerMap)) {
        this.events(listeners, {
          tag: attrNameFromPropName(tag),
          ...options
        });
      }
      return this;
    }
    /** @type {typeof CustomElement['events']} */
    static rootEvents(listeners, options) {
      return this.events(listeners, {
        tag: Composition.shadowRootTag,
        ...options
      });
    }
    /**
     * @type {{
     * <
     *  T1 extends typeof CustomElement,
     *  T2 extends InstanceType<T1>,
     *  T3 extends CompositionCallback<T2, T2>,
     *  T4 extends keyof T3,
     *  >
     *  (this: T1, name: T3|T4, callbacks?: T3[T4] & ThisType<T2>): T1
     * }}
     */
    static on(nameOrCallbacks, callback) {
      const callbacks = typeof nameOrCallbacks === "string" ? { [nameOrCallbacks]: callback } : nameOrCallbacks;
      for (const [name, fn] of Object.entries(callbacks)) {
        let arrayPropName;
        switch (name) {
          case "composed":
            arrayPropName = "_onComposeCallbacks";
            break;
          case "constructed":
            arrayPropName = "_onConstructedCallbacks";
            break;
          case "connected":
            arrayPropName = "_onConnectedCallbacks";
            break;
          case "disconnected":
            arrayPropName = "_onDisconnectedCallbacks";
            break;
          case "props":
            this.onPropChanged(fn);
            continue;
          case "attrs":
            this.onAttributeChanged(fn);
            continue;
          default:
            if (name.endsWith("Changed")) {
              const prop = name.slice(0, name.length - "Changed".length);
              this.onPropChanged({ [prop]: fn });
              continue;
            }
            throw new Error("Invalid callback name");
        }
        this._addCallback(arrayPropName, fn);
      }
      return this;
    }
    /**
     * @type {{
     * <
     *  T1 extends typeof CustomElement,
     *  T2 extends InstanceType<T1>
     *  >
     *  (
     *    this: T1,
     *    options: ObjectOrObjectEntries<{
     *      [P in keyof T2]? : (
     *      this: T2,
     *      oldValue: T2[P],
     *      newValue: T2[P],
     *      changes:any,
     *      element: T2
     *      ) => void
     *    }>,
     *  ): T1;
     * }}
     */
    static onPropChanged(options) {
      const entries = Array.isArray(options) ? options : Object.entries(options);
      const { propChangedCallbacks } = this;
      for (const [prop, callback] of entries) {
        if (propChangedCallbacks.has(prop)) {
          propChangedCallbacks.get(prop).push(callback);
        } else {
          propChangedCallbacks.set(prop, [callback]);
        }
      }
      return this;
    }
    /**
     * @type {{
     * <
     *  T1 extends typeof CustomElement,
     *  T2 extends InstanceType<T1>
     *  >
     *  (
     *    this: T1,
     *    options: {
     *      [x:string]: (
     *      this: T2,
     *      oldValue: string,
     *      newValue: string,
     *      element: T2
     *      ) => void
     *    },
     *  ): T1;
     * }}
     */
    static onAttributeChanged(options) {
      const entries = Array.isArray(options) ? options : Object.entries(options);
      const { attributeChangedCallbacks } = this;
      for (const [name, callback] of entries) {
        if (attributeChangedCallbacks.has(name)) {
          attributeChangedCallbacks.get(name).push(callback);
        } else {
          attributeChangedCallbacks.set(name, [callback]);
        }
      }
      return this;
    }
    /** @type {Record<string, HTMLElement>}} */
    #refsProxy;
    /** @type {Map<string, WeakRef<HTMLElement>>}} */
    #refsCache = /* @__PURE__ */ new Map();
    /** @type {Map<string, WeakRef<HTMLElement>>}} */
    #refsCompositionCache = /* @__PURE__ */ new Map();
    /** @type {Composition<?>} */
    #composition;
    #patching = false;
    /** @type {Array<[string, any, CustomElement]>} */
    #pendingPatchRenders = [];
    /** @type {Map<string,{stringValue:string, parsedValue:any}>} */
    _propAttributeCache;
    /** @type {CallbackArguments} */
    _callbackArguments = null;
    /** @param {any[]} args */
    constructor(...args) {
      super();
      if (_CustomElement.supportsElementInternals) {
        this.elementInternals = this.attachInternals();
      }
      this.attachShadow({ mode: "open", delegatesFocus: this.delegatesFocus });
      this.render = this.composition.render(
        this.constructor.prototype,
        this,
        {
          defaults: this.constructor.prototype,
          store: this,
          shadowRoot: this.shadowRoot,
          context: this
        }
      );
      for (const callback of this.static._onConstructedCallbacks) {
        callback.call(this, this.callbackArguments);
      }
    }
    /**
     * @type {{
     * <
     *   T extends CustomElement,
     *   K extends string = string,
     * >(this:T,
     *     name: K,
     *     oldValue: K extends keyof T ? T[K] : unknown,
     *     newValue: K extends keyof T ? T[K] : unknown,
     *     changes?: K extends keyof T ? T[K] extends object ? Partial<T[K]> : T[K] : unknown): void;
     * }}
     */
    propChangedCallback(name, oldValue, newValue, changes = newValue) {
      if (this.#patching) {
        this.#pendingPatchRenders.push([name, changes, this]);
      } else {
        this.render.byProp(name, changes, this);
      }
      const { _propChangedCallbacks } = this.static;
      if (_propChangedCallbacks.has(name)) {
        for (const callback of _propChangedCallbacks.get(name)) {
          callback.call(this, oldValue, newValue, changes, this);
        }
      }
    }
    /**
     * @param {string} name
     * @param {string|null} oldValue
     * @param {string|null} newValue
     */
    attributeChangedCallback(name, oldValue, newValue) {
      const { attributeChangedCallbacks } = this.static;
      if (attributeChangedCallbacks.has(name)) {
        for (const callback of attributeChangedCallbacks.get(name)) {
          callback.call(this, oldValue, newValue, this);
        }
      }
      const { attrList } = this.static;
      if (!attrList.has(name)) return;
      const config = attrList.get(name);
      if (config.attributeChangedCallback) {
        config.attributeChangedCallback.call(this, name, oldValue, newValue);
        return;
      }
      let cacheEntry;
      if (this.attributeCache.has(name)) {
        cacheEntry = this.attributeCache.get(name);
        if (cacheEntry.stringValue === newValue) return;
      }
      const previousDataValue = this[config.key];
      const parsedValue = newValue === null ? config.nullParser(
        /** @type {null} */
        newValue
      ) : config.type === "boolean" ? true : config.parser(newValue);
      if (parsedValue === previousDataValue) {
        return;
      }
      if (cacheEntry) {
        cacheEntry.stringValue = newValue;
        cacheEntry.parsedValue = parsedValue;
      } else {
        this.attributeCache.set(name, {
          stringValue: newValue,
          parsedValue
        });
      }
      this[config.key] = parsedValue;
    }
    get #template() {
      var _a5;
      return (_a5 = this.#composition) == null ? void 0 : _a5.template;
    }
    /**
     * @param {string} name
     * @param {any} oldValue
     * @param {any} newValue
     * @param {any} changes
     */
    _onObserverPropertyChanged(name, oldValue, newValue, changes) {
      const { propList } = this.static;
      if (propList.has(name)) {
        const { reflect, attr } = propList.get(name);
        if (attr && (reflect === true || reflect === "write")) {
          let cacheEntry;
          let needsWrite = false;
          const { attributeCache } = this;
          if (attributeCache.has(attr)) {
            cacheEntry = attributeCache.get(attr);
            needsWrite = cacheEntry.parsedValue !== newValue;
          } else {
            cacheEntry = {};
            attributeCache.set(attr, cacheEntry);
            needsWrite = true;
          }
          if (needsWrite) {
            const stringValue = attrValueFromDataValue(newValue);
            cacheEntry.parsedValue = newValue;
            cacheEntry.stringValue = stringValue;
            if (stringValue == null) {
              this.removeAttribute(attr);
            } else {
              this.setAttribute(attr, stringValue);
            }
          }
        }
      }
      this.propChangedCallback(name, oldValue, newValue, changes);
    }
    /** @param {any} patch */
    patch(patch) {
      this.#patching = true;
      applyMergePatch(this, patch);
      for (const [name, changes, state] of this.#pendingPatchRenders) {
        if (name in patch) continue;
        this.render.byProp(name, changes, state);
      }
      this.#pendingPatchRenders.slice(0, this.#pendingPatchRenders.length);
      this.render(patch);
      this.#patching = false;
    }
    /**
     * Proxy object that returns shadow DOM elements by tag.
     * If called before interpolation (eg: on composed), returns from template
     * @return {Record<string,HTMLElement>}
     */
    get refs() {
      return this.#refsProxy ??= new Proxy({}, {
        /**
         * @param {any} target
         * @param {string} tag
         * @return {Element}
         */
        get: (target, tag) => {
          if (!this.#composition) {
            console.warn(this.static.name, "Attempted to access references before composing!");
          }
          const composition = this.composition;
          let element;
          if (!composition.interpolated) {
            if (this.#refsCompositionCache.has(tag)) {
              element = this.#refsCompositionCache.get(tag).deref();
              if (element) return element;
            }
            const formattedTag2 = attrNameFromPropName(tag);
            element = composition.template.getElementById(formattedTag2);
            if (!element) return null;
            this.#refsCompositionCache.set(tag, new WeakRef(element));
            return element;
          }
          if (this.#refsCache.has(tag)) {
            element = this.#refsCache.get(tag).deref();
            if (element) {
              return element;
            }
          }
          const formattedTag = attrNameFromPropName(tag);
          const tagIndex = this.composition.tags.indexOf(formattedTag);
          element = this.render.state.refs[tagIndex];
          if (!element) return null;
          this.#refsCache.set(tag, new WeakRef(element));
          return element;
        }
      });
    }
    get attributeCache() {
      return this._propAttributeCache ??= /* @__PURE__ */ new Map();
    }
    get static() {
      return (
        /** @type {typeof CustomElement} */
        /** @type {unknown} */
        this.constructor
      );
    }
    get unique() {
      return false;
    }
    /**
     * @template {CustomElement} T
     * @this {T}
     */
    get callbackArguments() {
      return this._callbackArguments ??= {
        composition: this.#composition,
        refs: this.refs,
        html: html.bind(this),
        inline: addInlineFunction,
        template: this.#template,
        element: this
      };
    }
    /** @return {Composition<?>} */
    get composition() {
      if (this.#composition) return this.#composition;
      if (!this.unique && this.static.hasOwnProperty("_composition")) {
        this.#composition = this.static._composition;
        return this.static._composition;
      }
      this.compose();
      for (const callback of this.static._onComposeCallbacks) {
        callback.call(this, this.callbackArguments);
      }
      if (!this.unique) {
        this.static._composition = this.#composition;
      }
      return this.#composition;
    }
    connectedCallback() {
      for (const callbacks of this.static._onConnectedCallbacks) {
        callbacks.call(this, this.callbackArguments);
      }
    }
    disconnectedCallback() {
      for (const callbacks of this.static._onDisconnectedCallbacks) {
        callbacks.call(this, this.callbackArguments);
      }
    }
  };
  CustomElement.prototype.delegatesFocus = false;

  // mixins/DelegatesFocusMixin.js
  function DelegatesFocusMixin(Base) {
    return Base.set({
      /** When true, the element delegates focus to an internal focus target. */
      delegatesFocus: true
    }).extend(CHROME_VERSION >= 111 ? (BaseClass) => BaseClass : (BaseClass) => class extends BaseClass {
      get tabIndex() {
        return super.tabIndex;
      }
      set tabIndex(value) {
        if (value === super.tabIndex && value !== -1) {
          return;
        }
        if (this.delegatesFocus && isFocused(this)) {
          if (this.getAttribute("tabindex") === value.toString()) {
            return;
          }
          const listener = (e) => {
            e.stopImmediatePropagation();
            e.stopPropagation();
            if (e.type === "blur") {
              console.warn("Chromium bug 1346606: Tabindex change caused blur. Giving focusing back.", this);
              this.focus();
            } else {
              console.warn(`Chromium bug 1346606: Blocking ${e.type} event.`, this);
            }
          };
          for (const type of ["blur", "focus", "focusout", "focusin"]) {
            this.addEventListener(type, listener, { capture: true, once: true });
          }
          super.tabIndex = value;
          for (const type of ["blur", "focus", "focusout", "focusin"]) {
            this.removeEventListener(type, listener, { capture: true });
          }
          return;
        }
        super.tabIndex = value;
      }
    });
  }

  // mixins/FormAssociatedMixin.js
  var FORM_IPC_EVENT = "mdw-form-associated-changed";
  var DOMString = { nullParser: String, value: "" };
  function FormAssociatedMixin(Base) {
    return Base.setStatic({
      formAssociated: true
    }).set({
      /** @type {EventListener} */
      _ipcListener: null,
      /** @type {EventTarget} */
      _ipcTarget: null,
      /** @type {FileList} */
      _files: null
    }).observe({
      /** ARIA 'controls' attribute (string). */
      ariaControls: "string",
      /** Autocomplete token for the associated control (string). */
      autocomplete: DOMString,
      /** Name attribute for the control used in forms. */
      name: DOMString,
      /** Read-only state reflected to control via 'readonly' attribute. */
      readOnly: { attr: "readonly", type: "boolean" },
      /** When true, form validation is skipped for this control (formnovalidate). */
      formNoValidate: { attr: "formnovalidate", type: "boolean" },
      /** Default checked state for checkable controls (checkbox/radio). */
      defaultChecked: { attr: "checked", type: "boolean" },
      _checkedDirty: "boolean",
      /* "Checkedness" */
      _checked: "boolean",
      /** Whether the control is required for form submission. */
      required: "boolean",
      /** Control type token (e.g. 'text','checkbox','radio','file'). */
      type: DOMString,
      //  [CEReactions] attribute [LegacyNullToEmptyString] DOMString value;
      /** Reflected default value backing field (attr: value). */
      _defaultValue: { reflect: true, attr: "value" },
      /** Internal value storage. */
      _value: { empty: "" },
      _valueDirty: "boolean",
      /** Whether the user has interacted with the control (used for validation UX). */
      _userInteracted: "boolean",
      _invalid: "boolean",
      _badInput: "boolean",
      _validationMessage: "string",
      _formDisabled: "boolean",
      _formReset: "boolean"
    }).observe({
      erroredState({ _invalid, _userInteracted }) {
        return _userInteracted && _invalid;
      },
      defaultValue: {
        reflect: false,
        get({ _defaultValue }) {
          return _defaultValue ?? "";
        },
        set(value) {
          this._defaultValue = String(value);
        }
      },
      _valueBehavior({ type }) {
        switch (type) {
          case "radio":
          case "checkbox":
            return "default/on";
          case "hidden":
          case "button":
          case "submit":
          case "image":
          case "reset":
            return "default";
          case "file":
            return "filename";
          default:
            return "value";
        }
      }
    }).methods({
      /**
       * Default behavior should likely be overridden
       * @param {string} value
       */
      _onSetValue(value) {
        this._value = value;
      },
      /**
       * Default behavior should likely be overridden
       * @param {boolean} checked
       */
      _onSetChecked(checked) {
        this._checked = checked;
      }
    }).observe({
      value: {
        reflect: false,
        get({ _valueBehavior, _defaultValue, _value }) {
          switch (_valueBehavior) {
            case "filename":
            default:
              return _value;
            case "default":
              return _defaultValue ?? "";
            case "default/on":
              return _defaultValue ?? "on";
          }
        },
        /** @param {string} v */
        set(v) {
          switch (this._valueBehavior) {
            case "value":
              this._valueDirty = true;
              this._onSetValue(v);
              break;
            case "filename":
              if (v == null || v === "") {
                this._files = null;
              } else {
                throw new DOMException("InvalidStateError");
              }
              break;
            default:
              this.defaultValue = v;
          }
        }
      },
      /**
       * Part of FormAssociatedMixin for simplicity.
       * Enumerability doesn't guarantee checked state will be passed or used.
       */
      checked: {
        reflect: false,
        type: "boolean",
        get({ _checkedDirty, defaultChecked, _checked }) {
          if (_checkedDirty) return _checked;
          return defaultChecked;
        },
        /** @param {boolean} checked */
        set(checked) {
          this._checkedDirty = true;
          this._onSetChecked(checked);
        }
      }
    }).define({
      form() {
        return this.elementInternals.form;
      },
      validity() {
        return this.elementInternals.validity;
      },
      validationMessage() {
        return this.elementInternals.validationMessage;
      },
      willValidate() {
        if (this.type === "submit") return !this.formNoValidate;
        if (this.type === "button" || this.type === "reset") return false;
        return this.elementInternals.willValidate;
      },
      labels() {
        return this.elementInternals.labels;
      }
    }).observe({
      disabledState({ _formDisabled, disabled }) {
        if (_formDisabled) return true;
        return !!disabled;
      }
    }).methods({
      checkValidity() {
        return this.elementInternals.checkValidity();
      },
      reportValidity() {
        return this.elementInternals.reportValidity();
      },
      /**
       * @param {string} error
       * @return {void}
       */
      setCustomValidity(error) {
        this.elementInternals.setValidity({
          ...this.elementInternals.validity,
          customError: !!error
        }, this.elementInternals.validationMessage || error);
      },
      /**
       * @param {string} key
       * @param {string} value
       * @return {void}
       */
      _notifyRadioChange(key, value) {
        var _a5;
        (_a5 = this._ipcTarget) == null ? void 0 : _a5.dispatchEvent(
          new CustomEvent(FORM_IPC_EVENT, { detail: [key, value] })
        );
      },
      refreshFormAssociation() {
        const newTarget = this.elementInternals.form ?? this.getRootNode();
        if (newTarget === this._ipcTarget) {
          return;
        }
        if (this._ipcTarget) {
          this._ipcTarget.removeEventListener(FORM_IPC_EVENT, this._ipcListener);
        }
        if (this.type !== "radio") return;
        this._ipcTarget = newTarget;
        this._ipcListener ??= this.formIPCEvent.bind(this);
        this._ipcTarget.addEventListener(FORM_IPC_EVENT, this._ipcListener);
      },
      /**
       * New lifecycle callback. This is called when association with
       * <form> is changed.
       * @param {HTMLFormElement?} form
       * @return {void}
       */
      formAssociatedCallback(form) {
        this.refreshFormAssociation();
        this.checkValidity();
      },
      /**
       * @param {CustomEvent<[string, string]>} event
       * @return {void}
       */
      formIPCEvent(event) {
        if (event.target instanceof HTMLFormElement && event.target !== this.form) {
          console.warn("Control.formIPCEvent: Abort from wrong form");
          return;
        }
        if (this.type !== "radio") {
          console.warn("Control.formIPCEvent: Abort from not radio");
          return;
        }
        const [name, value] = event.detail;
        if (this.name !== name) return;
        if (value === this.value) {
        } else {
          console.debug("FormAssociatedMixin: Unchecking", this);
          this.checked = false;
        }
      },
      /** @param {boolean} disabled */
      formDisabledCallback(disabled) {
        this._formDisabled = disabled;
      },
      formResetCallback() {
        this._formReset = true;
        this._valueDirty = false;
        this.checkValidity();
        this._userInteracted = false;
        this._formReset = false;
      },
      /**
       * @param {string|FormData} state
       * @param {'autocomplete'|'restore'} mode
       */
      formStateRestoreCallback(state, mode) {
        if (CHROME_VERSION < 115) {
          return;
        }
        if (typeof state !== "string") {
          console.warn("FormAssociatedMixin: (Restore) Could not restore", state);
          return;
        }
        if (this.type === "checkbox" || this.type === "radio") {
          console.debug("FormAssociatedMixin: (Restore) Setting Checkbox checked state.", state, this);
          this.checked = state === "checked";
          return;
        }
        if (this.type === "radio") {
          this.checked = state === "checked";
          return;
        }
        console.debug("FormAssociatedMixin: (Restore) Setting value state.", state, this);
        this.value = state;
      },
      _updateFormAssociatedValue() {
        switch (this.type) {
          case "radio":
            if (this.checked) {
              this._notifyRadioChange(this.name, this.value || "on");
            }
          // Fallthrough
          case "checkbox":
            if (this.checked) {
              this.elementInternals.setFormValue(this.value, "checked");
            } else {
              this.elementInternals.setFormValue(null, "unchecked");
            }
            break;
          case "button":
          case "reset":
            this.elementInternals.setFormValue(null);
            break;
          case "file": {
            const { elementInternals, _files, name } = this;
            if (!_files || _files.length) {
              elementInternals.setFormValue(null);
            } else {
              const fd = new FormData();
              for (const entry of _files) {
                fd.append(name, entry);
              }
              elementInternals.setFormValue(fd);
            }
            break;
          }
          case "select-multiple": {
            const formData = new FormData();
            const selectElement = (
              /** @type {HTMLSelectElement} */
              /** @type {unknown} */
              this
            );
            if (selectElement.name) {
              for (const option of selectElement.selectedOptions) {
                formData.append(selectElement.name, option.value);
              }
            }
            this.elementInternals.setFormValue(formData);
            break;
          }
          // case 'select-one':
          default:
            this.elementInternals.setFormValue(this.value);
        }
      }
    }).events({
      blur() {
        this._userInteracted = true;
        this.checkValidity();
      }
    }).on({
      connected() {
        this.refreshFormAssociation();
      },
      checkedChanged() {
        this._updateFormAssociatedValue();
      },
      valueChanged() {
        this._updateFormAssociatedValue();
      },
      _valueBehaviorChanged(previous, current) {
        if (previous !== "filename" && current === "filename") {
          this.value = "";
        }
      },
      typeChanged() {
        this._updateFormAssociatedValue();
      }
    });
  }

  // mixins/ControlMixin.js
  function ControlMixin(Base) {
    return Base.mixin(FormAssociatedMixin).mixin(DelegatesFocusMixin).observe({
      /** Optional aria-label applied to the internal control (string). */
      ariaLabel: "string",
      /** Internal cached slot text used as fallback label when aria-label is absent. */
      _slotInnerText: "string"
    }).set({
      focusableOnDisabled: false,
      controlTagName: "input",
      controlVoidElement: true,
      _slotMutationObserver: null
    }).methods({
      /**
       * Default behavior can be overridden
       * @param {string} value
       */
      _onControlValue(value) {
        this._value = value;
      },
      onValueChangingContentAttribute() {
        const control = (
          /** @type {HTMLControlElement} */
          this.refs.control
        );
        if (!this.hasAttribute("value")) {
          control.removeAttribute("value");
          control.setAttribute("value", "");
        }
        this._onControlValue(control.value);
      },
      /** @type {HTMLElement['focus']} */
      focus(...options) {
        this.refs.control.focus(...options);
      },
      /** Redirect click requests to control itself */
      click() {
        if (this.disabledState) return;
        this.refs.control.click();
      }
    }).define({
      stateTargetElement() {
        return this.refs.control;
      }
    }).methods({
      checkValidity() {
        if (!this.willValidate) return true;
        const control = (
          /** @type {HTMLControlElement} */
          this.refs.control
        );
        const validityState = control.checkValidity();
        const newValidity = {};
        for (const key in control.validity) {
          newValidity[key] = control.validity[key];
        }
        this.elementInternals.setValidity(newValidity, control.validationMessage, control);
        this._invalid = !validityState;
        this._validationMessage = control.validationMessage;
        this._badInput = control.validity.badInput;
        return validityState;
      },
      reportValidity() {
        this.checkValidity();
        this.refs.control.reportValidity();
        return this.elementInternals.reportValidity();
      },
      /**
       * @param {string} error
       * @return {void}
       */
      setCustomValidity(error) {
        this.refs.control.setCustomValidity(error);
        this.checkValidity();
        this.elementInternals.setValidity(
          {
            ...this.elementInternals.validity,
            customError: !!error
          },
          this.elementInternals.validationMessage || error,
          this.refs.control
        );
      }
    }).observe({
      _computedAriaLabel({ ariaLabel, _slotInnerText }) {
        return (ariaLabel == null ? void 0 : ariaLabel.trim()) || (_slotInnerText == null ? void 0 : _slotInnerText.trim()) || null;
      }
    }).expressions({
      _computedAriaLabelledby({ _computedAriaLabel }) {
        return _computedAriaLabel ? null : "slot";
      }
    }).recompose(({ template, html: html2, element }) => {
      template.append(html2`
        <${element.controlTagName} id=control
          aria-label={_computedAriaLabel}
          aria-labelledby={_computedAriaLabelledby}
          part=control
          form-disabled={disabledState}
          type={type}
          >${element.controlVoidElement ? "" : `</${element.controlTagName}>`}
      `);
    }).on({
      disabledStateChanged(oldValue, newValue) {
        const control = (
          /** @type {HTMLControlElement} */
          this.refs.control
        );
        control.setAttribute("aria-disabled", `${newValue}`);
        if (!this.focusableOnDisabled) {
          control.disabled = newValue;
          if (newValue) {
            this.tabIndex = 0;
          } else {
            this.removeAttribute("tabindex");
          }
        }
      },
      readOnlyChanged(oldValue, newValue) {
        const control = (
          /** @type {HTMLControlElement} */
          this.refs.control
        );
        if (this.type === "checkbox") {
          control.setAttribute("aria-readonly", newValue ? "true" : "false");
        } else {
          control.removeAttribute("aria-readonly");
        }
      },
      constructed() {
        const control = (
          /** @type {HTMLControlElement} */
          this.refs.control
        );
        this._onControlValue(control.value);
      },
      connected() {
        if (!this.hasAttribute("tabindex")) {
          this.tabIndex = 0;
        }
      },
      attrs: {
        autocomplete: cloneAttributeCallback("autocomplete", "control"),
        name: cloneAttributeCallback("name", "control"),
        readonly: cloneAttributeCallback("readonly", "control"),
        required: cloneAttributeCallback("required", "control")
      }
    }).childEvents({
      control: {
        click(e) {
          if (this.type === "checkbox" && this.readOnly || this.focusableOnDisabled && this.disabledState) {
            e.preventDefault();
            e.stopImmediatePropagation();
          }
        },
        input({ currentTarget }) {
          const control = (
            /** @type {HTMLControlElement} */
            currentTarget
          );
          if (this.validity.valid) {
            control.checkValidity();
            this._badInput = control.validity.badInput;
          } else {
            this.checkValidity();
          }
          this._onControlValue(control.value);
        },
        change({ currentTarget }) {
          const control = (
            /** @type {HTMLControlElement} */
            currentTarget
          );
          this._valueDirty = true;
          this._onControlValue(control.value);
          this.checkValidity();
        }
      },
      slot: FIREFOX_VERSION < 116 || SAFARI_VERSION ? {
        slotchange({ currentTarget }) {
          this._slotInnerText = this.textContent;
          if (!this._slotMutationObserver) {
            this._slotMutationObserver = new MutationObserver(() => {
              this._slotInnerText = this.textContent;
            });
            this._slotMutationObserver.observe(currentTarget, { characterData: true });
          }
        }
      } : {}
    }).rootEvents({
      change(event) {
        this.dispatchEvent(new event.constructor(event.type, event));
      }
    }).css`
      :host {
        display: inline-flex;
      }
      
      /* Remove Firefox inner */
      :host(::-moz-focus-inner) {
        border: 0;
      }

      #control {
        /* Control is the touch target */
        /* Firefox requires at least 1px "visible" for screen reading */
        /* Safari will not allow interaction with 0 opacity */
        /* Chrome will not focus with visibility:hidden */
      
        position: absolute;
        /* stylelint-disable-next-line liberty/use-logical-spec */
        top: 50%;
        /* stylelint-disable-next-line liberty/use-logical-spec */
        left: 50%;
        
        /* --mdw-device-pixel-ratio: 1; */
      
        block-size: 100%;
        min-block-size: 48px;
        inline-size:100%;
        min-inline-size: 48px;
        margin: 0;
        border: 0;
        padding: 0;
      
        -webkit-appearance: none;
        -moz-appearance: none;
        appearance: none;
      
        cursor: auto;
        outline: none;
        transform: translateX(-50%) translateY(-50%);
      
        /* Safari and Chrome will emit two click events if not at top of stack */
        /* Allows up to 3 other layers (eg: ripple, outline) */
        z-index: 4;

        background-color: transparent;
      
        border-radius: 0;
        color: transparent;
      }
      
      #control::-moz-focus-inner {
        border: 0;
      }
    
    `;
  }

  // mixins/InputMixin.js
  var IMPLICIT_SUBMISSION_BLOCKING_TYPES = /* @__PURE__ */ new Set([
    "text",
    "search",
    "url",
    "tel",
    "email",
    "password",
    "date",
    "month",
    "week",
    "time",
    "datetime-local",
    "number"
  ]);
  var DOMString2 = { nullParser: String, empty: "" };
  var redispatchedClickEvents = /* @__PURE__ */ new WeakSet();
  var rootClickEvents = /* @__PURE__ */ new WeakSet();
  function InputMixin(Base) {
    return Base.mixin(ControlMixin).observe({
      /** Accepted file types for file input (e.g. '.png,.jpg'). */
      accept: DOMString2,
      /** Alternate text for images (for `type='image'`). */
      alt: DOMString2,
      /** Directionality for form submission name (dirname attribute). */
      dirName: { attr: "dirname", ...DOMString2 },
      /** Form action URL when this input is used as a submit button. */
      _formAction: { attr: "formaction" },
      /** Form encoding type (formenctype). */
      formEnctype: { attr: "formenctype", ...DOMString2 },
      /** Form method when associated with a submit input (formmethod). */
      formMethod: { attr: "formmethod", ...DOMString2 },
      /** Target browsing context for form submission (formtarget). */
      formTarget: { attr: "formtarget", ...DOMString2 },
      /** Rendered height hint for certain input types (integer). */
      _height: { attr: "height", type: "integer" },
      _indeterminate: "boolean",
      /** Max value or token for the input. */
      max: DOMString2,
      /** Maximum length for text-like inputs. */
      maxLength: { attr: "maxlength", type: "integer", empty: -1 },
      /** Min value or token for the input. */
      min: DOMString2,
      /** Minimum length for text-like inputs. */
      minLength: { attr: "minlength", type: "integer", empty: -1 },
      /** When true, multiple values are allowed (e.g. file inputs). */
      multiple: "boolean",
      /** Pattern used for validation (RegExp as string). */
      pattern: DOMString2,
      /** Placeholder text shown when no value is present. */
      placeholder: DOMString2,
      /** Suggested control size (number of characters). */
      size: { type: "integer", empty: 20 },
      /** Source URL for image-type inputs. */
      src: DOMString2,
      /** Step interval for numeric inputs. */
      step: DOMString2,
      //  [CEReactions] attribute [LegacyNullToEmptyString] DOMString value;
      /** Rendered width hint for certain input types (integer). */
      _width: { attr: "width", type: "integer" }
    }).set({
      _useFormImplicitSubmission: true
    }).define({
      // Alias for typescript
      _input() {
        return (
          /** @type {HTMLInputElement} */
          this.refs.control
        );
      }
    }).observe({
      indeterminate: {
        type: "boolean",
        get({ _indeterminate }) {
          return _indeterminate;
        },
        /** @param {boolean} value */
        set(value) {
          this._input.indeterminate = value;
          this._indeterminate = this._input.indeterminate;
        }
      }
    }).overrides({
      controlTagName: "input"
    }).recompose(({ refs: { control } }) => {
      control.setAttribute("checked", "{defaultChecked}");
      control.setAttribute("height", "{_height}");
      control.setAttribute("width", "{_width}");
      control.setAttribute("value", "{_defaultValue}");
    }).on({
      // TODO: Bind multiple
      typeChanged() {
        this.onValueChangingContentAttribute();
      },
      checkedChanged() {
        this._input.checked = this.checked;
        this._input.indeterminate = this._indeterminate;
      },
      _indeterminateChanged(previous, current) {
        this._input.indeterminate = current;
      },
      minChanged() {
        this.onValueChangingContentAttribute();
      },
      minLengthChanged() {
        this.onValueChangingContentAttribute();
      },
      maxChanged() {
        this.onValueChangingContentAttribute();
      },
      maxLengthChanged() {
        this.onValueChangingContentAttribute();
      },
      multipleChanged() {
        this.onValueChangingContentAttribute();
      },
      patternChanged() {
        this.onValueChangingContentAttribute();
      },
      stepChanged() {
        this.onValueChangingContentAttribute();
      },
      defaultValueChanged() {
        this.onValueChangingContentAttribute();
      },
      _formResetChanged(oldValue, newValue) {
        if (!newValue) return;
        this._onSetValue(this.defaultValue);
        const input = this._input;
        input.checked = this.defaultChecked;
        this._checked = input.checked;
        this._checkedDirty = false;
      },
      attrs: {
        accept: cloneAttributeCallback("accept", "control"),
        alt: cloneAttributeCallback("alt", "control"),
        dirname: cloneAttributeCallback("dirname", "control"),
        formenctype: cloneAttributeCallback("formenctype", "control"),
        formmethod: cloneAttributeCallback("formmethod", "control"),
        formnovalidate: cloneAttributeCallback("formnovalidate", "control"),
        formTarget: cloneAttributeCallback("formTarget", "control"),
        max: cloneAttributeCallback("max", "control"),
        maxlength: cloneAttributeCallback("maxlength", "control"),
        min: cloneAttributeCallback("min", "control"),
        minlength: cloneAttributeCallback("minlength", "control"),
        multiple: cloneAttributeCallback("multiple", "control"),
        pattern: cloneAttributeCallback("pattern", "control"),
        placeholder: cloneAttributeCallback("placeholder", "control"),
        size: cloneAttributeCallback("size", "control"),
        src: cloneAttributeCallback("src", "control"),
        step: cloneAttributeCallback("step", "control")
      }
    }).overrides({
      _onSetChecked(checked) {
        this._input.checked = checked;
        this._checked = this._input.checked;
        this.indeterminate = false;
      },
      _onSetValue(value) {
        this._input.value = value;
        this._value = this._input.value;
      }
    }).methods({
      /**
       * @see https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#implicit-submission
       * @param {Event} event
       * @return {void}
       */
      performImplicitSubmission(event) {
        if (!this._useFormImplicitSubmission) return;
        const form = this.form;
        if (!form) return;
        let defaultButton;
        const submissionBlockers = /* @__PURE__ */ new Set();
        for (
          const element of
          /** @type {HTMLCollectionOf<HTMLInputElement>} */
          form.elements
        ) {
          if (element.type === "submit" && !element.disabled && !element.matches(":disabled")) {
            defaultButton ??= element;
            break;
          }
          if (IMPLICIT_SUBMISSION_BLOCKING_TYPES.has(element.type)) {
            submissionBlockers.add(element);
          }
        }
        if (defaultButton) {
          defaultButton.dispatchEvent(new PointerEvent(
            "click",
            { bubbles: true, cancelable: true, composed: true }
          ));
          return;
        }
        if (submissionBlockers.size > 1) return;
        this.form.submit();
      },
      /** @param {Event} event */
      _redispatchControlClickEvent(event) {
        event.stopPropagation();
        const newEvent = new event.constructor(event.type, event);
        redispatchedClickEvents.add(newEvent);
        return this.dispatchEvent(newEvent);
      },
      /** @param {MouseEvent} event */
      _handleInputClick(event) {
        var _a5;
        if (this.disabledState) return;
        const input = this._input;
        switch (input.type) {
          case "checkbox":
          case "radio": {
            const { _checkedDirty, _checked, _indeterminate } = this;
            this.checked = input.checked;
            if (this._redispatchControlClickEvent(event)) return;
            event.preventDefault();
            this._checkedDirty = _checkedDirty;
            this._checked = _checked;
            this._indeterminate = _indeterminate;
            break;
          }
          case "button":
          case "submit":
          case "reset":
            {
              if (!this._redispatchControlClickEvent(event)) {
                event.preventDefault();
                return;
              }
              const { type } = input;
              if (type !== "submit" && type !== "reset") return;
              for (const target of event.composedPath()) {
                if (target === input || target === this) break;
                if ((target instanceof HTMLInputElement || target instanceof HTMLButtonElement) && (target.type === "submit" || target.type === "reset")) {
                  return;
                }
                if (target instanceof HTMLElement && target.form instanceof HTMLFormElement && (target.type === "submit" || target.type === "reset")) {
                  return;
                }
                if (target instanceof HTMLAnchorElement && target.href) {
                  return;
                }
              }
              const form = (_a5 = this.elementInternals) == null ? void 0 : _a5.form;
              if (!form) return;
              if (type === "submit") {
                const duplicatedButton = (
                  /** @type {HTMLInputElement} */
                  input.cloneNode()
                );
                duplicatedButton.hidden = true;
                form.append(duplicatedButton);
                if ("requestSubmit" in form) {
                  form.requestSubmit(duplicatedButton);
                } else {
                  duplicatedButton.click();
                }
                duplicatedButton.remove();
              } else if (type === "reset") {
                form.reset();
              }
            }
            break;
          default:
        }
      }
    }).rootEvents({
      click(event) {
        rootClickEvents.add(event);
        const { control } = this.refs;
        if (event.target === control) return;
        if (!event.bubbles) return;
        const { disabledState, type } = this;
        if (disabledState) return;
        if (type === "checkbox" || type === "radio") {
          event.stopPropagation();
          control.click();
        } else {
          this._handleInputClick(event);
        }
      }
    }).events({
      click(event) {
        if (rootClickEvents.has(event)) return;
        if (redispatchedClickEvents.has(event)) return;
        if (event.target === this) {
          event.stopImmediatePropagation();
          this.refs.control.click();
        }
      }
    }).childEvents({
      control: {
        keydown(event) {
          if (event.defaultPrevented) return;
          if (event.key !== "Enter") return;
          if (
            /** @type {HTMLInputElement} */
            event.currentTarget.type === "submit"
          ) return;
          this.performImplicitSubmission(event);
        },
        click: "_handleInputClick",
        input(event) {
          if (this.disabledState) {
            event.preventDefault();
            event.stopImmediatePropagation();
            return;
          }
          const input = (
            /** @type {HTMLInputElement} */
            event.currentTarget
          );
          this.checked = input.checked;
        },
        change(event) {
          if (this.disabledState) {
            event.preventDefault();
            event.stopImmediatePropagation();
            return;
          }
          const input = (
            /** @type {HTMLInputElement} */
            event.currentTarget
          );
          this.checked = input.checked;
        }
      }
    }).methods({
      /** @type {HTMLInputElement['setRangeText']} */
      // @ts-ignore Can't cast?
      setRangeText(...args) {
        this._input.setRangeText(...args);
      },
      /** @type {HTMLInputElement['setSelectionRange']} */
      setSelectionRange(...args) {
        this._input.setSelectionRange(...args);
      },
      /** @type {HTMLInputElement['showPicker']} */
      showPicker(...args) {
        this._input.showPicker(...args);
      },
      /** @type {HTMLInputElement['stepDown']} */
      stepDown(...args) {
        this._input.stepDown(...args);
        this._value = this._input.value;
      },
      /** @type {HTMLInputElement['stepUp']} */
      stepUp(...args) {
        this._input.stepUp(...args);
        this._value = this._input.value;
      },
      /** @type {HTMLInputElement['select']} */
      select(...args) {
        this._input.select(...args);
      }
    }).define({
      files: {
        get() {
          return this._input.files;
        },
        set(value) {
          if (value == null && this.type === "file") {
            this._input.value = "";
            this.value = "";
          } else {
            this._input.files = value;
          }
        }
      },
      selectionDirection: {
        get() {
          return this._input.selectionDirection;
        },
        set(value) {
          this._input.selectionDirection = value;
        }
      },
      selectionEnd: {
        get() {
          return this._input.selectionEnd;
        },
        set(value) {
          this._input.selectionEnd = value;
        }
      },
      selectionStart: {
        get() {
          return this._input.selectionStart;
        },
        set(value) {
          this._input.selectionStart = value;
        }
      },
      valueAsDate: {
        get() {
          return this._input.valueAsDate;
        },
        set(value) {
          this._input.valueAsDate = value;
          this.value = this._input.value;
        }
      },
      valueAsNumber: {
        get() {
          return this._input.valueAsNumber;
        },
        set(value) {
          this._input.valueAsNumber = value;
          this.value = this._input.value;
        }
      },
      height: {
        get() {
          return this._input.height;
        },
        set(value) {
          this._input.height = value;
          this._height = value;
        }
      },
      formAction: {
        get() {
          return this._input.formAction;
        },
        set(value) {
          this._input.formAction = value;
          this._formAction = value;
        }
      },
      width: {
        get() {
          return this._input.width;
        },
        set(value) {
          this._input.width = value;
          this._width = value;
        }
      }
    }).css`
      #control::-webkit-file-upload-button {
        display: none;
      }
    `;
  }

  // mixins/ResizeObserverMixin.js
  var resizeObserver = new ResizeObserver((entries) => {
    for (const entry of entries) {
      entry.target.onResizeObserved(entry);
    }
  });
  function ResizeObserverMixin(Base) {
    return Base.observe({
      /** Enable or disable automatic ResizeObserver attachment (defaults true) */
      _resizeObserverEnabled: {
        type: "boolean",
        value: true
      }
    }).methods({
      /** @param {ResizeObserverEntry} entry */
      onResizeObserved(entry) {
      },
      observeResize() {
        resizeObserver.observe(this, {
          box: "border-box"
        });
      },
      unobserveResize() {
        resizeObserver.unobserve(this);
      }
    }).on({
      connected() {
        if (!this._resizeObserverEnabled) return;
        this.observeResize();
      },
      disconnected() {
        this.unobserveResize();
      },
      _resizeObserverEnabledChanged(previous, enabled) {
        if (enabled) {
          this.observeResize();
        } else {
          this.unobserveResize();
        }
      }
    });
  }

  // mixins/StateMixin.js
  var _a4;
  var lastInteractionWasTouch = (_a4 = window == null ? void 0 : window.matchMedia) == null ? void 0 : _a4.call(window, "(any-pointer: coarse)").matches;
  function StateMixin(Base) {
    return Base.observe({
      /** Whether the element is disabled (affects interactive states) */
      disabled: "boolean",
      /** Force focus state (independent of document) */
      focused: "boolean",
      /** Force hover state (independent of interaction) */
      hovered: "boolean",
      /** Force pressed state (independent of interaction) */
      pressed: "boolean",
      _lastInteraction: {
        /** @type {'mouse'|'touch'|'key'|'pen'|null} */
        value: null
      },
      _hovered: "boolean",
      _focused: "boolean",
      /** True if focus was synthetic */
      _focusedSynthetic: "boolean",
      _keyPressed: "boolean",
      /** True if key was released this event loop. (Used to ignore clicks) */
      _keyReleased: "boolean",
      _pointerPressed: "boolean",
      /** Show the visual state layer element when true */
      stateLayer: "boolean"
    }).observe({
      disabledState({ disabled }) {
        return disabled;
      },
      hoveredState({ _hovered, hovered }) {
        return _hovered || hovered;
      },
      focusedState({ _focused, focused }) {
        return _focused || focused;
      },
      pressedState({ _keyPressed, _pointerPressed, pressed }) {
        return _keyPressed || _pointerPressed || pressed;
      },
      touchedState({ _lastInteraction }) {
        return _lastInteraction === "touch";
      },
      pointedState({ _lastInteraction }) {
        return _lastInteraction === "mouse" || _lastInteraction === "pen";
      }
    }).define({
      /** @return {HTMLElement} */
      stateTargetElement() {
        return this;
      }
    }).html`
      <div id=state mdw-if={stateLayer}
        disabled={disabledState}
        focused={focusedState}
        hovered={hoveredState}
        pressed={pressedState}
        interaction={_lastInteraction}
        touched={touchedState}
        pointed={pointedState}
        aria-hidden=true></div>
    `.events({
      pointerenter(event) {
        if (!event.isTrusted) return;
        if (!event.isPrimary) return;
        this._pointerPressed = this.stateTargetElement.matches(":active");
        if (event.pointerType === "touch") return;
        this._hovered = true;
      },
      "~pointerdown"(event) {
        if (!event.isTrusted) return;
        if (!event.isPrimary) return;
        this._lastInteraction = /** @type {'touch'|'mouse'|'pen'} */
        event.pointerType;
        this._pointerPressed = true;
      },
      "~pointerup"(event) {
        if (!event.isTrusted) return;
        if (!event.isPrimary) return;
        this._lastInteraction = /** @type {'touch'|'mouse'|'pen'} */
        event.pointerType;
        this._pointerPressed = false;
      },
      pointercancel(event) {
        if (!event.isTrusted) return;
        if (!event.isPrimary) return;
        this._pointerPressed = this.stateTargetElement.matches(":active");
      },
      pointerleave(event) {
        if (!event.isTrusted) return;
        if (!event.isPrimary) return;
        this._pointerPressed = false;
        this._hovered = false;
      },
      "~keydown"(event) {
        if (!event.isTrusted) return;
        this._lastInteraction = "key";
        if (event.repeat) return;
        if (event.key !== " ") return;
        this._keyPressed = true;
      },
      "~keyup"(event) {
        if (!event.isTrusted) return;
        this._lastInteraction = "key";
        if (event.key !== " ") return;
        this._keyPressed = false;
        this._keyReleased = true;
        setTimeout(() => {
          this._keyReleased = false;
        });
      },
      blur(event) {
        if (!event.isTrusted) return;
        this._focused = false;
        this._focusedSynthetic = false;
        this._keyPressed = false;
        this._pointerPressed = false;
        if (!this._lastInteraction) return;
        lastInteractionWasTouch = this._lastInteraction === "touch";
        this._lastInteraction = null;
      },
      focus(event) {
        if (!event.isTrusted) return;
        this._focusedSynthetic = "sourceCapabilities" in event ? !event.sourceCapabilities : this._lastInteraction === null && !event.relatedTarget;
        this._focused = true;
        if (!this._lastInteraction && lastInteractionWasTouch) {
          this._lastInteraction = "touch";
        }
      }
    }).on({
      disconnected() {
        this._focused = false;
        this._keyPressed = false;
        this._pointerPressed = false;
        this._lastInteraction = null;
      }
    }).css`
      /* https://m3.material.io/foundations/interaction-states */

      :host {
        --mdw-state__hovered-opacity: 0.08;
        --mdw-state__focused-opacity: 0.12;
        --mdw-state__pressed-opacity: 0.12;
        --mdw-state__dragged-opacity: 0.12;
        position: relative;

        outline: none;
        -webkit-tap-highlight-color: transparent;
      }

      /* Remove Firefox inner */
      :host(::-moz-focus-inner) {
        border: 0;
      }

      #state {
        --mdw-state__opacity: calc(
          var(--mdw-state__hovered-opacity) +
          var(--mdw-state__focused-opacity) +
          var(--mdw-state__pressed-opacity) +
          var(--mdw-state__dragged-opacity)
        );

        position: absolute;
        inset: 0;

        pointer-events: none;

        opacity: var(--mdw-state__opacity);
        /* opacity handled by theme engine */
        background-color: currentColor;
        border-radius: inherit;

        transition-delay: 0ms;
        transition-duration: 000ms;
        transition-property: opacity, color, background-color;
        will-change: opacity;
      }

      /** Reduce RAM usage by not creating stack contexts */
      @supports(background-color: color-mix(in srgb, red calc(100%), red)) {
        #state {
          opacity: 1;

          background-color: color-mix(in srgb, currentColor calc(100% * var(--mdw-state__opacity)), transparent);

          transition-property: color, background-color;
          will-change: color, background-color;
        }
      }

      #state[touched] {
        --mdw-state__hovered-opacity: 0;
        --mdw-state__focused-opacity: 0;
      }

      /* Remove Hover State */
      #state:is(
      :not([hovered]),
      [disabled]:not([state-disabled~="hover"]),
      [state-off~="hover"]) {
        --mdw-state__hovered-opacity: 0;
      }

      /* Remove Focus State */
      #state:is(
      :not([focused]),
      [disabled]:not([state-disabled~="focus"]),
      [state-off~="focus"]) {
        --mdw-state__focused-opacity: 0;
      }

      /* Remove Pressed State */

      #state:is(
      :not([pressed]),
      [disabled]:not([state-disabled~="pressed"]),
      [state-off~="pressed"]) {
        --mdw-state__pressed-opacity: 0;
      }

      /* Remove Dragged State */
      :host(:not([aria-dragged="true"])) #state,
      #state:is(
        [disabled]:not([state-disabled~="dragged"]),
        [state-off~="dragged"]) {
        --mdw-state__dragged-opacity: 0;
      }

      /* Disabled */
      #state[disabled]:not([state-disabled]) {
        display: none;
      }

    `;
  }

  // services/theme.js
  var PALETTES = [
    "primary",
    "secondary",
    "tertiary",
    "error",
    "surface"
  ];
  var TYPE_STYLES = [
    "display",
    "headline",
    "title",
    "label",
    "body"
  ];

  // mixins/ThemableMixin.js
  var colorAttributeCSS = PALETTES.map((palette) => [
    `:host([color="${palette}"]){`,
    `--mdw-bg: var(--mdw-color__${palette});`,
    `--mdw-ink: var(--mdw-color__on-${palette});`,
    "}",
    `:host([color="${palette}-container"]){`,
    `--mdw-bg: var(--mdw-color__${palette}-container);`,
    `--mdw-ink: var(--mdw-color__on-${palette}-container);`,
    "}"
  ].join("")).join("");
  var inkAttributeCSS = PALETTES.map((palette) => [
    `:host([ink="${palette}"]){`,
    `--mdw-ink: var(--mdw-color__${palette});`,
    "}",
    `:host([ink="on-${palette}"]){`,
    `--mdw-ink: var(--mdw-color__on-${palette});`,
    "}",
    `:host([ink="on-${palette}-container"]){`,
    `--mdw-ink: var(--mdw-color__on-${palette}-container);`,
    "}"
  ].join("")).join("");
  var typeStyleAttributeCSS = TYPE_STYLES.map((typeStyle) => [
    `:host([type-style|="${typeStyle}"]) {`,
    `--mdw-type__font: var(--mdw-typescale__${typeStyle}-large__font);`,
    `--mdw-type__letter-spacing: var(--mdw-typescale__${typeStyle}-large__letter-spacing);`,
    "}",
    `:host([type-style="${typeStyle}-medium"]) {`,
    `--mdw-type__font: var(--mdw-typescale__${typeStyle}-medium__font);`,
    `--mdw-type__letter-spacing: var(--mdw-typescale__${typeStyle}-medium__letter-spacing);`,
    "}",
    `:host([type-style="${typeStyle}-small"]) {`,
    `--mdw-type__font: var(--mdw-typescale__${typeStyle}-small__font);`,
    `--mdw-type__letter-spacing: var(--mdw-typescale__${typeStyle}-small__letter-spacing);`,
    "}"
  ].join("")).join("");
  function ThemableMixin(Base) {
    return Base.observe({
      /**
       * Palette or surface token used to select background/ink tokens.
       * Examples: 'primary', 'background', 'surface-container-low'.
       */
      color: "string",
      /**
       * Explicit ink override token (e.g. 'outline', 'on-primary', 'inverse-on-surface', 'inherit').
       * Maps to `--mdw-ink`.
       */
      ink: "string",
      /**
       * Typographic style shortcut that maps to type scale variables
       * (e.g. 'headline-large', 'body-medium').
       */
      typeStyle: "string"
    }).css(colorAttributeCSS).css`
      :host([color="background"]) {
        --mdw-bg: var(--mdw-color__background);
        --mdw-ink: var(--mdw-color__on-background);
      }

      :host([color="surface-dim"]) {
        --mdw-bg: var(--mdw-color__surface-dim);
      }

      :host([color="surface-bright"]) {
        --mdw-bg: var(--mdw-color__surface-bright);
      }

      :host([color="surface-container-lowest"]) {
        --mdw-bg: var(--mdw-color__surface-container-lowest);
      }

      :host([color="surface-container-low"]) {
        --mdw-bg: var(--mdw-color__surface-container-low);
      }

      :host([color="surface-container-high"]) {
        --mdw-bg: var(--mdw-color__surface-container-high);
      }
      
      :host([color="surface-container-highest"]) {
        --mdw-bg: var(--mdw-color__surface-container-highest);
      }
      
      /* Quality-of-life */
      :host([color="surface-primary"]) {
        --mdw-bg: var(--mdw-color__surface);
        --mdw-ink: var(--mdw-color__primary);
      }
      
      :host([color$="variant"]) {
        --mdw-bg: var(--mdw-color__surface-container-highest);
        --mdw-ink: var(--mdw-color__on-surface-variant);
      }
      
      :host([color^="inverse"]) {
        --mdw-bg: var(--mdw-color__inverse-surface);
        --mdw-ink: var(--mdw-color__inverse-on-surface);
      }
      
      :host([color="inverse-primary"]) {
        --mdw-ink: var(--mdw-color__inverse-primary);
      }
      `.css(inkAttributeCSS).css`
      :host([ink="inverse-primary"]) {
        --mdw-ink: var(--mdw-color__inverse-primary);
      }

      :host([ink="outline"]) {
        --mdw-ink: var(--mdw-color__outline);
      }
      
      :host([ink="surface-container-highest"]) {
        --mdw-ink: var(--mdw-color__surface-container-highest);
      }
      
      :host([ink="on-surface-variant"]) {
        --mdw-ink: var(--mdw-color__on-surface-variant);
      }
      
      :host([ink="inverse-on-surface"]) {
        --mdw-ink: var(--mdw-color__inverse-on-surface);
      }
      
      :host([ink="inherit"]) {
        --mdw-ink: inherit;
      }
    `.css(typeStyleAttributeCSS);
  }

  // services/svgAlias.js
  var svgAliasMap = /* @__PURE__ */ new Map();
  var unaliased = /* @__PURE__ */ new Set();
  function addSVGAlias(name, path, viewBox = "0 0 24 24") {
    name = name.toLowerCase();
    if (path) {
      svgAliasMap.set(name, { path, viewBox });
    } else {
      svgAliasMap.delete(name);
    }
  }

  // components/Icon.js
  var documentLoadedStyleSheets = /* @__PURE__ */ new Set();
  var Icon_default = CustomElement.extend().mixin(ThemableMixin).define({
    _img() {
      return (
        /** @type {HTMLImageElement} */
        this.refs.img
      );
    }
  }).define({
    naturalWidth() {
      return this._img.naturalWidth;
    },
    naturalHeight() {
      return this._img.naturalHeight;
    },
    complete() {
      return this._img.complete;
    },
    currentSrc() {
      return this._img.currentSrc;
    },
    x() {
      return this._img.x;
    },
    y() {
      return this._img.y;
    },
    decode() {
      return this._img.decode;
    }
  }).observe({
    /** Icon name used with SVG aliases or font glyphs. */
    icon: "string",
    /** Whether the icon is disabled; affects image appearance. */
    disabled: "boolean",
    /** Alternative text for image-backed icons. */
    alt: "string",
    /** Image source URL for an icon. */
    src: "string",
    /** URL to an external SVG resource. */
    svg: "string",
    /** Inline SVG path data to render as the icon. */
    svgPath: "string",
    /** Image `srcset` attribute for responsive icon images. */
    srcset: "string",
    /** Image `sizes` attribute for responsive icon images. */
    sizes: "string",
    /** Variation suffix used when resolving icon aliases (e.g., 'filled'). */
    variation: "string",
    /** `crossorigin` attribute for image requests. */
    crossOrigin: { attr: "crossorigin" },
    /** `usemap` attribute for image maps. */
    useMap: { attr: "usemap" },
    /** `ismap` boolean attribute for image maps. */
    isMap: { type: "boolean", attr: "ismap" },
    /** `referrerpolicy` attribute for image requests. */
    referrerPolicy: { attr: "referrerpolicy" },
    /** Preferred image decoding mode: 'async' | 'sync' | 'auto'. */
    decoding: { value: (
      /** @type {'async'|'sync'|'auto'} */
      null
    ) },
    /** Image loading hint: 'eager' | 'lazy'. */
    loading: { value: (
      /** @type {'eager'|'lazy'} */
      null
    ) },
    /** Rendered width in CSS pixels. */
    width: "integer",
    /** Rendered height in CSS pixels. */
    height: "integer",
    /** Force using font glyphs instead of SVG when true. */
    forceFont: "boolean",
    _linkLoaded: "boolean",
    /** viewBox used for SVG rendering. */
    viewBox: "string",
    /** CSS class applied to font-based icons. */
    fontClass: { empty: "material-symbols-outlined" },
    /** URL to Material Symbols CSS when using font-based icons. */
    fontLibrary: { empty: "https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:FILL@0..1&display=block" },
    _isConnected: "boolean"
  }).observe({
    _svgAlias: {
      type: "object",
      get({ icon, variation }) {
        if (!icon) return null;
        const iconName = icon.trim().toLowerCase();
        const suffix = variation ? `#${variation}` : "";
        const aliasName = `${iconName}${suffix}`;
        if (svgAliasMap.has(aliasName)) {
          return svgAliasMap.get(aliasName);
        }
        unaliased.add(aliasName);
        if (suffix && svgAliasMap.has(iconName)) {
          return svgAliasMap.get(iconName);
        }
        return null;
      }
    }
  }).observe({
    _computedSVGPath({ svgPath, _svgAlias }) {
      return svgPath || (_svgAlias == null ? void 0 : _svgAlias.path);
    },
    _computedViewBox({ viewBox, _svgAlias }) {
      return viewBox ?? (_svgAlias == null ? void 0 : _svgAlias.viewBox) ?? "0 0 24 24";
    }
  }).observe({
    _showFontIcon: {
      type: "boolean",
      get({ icon, svg, _computedSVGPath, src }) {
        return icon && !svg && !_computedSVGPath && !src;
      }
    }
  }).expressions({
    showSVG({ svg, _computedSVGPath }) {
      return Boolean(svg || _computedSVGPath);
    }
  }).html`
    <link mdw-if={_showFontIcon} id=link rel=stylesheet href={fontLibrary} />
    <svg mdw-if="{showSVG}" id="svg" viewBox="{_computedViewBox}">
      <use id="use" mdw-if="{svg}" href="{svg}" fill="currentColor"/>
      <path id="path" mdw-if="{_computedSVGPath}" d="{_computedSVGPath}"/>
    </svg>
    <img mdw-if={src} id=img
      disabled={disabled}
      alt={alt} src={src} srcset={srcset} sizes={sizes}
      crossorigin={crossOrigin} usemap={useMap} ismap={isMap}
      referrerpolicy={referrerPolicy} decoding={decoding} loading={loading}
      width={width} height={height}
    />
    <span id=icon class={fontClass} hidden={!_showFontIcon} aria-hidden=true>{icon}</span>
  `.css`
    /* https://material.io/design/iconography/system-icons.html */

    :host {
      vertical-align: -11.5%;

      block-size: 1em;
      inline-size: 1em;

      -webkit-user-select: none;
      user-select: none;

      line-height: 1;

      font-variation-settings: 'FILL' 0;

      transition-duration: 200ms;
      /* stylelint-disable-next-line liberty/use-logical-spec -- Safari does not animate inline-size */
      transition-property: inline-size, width;
    }

    :host([variation="fill"]) {
      font-variation-settings: 'FILL' 1;
    }

    :host(:is([color],[ink])) {
      color: rgb(var(--mdw-ink));
    }

    #icon {
      /* Clip bounds in case font is not ready */
      overflow: clip;

      block-size: 1em;
      inline-size: 1em;

      font-size: inherit;
      font-variation-settings: inherit;

      transition-delay: 1ms;
      transition-duration: 200ms;

      transition-property: font-variation-settings;
    }

    #icon[hidden] {
      display: none;
    }

    #svg {
      block-size: inherit;
      inline-size: inherit;

      fill: currentColor;

      object-fit: cover;
    }

    #img {
      block-size: inherit;
      inline-size: inherit;

      object-fit: cover;

      transition-delay: 1ms;
      transition-duration: 200ms;
      transition-property: filter;
    }

    #img[disabled] {
      filter: grayscale();
    }

    .material-symbols-outlined {
      /* https://github.com/google/material-design-icons/issues/750 */
      direction: inherit;
    }

  `.childEvents({
    link: {
      /**
       * @param {{currentTarget: HTMLLinkElement}} event
       * @type {any}
       */
      load({ currentTarget }) {
        const { href, parentNode } = currentTarget;
        if (!parentNode) {
          console.warn("Icon: parentNode is blank");
        }
        if (documentLoadedStyleSheets.has(href)) return;
        for (const link of document.head.getElementsByTagName("link")) {
          if (link.href === href) {
            documentLoadedStyleSheets.add(href);
            return;
          }
        }
        document.head.append(currentTarget.cloneNode());
        documentLoadedStyleSheets.add(href);
      }
    }
  }).extend((BaseClass) => class extends BaseClass {
    /**
     * @param {number} [width]
     * @param {number} [height]
     */
    constructor(width, height) {
      super();
      if (width != null) {
        this.width = width;
      }
      if (height != null) {
        this.height = height;
      }
    }
  }).autoRegister("mdw-icon");

  // mixins/DensityMixin.js
  function DensityMixin(Base) {
    return Base.observe({
      /** Density level affecting spacing and compactness. Integer from -4 (dense) to 4 (spacious). */
      density: "integer"
    }).css`
      :host {
        --mdw-density: var(--mdw-density__default, 0);
      }
      
      /* Reset */
      :host([density]) { --mdw-density: 0; }
      
      :host([density="-1"]) { --mdw-density: -1; }
      :host([density="-2"]) { --mdw-density: -2; }
      :host([density="-3"]) { --mdw-density: -3; }
      :host([density="-4"]) { --mdw-density: -4; }
      :host([density="1"]) { --mdw-density: 1; }
      :host([density="2"]) { --mdw-density: 2; }
      :host([density="3"]) { --mdw-density: 3; }
      :host([density="4"]) { --mdw-density: 4; }
    `;
  }

  // mixins/ShapeMixin.js
  function ShapeMixin(Base) {
    return Base.observe({
      /** Show top cut/shape on the element */
      shapeTop: "boolean",
      /** Show bottom cut/shape on the element */
      shapeBottom: "boolean",
      /** Show start-side cut/shape (logical start) */
      shapeStart: "boolean",
      /** Show end-side cut/shape (logical end) */
      shapeEnd: "boolean",
      /** Predefined shape size/style name (none|extra-small|small|medium|large|extra-large|full|inherit) */
      shapeStyle: "string",
      /** When true, an outline is rendered around the element */
      outlined: "boolean"
    }).html`
      <div id=outline mdw-if={outlined} class=outline disabled={disabledState} focused={focusedState} pressed={pressedState} hovered={hoveredState}></div>
    `.css`
      :host {
        --mdw-shape__size: 0px;
        --mdw-shape__ltr: calc(0.5 * var(--mdw-dir, 1) + 0.5); /* 1 if LTR, 0 if RTL */
        --mdw-shape__rtl: calc(-0.5 * var(--mdw-dir, 1) + 0.5); /* 0 if LTR, 1 if RTL */

        /** By default, fallback to border-radius */
        --mdw-shape__inline-start-deg: calc(var(--mdw-dir, 1) * -90deg);

        --mdw-shape__size__top-start-size: var(--mdw-shape__size);
        --mdw-shape__size__top-end-size: var(--mdw-shape__size);
        --mdw-shape__size__bottom-start-size: var(--mdw-shape__size);
        --mdw-shape__size__bottom-end-size: var(--mdw-shape__size);
        /* (1/2n + 1/2)L + (-1/2n + 1/2)R  */
        
        --mdw-shape__size__top-left-size: calc((var(--mdw-shape__ltr) * var(--mdw-shape__size__top-start-size)) + (var(--mdw-shape__rtl) * var(--mdw-shape__size__top-end-size)));
        --mdw-shape__size__top-right-size: calc((var(--mdw-shape__rtl) * var(--mdw-shape__size__top-start-size)) + (var(--mdw-shape__ltr) * var(--mdw-shape__size__top-end-size)));
        --mdw-shape__size__bottom-left-size: calc((var(--mdw-shape__ltr) * var(--mdw-shape__size__bottom-start-size)) + (var(--mdw-shape__rtl) * var(--mdw-shape__size__bottom-end-size)));
        --mdw-shape__size__bottom-right-size: calc((var(--mdw-shape__rtl) * var(--mdw-shape__size__bottom-start-size)) + (var(--mdw-shape__ltr) * var(--mdw-shape__size__bottom-end-size)));
        z-index: 0;

        border-start-start-radius: calc(var(--mdw-shape__size__top-start-size));
        border-start-end-radius: calc(var(--mdw-shape__size__top-end-size));
        border-end-start-radius: calc(var(--mdw-shape__size__bottom-start-size));
        border-end-end-radius: calc(var(--mdw-shape__size__bottom-end-size));
      }

      :host([shape-style="none"]) {
        --mdw-shape__size: 0px;
      }
      
      :host([shape-style="extra-small"]) {
        --mdw-shape__size: var(--mdw-shape__extra-small);
      }
      
      :host([shape-style="small"]) {
        --mdw-shape__size: var(--mdw-shape__small);
      }
      
      :host([shape-style="medium"]) {
        --mdw-shape__size: var(--mdw-shape__medium);
      }
      
      :host([shape-style="large"]) {
        --mdw-shape__size: var(--mdw-shape__large);
      }
      
      :host([shape-style="extra-large"]) {
        --mdw-shape__size: var(--mdw-shape__extra-large);
      }
      
      :host([shape-style="full"]) {
        --mdw-shape__size: var(--mdw-shape__full);
      }
      
      :host([shape-style="inherit"]) {
        --mdw-shape__size: inherit;
      }
      
      :host([shape-top]) {
        --mdw-shape__size__bottom-start-size: 0px;
        --mdw-shape__size__bottom-end-size: 0px;
      }
      
      :host([shape-bottom]) {
        --mdw-shape__size__top-start-size: 0px;
        --mdw-shape__size__top-end-size: 0px;
      }
      
      :host([shape-start]) {
        --mdw-shape__size__top-end-size: 0px;
        --mdw-shape__size__bottom-end-size: 0px;
      }
      
      :host([shape-end]) {
        --mdw-shape__size__top-start-size: 0px;
        --mdw-shape__size__bottom-start-size: 0px;
      }
      
    `.css`
      .outline {
        position: absolute;
        inset: 0;

        overflow: hidden;

        border-style: solid;
        border-width: 1px;
      
        pointer-events: none;
      
        border-color: currentColor;
        border-radius: inherit;
        color: rgb(var(--mdw-color__outline));
      }
      
      .outline:is([pressed],[focused]) {
        color: rgb(var(--mdw-ink));
      
        transition-delay: 0;
        transition-duration: 0;
      }
      
      .outline[disabled] {
        color: rgba(var(--mdw-color__on-surface), 0.12);
      }
      
    `;
  }

  // mixins/TextFieldMixin.js
  function TextFieldMixin(Base) {
    return Base.mixin(DensityMixin).mixin(ShapeMixin).set({
      /** Show an internal visual state layer element */
      stateLayer: true
    }).observe({
      /** Input type (text, password, email, etc.) */
      type: { empty: "text" },
      /** Leading icon key/name to render inside the field */
      icon: "string",
      /** Variation of the icon display (e.g., filled) */
      iconVariation: "string",
      /** Floating label text for the field */
      label: "string",
      /** When true, use filled styling */
      filled: "boolean",
      /** When true, use outlined styling */
      outlined: "boolean",
      /** Prefix text shown before the input */
      inputPrefix: "string",
      /** Suffix text shown after the input */
      inputSuffix: "string",
      /** Trailing icon key/name */
      trailingIcon: "string",
      /** Ink/color token for the trailing icon */
      trailingIconInk: "string",
      /** Accessible label for the trailing icon */
      trailingIconLabel: "string",
      /** Supporting/helper text shown beneath the field */
      supporting: "string",
      /** Error message text */
      error: "string",
      /** Placeholder text (DOMString) */
      placeholder: { nullParser: String }
    }).observe({
      erroredState({ error, _invalid, _userInteracted }) {
        return _userInteracted && Boolean(error || _invalid);
      }
    }).expressions({
      computePlaceholder({ filled, outlined, label, placeholder }) {
        if (filled || outlined) return placeholder;
        return placeholder ?? label;
      },
      shouldShowSupporting({ erroredState, supporting }) {
        return erroredState || supporting != null;
      },
      computeSupportingText({ error, erroredState, _validationMessage, supporting }) {
        return (error || erroredState && _validationMessage || supporting) ?? "";
      },
      populatedState({ value, _badInput }) {
        return !!value || _badInput;
      },
      _showLabelText({ label, filled, outlined }) {
        return label && (filled || outlined);
      }
    }).expressions({
      _shapeShapeTop({ shapeTop, filled }) {
        return shapeTop || filled;
      },
      computedIconVariation({ iconVariation, outlined }) {
        return iconVariation ?? (outlined ? null : "filled");
      }
    }).html`
      <div id=shape role=none filled={filled} icon={icon} trailing-icon={trailingIcon}
      populated={populatedState} focused={focusedState} label={label} outlined={outlined}
      shape-top={_shapeShapeTop}>
        <mdw-icon mdw-if={icon} id=icon aria-hidden=true disabled={disabledState} icon={icon} variation={computedIconVariation}></mdw-icon>
        <div id=inline role=none filled={filled} icon={icon} trailing-icon={trailingIcon}
          populated={populatedState} focused={focusedState} label={label} outlined={outlined}>
          <span mdw-if={inputPrefix} class=inline id=prefix aria-hidden=true focused={focusedState} populated={populatedState}>{inputPrefix}</span>
          <span mdw-if={inputSuffix} class=inline id=suffix aria-hidden=true focused={focusedState} populated={populatedState}>{inputSuffix}</span>
        </div>
        <mdw-icon-button tabindex=-1 disabled={disabledState} mdw-if={trailingIcon} id=trailing-icon ink={trailingIconInk} disabled={disabledState} icon={trailingIcon}>{trailingIconLabel}</mdw-icon-button>
        <div mdw-if={filled} id=indicator aria-hidden=true focused={focusedState} hovered={hoveredState} errored={erroredState} disabled={disabledState}></div>
      </div>
      <div id=label-text mdw-if={_showLabelText} aria-hidden=true
        outlined={outlined}
        populated={populatedState}
        focused={focusedState}
        icon={icon}
        trailing-icon={trailingIcon}
        disabled={disabledState}
        errored={erroredState}>{label}</div>
      <div mdw-if={shouldShowSupporting} id=supporting disabled={disabledState} errored={erroredState}>
        {computeSupportingText}
        <slot id=supporting-slot name=supporting></slot>
      </div>
      
    `.recompose(({ html: html2, refs: { control, outline, state, shape, inline } }) => {
      control.setAttribute("placeholder", "{computePlaceholder}");
      control.setAttribute("aria-label", "{label}");
      control.setAttribute("input-suffix", "{inputSuffix}");
      control.setAttribute("errored", "{erroredState}");
      control.setAttribute("aria-describedby", "supporting");
      control.removeAttribute("aria-labelledby");
      control.classList.add("inline");
      state.setAttribute("mdw-if", "{!outlined}");
      outline.append(html2`
        <div id=outline-left class=outline-section focused={focusedState}></div>
        <div id=gap label={label} populated={populatedState} focused={focusedState}>
          <div id=gap-slot focused={focusedState}></div>
          <span id=gap-label>{label}</span>
        </div>
        <div id=outline-right class=outline-section focused={focusedState}></div>
      `);
      outline.setAttribute("label", "{label}");
      outline.setAttribute("errored", "{erroredState}");
      shape.prepend(outline, state);
      inline.prepend(control);
    }).on({
      // @ts-ignore TODO: Missing observable size property
      sizeChanged(oldValue, newValue) {
        const control = (
          /** @type {HTMLElement} */
          this.refs.control
        );
        control.style.setProperty("--size", `${newValue}ch`);
      }
    }).css`
      /* https://m3.material.io/components/text-fields/specs */

      /**
       * States:      Enabled            / Hover              / Focus              / Error              / Error Hover        / Error Focus
       * Input:       on-surface         / on-surface         / on-surface         / on-surface         / on-surface         / on-surface
       * Inline:      on-surface-variant / on-surface-variant / on-surface-variant / on-surface-variant / on-surface-variant / on-surface-variant
       * Label:       on-surface-variant / on-surface*        / ink                / error              / on-error-container / error
       * Indicator:   on-surface-variant / on-surface         / ink                / error              / on-error-container / error
       * Caret:       (any)              / (any)              / ink                / (any)              / (any)              / error
       * Outline:     outline            / on-surface         / ink                / error              / on-error-container / error
       * Selection:   on-*               / on-*               / ink                / error              / on-error-container / error
       *
       *
       * *Filled hovered unpopulated label may be on-surface-variant instead
       *
       * Input: Always on-surface
       * Inline: Always on-surface-variant
       * Indicator: same as label
       * Label: same as indicator
       * Outline: outline default, same as label+indicator on :hover or :focus
       * Caret: same as label+indicator+outline (cannot inherit color or use currentColor)
       * Selection:  (cannot inherit color or use currentColor)
       */

      :host {
        --mdw-shape__size: var(--mdw-shape__extra-small);
        /* --mdw-shape__size: 8px; */
        /* --mdw-shape__size__bottom-start-size: var(--mdw-shape__size); */
        /* --mdw-shape__size__bottom-end-size: var(--mdw-shape__size); */
        --mdw-text-field__ratio: calc(var(--mdw-density) * 0.125 + 1);

        --control__margin-top: calc(var(--mdw-typescale__body-small__line-height) / 2);
        --control__padding-top: calc((var(--mdw-text-field__ratio) * 16px) - calc(var(--mdw-typescale__body-small__line-height) / 2));
        --control__padding-bottom: calc(var(--mdw-text-field__ratio) * 16px);
        --control__margin-bottom: 0px;

        --inline-color: rgb(var(--mdw-color__on-surface-variant));

        --descriptor-opacity: 0.5;
        --mdw-ink: var(--mdw-color__primary);
        --mdw-bg: var(--mdw-color__surface-container-highest);

        --mdw-type__font: var(--mdw-typescale__body-large__font);
        --mdw-type__letter-spacing: var(--mdw-typescale__body-large__letter-spacing);

        display: inline-block;

        border-radius: 0;

        /* State layer */
        color: rgb(var(--mdw-color__on-surface));

        font: var(--mdw-type__font);
        letter-spacing: var(--mdw-type__letter-spacing);
      }

      :host(:is([color], [ink])) {
        background-color: transparent;
        color: rgb(var(--mdw-color__on-surface));
      }

      /** Guard against bleed */
      #shape[label][outlined] {
        --mdw-shape__size__top-start-size: min(var(--mdw-shape__size), 12px);
        --mdw-shape__size__bottom-start-size: min(var(--mdw-shape__size), 12px);
        --mdw-shape__size__top-end-size: min(var(--mdw-shape__size), 12px);
        --mdw-shape__size__bottom-end-size: min(var(--mdw-shape__size), 12px);
      }

      #shape {
        position: relative;

        display: flex;

        cursor: inherit;

        z-index: 0;

        background-color: transparent;

        border-start-start-radius: calc(var(--mdw-shape__size__top-start-size));
        border-start-end-radius: calc(var(--mdw-shape__size__top-end-size));
        border-end-start-radius: calc(var(--mdw-shape__size__bottom-start-size));
        border-end-end-radius: calc(var(--mdw-shape__size__bottom-end-size));

        font-weight: inherit;
        font-size: inherit;
        line-height: inherit;
        font-family: inherit;
        letter-spacing: inherit;

        transition: none 200ms cubic-bezier(0.0, 0.0, 0.2, 1);
      }

      #inline {
        display: flex;

        align-items: center;
        overflow: visible;

        flex: 1;
        padding-block: var(--control__margin-top) var(--control__margin-bottom);

        cursor: inherit;

        font-weight: inherit;
        font-size: inherit;
        line-height: inherit;
        font-family: inherit;
        letter-spacing: inherit;

        transition: none 200ms cubic-bezier(0.0, 0.0, 0.2, 1);
      }

      

      #shape:where([filled],[color]) {
        background-color: rgb(var(--mdw-bg));
        color: rgb(var(--mdw-color__on-surface));
      }

      #shape[outlined] {
        background-color: transparent;
      }

      #label-text,
      #indicator {
        color: rgb(var(--mdw-color__on-surface-variant))
      }

      :is(#label-text, #indicator)[focused] {
        color: rgb(var(--mdw-ink))
      }

      #shape[focused] {
        transition: none 100ms cubic-bezier(0.4, 0.0, 1, 1);
      }

      #shape[shape-top] {
        --mdw-shape__size__bottom-start-size: 0px;
        --mdw-shape__size__bottom-end-size: 0px;
      }

      #prefix,
      #suffix,
      #control::placeholder {
        opacity: var(--descriptor-opacity);

        color: var(--inline-color);

        transition-duration: inherit;
        transition-property: opacity;
        transition-timing-function: inherit;
        will-change: opacity;
      }

      :host([label]:is([filled],[outlined])) {
        --descriptor-opacity: 0;
      }

      #control {
        position: relative;
        inset: auto;
        align-self: flex-start;

        display: inline-block;

        box-sizing: border-box;

        block-size: auto;
        min-block-size: 0;
        inline-size: 100%;
        min-inline-size: 0;
        flex: 1;
        border-block-end: solid var(--control__margin-bottom) transparent;
        padding-block: var(--control__padding-top) var(--control__padding-bottom);

        appearance: none;
        caret-color: rgb(var(--mdw-ink));
        cursor: auto;

        transform: none;

        visibility: inherit;

        background-color: transparent;
        border-color: transparent;
        color: inherit;
        /* rgb(var(--mdw-color__on-surface)); */

        font-weight: inherit;
        font-size: inherit;
        line-height: inherit;
        font-family: inherit;
        letter-spacing: inherit;
        text-align: initial;

        transition-duration: inherit;
        transition-property: color;
        transition-timing-function: inherit;
      }

      #suffix,
      #prefix {
        /* Symmetrical to allow centering */
        padding-block: var(--control__padding-top) var(--control__padding-bottom);
      }

      /* stylelint-disable-next-line plugin/no-unsupported-browser-features */
      #control::selection {
        background-color: rgb(var(--mdw-ink));
        color: rgb(var(--mdw-color__surface));
      }

      #state {
        --mdw-state__focused-opacity: 0;
        --mdw-state__pressed-opacity: 0;
      }

      mdw-icon {
        --mdw-icon__size: 24px;
        align-self: center;

        color: var(--inline-color);
      }

      #icon {
        order: -2;

        margin-inline-start: 12px;

        font-size: 24px;
      }

      #prefix {
        order: -1;
      }

      #suffix {
        order: 1;
      }

      #trailing-icon {
        order: 2;

        /* stylelint-disable-next-line declaration-property-value-disallowed-list */
        margin-inline-end: 12px;
      }

      #indicator {
        position: absolute;
        inset-block-end: 0;
        inset-inline: 0;

        border-block-end: 2px solid currentColor;

        pointer-events: none;

        transform: scaleY(0.5);
        z-index: 1; /* Force new layer to avoid repaint */

        transition-duration: inherit;
        transition-property: transform;
        transition-timing-function: inherit;
        will-change: transform;
      }

      #indicator[focused] {
        transform: scaleY(1);

      }

      /** Label Text **/

      #label-text {
        position: absolute;
        inset-block-start: 0;
        inset-inline: 0;

        display: block;
        overflow-x: clip;
        overflow-y: visible;

        padding-inline: 16px;

        pointer-events: none;

        opacity: 1;
        transform: translateY(calc((var(--control__margin-top) + var(--control__padding-top) + 100% + var(--control__padding-bottom) + var(--control__margin-bottom)) / 2)) translateY(-50%);
        z-index: 4;
        /* FireFox bug */

        color: rgb(var(--mdw-color__on-surface-variant));

        text-overflow: ellipsis;
        white-space: nowrap;

        transition-duration: 200ms;
        transition-property: inset-inline-start, font-size, transform;
        /* transition-timing-function: inherit; */
        /*Expand*/

        will-change: inset-inline-start, font-size, transform;
      }

      @supports (-moz-appearance:none ) {
        #label-text {
          /* Firefox clips Y as well as X */
          overflow-x: hidden;
        }
      }

      #label-text[focused] {
        color: rgb(var(--mdw-ink));
      }

      #label-text[icon] {
        inset-inline-start: calc(12px + 24px);
      }

      #label-text[trailing-icon] {
        inset-inline-end: calc(24px + 12px);
      }

      #label-text:is([focused], [populated]) {
        transform: translateY(calc(var(--mdw-text-field__ratio) * 8px));

        font: var(--mdw-typescale__body-small__font);
        /* Not spec: Should only use font-size and line-height */
        letter-spacing: var(--mdw-typescale__body-small__letter-spacing);
      }

      #label-text[outlined]:is([focused], [populated]) {
        inset-inline: 0;

        transform: translateY(-50%);
      }

      :is(#prefix, #suffix):is([focused], [populated]) {
        opacity: 1;
      }

      /* If no label */
      #control:is(:focus, :not(:placeholder-shown))::placeholder {
        opacity: 0.70;
      }

      #control[input-suffix] {
        text-align: end;
      }

      /** Outlined **/

      #outline {
        position: absolute;
        inset: 0;

        border-style: solid;
        border-width: 0px;

        pointer-events: none;

        border-color: currentColor;
        border-radius: inherit;
        color: rgb(var(--mdw-color__outline));
      }

      #outline:is([pressed],[focused]) {
        color: rgb(var(--mdw-ink));

        transition-delay: 0;
        transition-duration: 0;
      }
      
      #outline[disabled] {
        color: rgba(var(--mdw-color__on-surface), 0.12);
      }

      #outline::before {
        content: none;
      }

      .outline-section {
        position: relative;

        border: 1px solid currentColor;
      }

      .outline-section[focused] {
        border-width: 2px;
      }

      #outline-left {
        /* stylelint-disable-next-line liberty/use-logical-spec */
        border-right-width: 0;
        /* stylelint-disable-next-line liberty/use-logical-spec */
        border-top-left-radius: inherit;
        /* stylelint-disable-next-line liberty/use-logical-spec */
        border-bottom-left-radius: inherit;
      }

      #outline-right {
        /* stylelint-disable-next-line liberty/use-logical-spec */
        border-left-width: 0;
        /* stylelint-disable-next-line liberty/use-logical-spec */
        border-top-right-radius: inherit;
        /* stylelint-disable-next-line liberty/use-logical-spec */
        border-bottom-right-radius: inherit;
      }

      #outline {
        display: grid;
        grid-auto-flow: column;
        grid-template-columns: 1fr 0 1fr;

        color: rgb(var(--mdw-color__outline));
      }

      #outline[label] {
        grid-template-columns: 12px minmax(0,auto) minmax(12px, 1fr);
      }

      #outline[hovered] {
        color: rgb(var(--mdw-color__on-surface));
      }

      #outline[focused] {
        color: rgb(var(--mdw-ink));
      }

      .outline-section {
        min-inline-size: 12px;
      }

      .outline-section::before,
      .outline-section::after {
        max-inline-size: none;
      }

      .outline-left {
        grid-column: calc(2 - var(--mdw-dir, 1)) / span 1; /* 1 on LTR, 3 on RTL */
      }

      .outline-right {
        grid-column: calc(2 + var(--mdw-dir, 1)) / span 1;
      }

      #gap {
        position: relative;

        display: inline-block;
        overflow: clip hidden;

        max-inline-size: 100%;
        grid-column: 2;

        font: var(--mdw-typescale__body-small__font);
        /* Not spec: Should only use font-size and line-height */
        letter-spacing: var(--mdw-typescale__body-small__letter-spacing);

        /* Close gap */
        transition-duration: inherit;
        transition-property: padding;
        transition-timing-function: inherit;
      }

      #gap-label {
        display: inline-block;
        overflow: clip hidden;

        padding-inline: 4px;

        color:transparent;

        white-space: nowrap;
      }

      #gap::after {
        content: '';

        position: absolute;
        inset: 0;

        border-block-end: solid 1px currentColor;
      }

      #gap[focused]::after {
        border-block-end-width: 2px;
      }

      #gap-slot {
        position: absolute;
        inset: 0;

      }

      #gap-slot::before,
      #gap-slot::after {
        content: '';

        position: absolute;
        inset: 0;

        border-block-start: solid 1px currentColor;

        transition: transform 200ms;
        will-change: transform;
      }

      #gap-slot[focused]::before,
      #gap-slot[focused]::after {
        border-block-start-width: 2px;
      }

      #gap-slot::before {
        /* stylelint-disable-next-line liberty/use-logical-spec */
        margin-right: -0.99px;

        transform: var(--gap-transform, scaleX(0.5));
        transform-origin: 0 0;
      }

      #gap-slot::after {
        /* stylelint-disable-next-line liberty/use-logical-spec */
        margin-left: -0.99px;

        transform: var(--gap-transform, scaleX(0.5));
        transform-origin: 100% 0;
      }

      #gap:is([focused], [populated]) {
        /* Open gap */
        --gap-transform: scaleX(0);
      }

      #gap:empty {
        padding: 0;
      }

      #inline[label][filled] {
        align-items: flex-start;
      }

      :host([filled]) {
        --mdw-shape__size__bottom-start-size: 0px;
        --mdw-shape__size__bottom-end-size: 0px;
        --mdw-text-field__ratio: calc(var(--mdw-density) * 0.25 + 1);
      }

      :host(:is([filled][label])) {
        --control__margin-top: calc((var(--mdw-text-field__ratio) * 8px) + var(--mdw-typescale__body-small__line-height));
        --control__padding-top: 0px;
        --control__padding-bottom: calc(var(--mdw-text-field__ratio) * 4px);
        --control__margin-bottom: calc(var(--mdw-text-field__ratio) * 4px);
      }

      #supporting {
        min-block-size: var(--mdw-typescale__body-small__line-height);
        margin-block-start: 4px;
        margin-inline: 16px;

        font-weight: var(--mdw-typescale__body-small__font-weight); /* Not spec */
        font-size: var(--mdw-typescale__body-small__font-size);
        line-height: var(--mdw-typescale__body-small__line-height);
        font-family: var(--mdw-typescale__body-small__font-family); /* Not spec */
        letter-spacing: var(--mdw-typescale__body-small__letter-spacing); /* Not spec */
      }

      /* Error States */

      #control[errored] {
        caret-color: rgb(var(--mdw-color__error));
      }

      #control[errored]::selection {
        background-color: rgb(var(--mdw-color__on-error-container));
      }

      :is(#indicator, #label-text, #supporting, #outline)[errored] {
        color: rgb(var(--mdw-color__error));
      }

      :is(#indicator, #label-text, #supporting, #outline)[errored]:where([hovered]) {
        color: rgb(var(--mdw-color__on-error-container));
      }

      :is(#indicator, #label-text, #supporting, #outline)[errored]:where([focused]) {
        color: rgb(var(--mdw-color__error));
      }

      /* stylelint-disable-next-line selector-max-compound-selectors */
      #shape[disabled],
      #shape[disabled] #control {
        cursor: not-allowed;
      }

      #outline[disabled] {
        color: rgba(var(--mdw-color__outline), 0.12);
      }

      #label-text[disabled] {
        color: rgba(var(--mdw-color__on-surface), 0.38);
      }

      #supporting[disabled] {
        color: rgba(var(--mdw-color__on-surface), 0.38);
      }

      .inline[disabled] {
        color: rgba(var(--mdw-color__on-surface), 0.38);
      }

      mdw-icon[disabled] {
        color: rgba(var(--mdw-color__on-surface), 0.38);
      }

      #shape[disabled] {
        background-color: rgba(var(--mdw-color__on-surface), calc(0.04));
        color: rgba(var(--mdw-color__on-surface), 0.38);
      }

      #indicator[disabled] {
        color: rgba(var(--mdw-color__on-surface), 0.38);
      }

      #shape[disabled][outlined] {
        background-color: transparent;
      }
    
    `;
  }

  // mixins/ElevationMixin.js
  function ElevationMixin(Base) {
    return Base.css`:host {

        /** Reference Properties */
        /*
        --mdw-surface__box-shadow__1__umbra: 0px 1px 2px 0px rgba(var(--mdw-color__shadow), 0.30);
        --mdw-surface__box-shadow__2__umbra: 0px 1px 2px 0px rgba(var(--mdw-color__shadow), 0.30);
        --mdw-surface__box-shadow__3__umbra: 0px 1px 3px 0px rgba(var(--mdw-color__shadow), 0.30);
        --mdw-surface__box-shadow__4__umbra: 0px 2px 3px 0px rgba(var(--mdw-color__shadow), 0.30);
        --mdw-surface__box-shadow__5__umbra: 0px 4px 4px 0px rgba(var(--mdw-color__shadow), 0.30);
      
        --mdw-surface__filter__0__umbra: drop-shadow(0px 1px 1px rgba(var(--mdw-color__shadow), 0));
        --mdw-surface__filter__1__umbra: drop-shadow(0px 1px 1px rgba(var(--mdw-color__shadow), 0.30));
        --mdw-surface__filter__2__umbra: drop-shadow(0px 1px 1px rgba(var(--mdw-color__shadow), 0.30));
        --mdw-surface__filter__3__umbra: drop-shadow(0px 1px 1.5px rgba(var(--mdw-color__shadow), 0.30));
        --mdw-surface__filter__4__umbra: drop-shadow(0px 2px 1.5px rgba(var(--mdw-color__shadow), 0.30));
        --mdw-surface__filter__5__umbra: drop-shadow(0px 4px 2px rgba(var(--mdw-color__shadow), 0.30));
      
        --mdw-surface__box-shadow__1__penumbra: 0px 1px 3px 1px  rgba(var(--mdw-color__shadow), 0.15);
        --mdw-surface__box-shadow__2__penumbra: 0px 2px 6px 2px  rgba(var(--mdw-color__shadow), 0.15);
        --mdw-surface__box-shadow__3__penumbra: 0px 4px 8px 3px  rgba(var(--mdw-color__shadow), 0.15);
        --mdw-surface__box-shadow__4__penumbra: 0px 6px 10px 4px rgba(var(--mdw-color__shadow), 0.15);
        --mdw-surface__box-shadow__5__penumbra: 0px 8px 12px 6px rgba(var(--mdw-color__shadow), 0.15);
      
        --mdw-elevation__filter__0__penumbra: drop-shadow(0px 1px 2.5px rgba(var(--mdw-color__shadow), 0));
        --mdw-elevation__filter__1__penumbra: drop-shadow(0px 1px 2.5px rgba(var(--mdw-color__shadow), 0.25));
        --mdw-elevation__filter__2__penumbra: drop-shadow(0px 2px 5px rgba(var(--mdw-color__shadow), 0.25));
        --mdw-elevation__filter__3__penumbra: drop-shadow(0px 4px 7px rgba(var(--mdw-color__shadow), 0.263));
        --mdw-elevation__filter__4__penumbra: drop-shadow(0px 6px 9px rgba(var(--mdw-color__shadow), 0.27));
        --mdw-elevation__filter__5__penumbra: drop-shadow(0px 8px 12px rgba(var(--mdw-color__shadow), 0.30));
      
        --mdw-elevation__filter__0: var(--mdw-surface__shadow__0__umbra) var(--mdw-surface__shadow__0__penumbra);
        --mdw-elevation__filter__1: var(--mdw-surface__shadow__1__umbra) var(--mdw-surface__shadow__1__penumbra);
        --mdw-elevation__filter__2: var(--mdw-surface__shadow__2__umbra) var(--mdw-surface__shadow__2__penumbra);
        --mdw-elevation__filter__3: var(--mdw-surface__shadow__3__umbra) var(--mdw-surface__shadow__3__penumbra);
        --mdw-elevation__filter__4: var(--mdw-surface__shadow__4__umbra) var(--mdw-surface__shadow__4__penumbra);
        --mdw-elevation__filter__5: var(--mdw-surface__shadow__5__umbra) var(--mdw-surface__shadow__5__penumbra);
        */

      --mdw-elevation__rgb: var(--mdw-color__shadow);

      --mdw-elevation__box-shadow__0: 0px 1px 1px 0px rgba(var(--mdw-elevation__rgb), 0.00), 0px 0px 1px 1px  rgba(var(--mdw-elevation__rgb), 0.00);
      --mdw-elevation__box-shadow__1: 0px 1px 2px 0px rgba(var(--mdw-elevation__rgb), 0.30), 0px 1px 3px 1px  rgba(var(--mdw-elevation__rgb), 0.15);
      --mdw-elevation__box-shadow__2: 0px 1px 2px 0px rgba(var(--mdw-elevation__rgb), 0.30), 0px 2px 6px 2px  rgba(var(--mdw-elevation__rgb), 0.15);
      --mdw-elevation__box-shadow__3: 0px 1px 3px 0px rgba(var(--mdw-elevation__rgb), 0.30), 0px 4px 8px 3px  rgba(var(--mdw-elevation__rgb), 0.15);
      --mdw-elevation__box-shadow__4: 0px 2px 3px 0px rgba(var(--mdw-elevation__rgb), 0.30), 0px 6px 10px 4px rgba(var(--mdw-elevation__rgb), 0.15);
      --mdw-elevation__box-shadow__5: 0px 4px 4px 0px rgba(var(--mdw-elevation__rgb), 0.30), 0px 8px 12px 6px rgba(var(--mdw-elevation__rgb), 0.15);

      --mdw-elevation__drop-shadow__0: drop-shadow(0px 1px 001px rgba(var(--mdw-elevation__rgb),000)) drop-shadow(0px 1px 2.5px rgba(var(--mdw-elevation__rgb),00000));
      --mdw-elevation__drop-shadow__1: drop-shadow(0px 1px 001px rgba(var(--mdw-elevation__rgb),0.3)) drop-shadow(0px 1px 2.5px rgba(var(--mdw-elevation__rgb),0.250));
      --mdw-elevation__drop-shadow__2: drop-shadow(0px 1px 001px rgba(var(--mdw-elevation__rgb),0.3)) drop-shadow(0px 2px 005px rgba(var(--mdw-elevation__rgb),0.250));
      --mdw-elevation__drop-shadow__3: drop-shadow(0px 1px 1.5px rgba(var(--mdw-elevation__rgb),0.3)) drop-shadow(0px 4px 007px rgba(var(--mdw-elevation__rgb),0.263));
      --mdw-elevation__drop-shadow__4: drop-shadow(0px 2px 1.5px rgba(var(--mdw-elevation__rgb),0.3)) drop-shadow(0px 6px 009px rgba(var(--mdw-elevation__rgb),0.270));
      --mdw-elevation__drop-shadow__5: drop-shadow(0px 4px 2.0px rgba(var(--mdw-elevation__rgb),0.3)) drop-shadow(0px 8px 012px rgba(var(--mdw-elevation__rgb),0.300));
    }`;
  }

  // utils/popup.js
  function canAnchorPopup(options) {
    let { pageX, pageY, directionX, directionY } = options;
    const pageWidth = document.documentElement.clientWidth;
    const pageHeight = document.documentElement.clientHeight;
    if (pageX == null || pageY == null) {
      const { clientX, clientY, anchor } = options;
      let rect;
      if (anchor) {
        rect = anchor instanceof Element ? anchor.getBoundingClientRect() : anchor;
      } else {
        rect = {
          left: 0,
          width: pageWidth,
          right: pageWidth,
          top: 0,
          bottom: pageHeight,
          height: pageHeight
        };
      }
      if (pageX == null) {
        switch (clientX) {
          case "left":
          case null:
          case void 0:
            pageX = rect.left;
            directionX ??= "right";
            break;
          case "center":
            pageX = rect.left + rect.width / 2;
            directionX ??= "center";
            break;
          case "right":
            pageX = rect.right;
            directionX ??= "left";
            break;
          default:
            pageX = rect.left + clientX;
        }
      }
      if (pageY == null) {
        switch (clientY) {
          case "top":
            pageY = rect.top;
            directionY ??= "up";
            break;
          case "center":
            pageY = rect.top + rect.height / 2;
            directionY ??= "center";
            break;
          case "bottom":
          case null:
          case void 0:
            pageY = rect.bottom;
            directionY ??= "down";
            break;
          default:
            pageY = rect.top + clientY;
        }
      }
    }
    let { width, height } = options;
    if (width == null || height == null) {
      const { popup } = options;
      if (popup instanceof Element) {
        width = popup.clientWidth;
        height = popup.clientHeight;
      } else {
        width = popup.width;
        height = popup.height;
      }
    }
    let top;
    let right;
    let bottom;
    let left;
    const margin = options.margin ?? 0;
    let pageTop = margin;
    let pageBottom = -margin;
    let pageLeft = margin;
    let pageRight = -margin;
    if (window.visualViewport) {
      pageTop += window.visualViewport.offsetTop;
      pageBottom += window.visualViewport.offsetTop + window.visualViewport.height;
      pageLeft += window.visualViewport.offsetLeft;
      pageRight += window.visualViewport.offsetLeft + window.visualViewport.width;
    } else {
      pageBottom += pageHeight;
      pageRight += pageWidth;
    }
    const offsetX = options.offsetX ?? 0;
    const offsetY = options.offsetY ?? 0;
    pageX += offsetX;
    pageY += offsetY;
    let cssTop = "auto";
    let cssRight = "auto";
    let cssBottom = "auto";
    let cssLeft = "auto";
    let maxHeight = null;
    let maxWidth = null;
    switch (directionY) {
      case "up":
        bottom = Math.min(pageY, pageBottom);
        top = Math.max(bottom - height, pageTop);
        cssBottom = `${pageHeight - bottom}px`;
        if (top === pageTop) {
          maxHeight = `${bottom - pageTop}px`;
        }
        break;
      case "center":
        top = Math.max(pageY - height / 2, pageTop);
        bottom = Math.min(pageY + height / 2, pageBottom);
        cssTop = `${top}px`;
        if (bottom === pageBottom) {
          maxHeight = `${pageBottom - pageTop}px`;
        }
        break;
      default:
        top = Math.max(pageY, pageTop);
        bottom = Math.min(top + height, pageBottom);
        cssTop = `${top}px`;
        if (bottom === pageBottom) {
          maxHeight = `${pageBottom - top}px`;
        }
    }
    switch (directionX) {
      case "left":
        right = Math.min(pageX, pageRight);
        left = Math.max(right - width, pageLeft);
        cssRight = `${pageWidth - right}px`;
        if (left === pageLeft) {
          maxWidth = `${right - pageLeft}px`;
        }
        break;
      case "center":
        left = Math.max(pageX - width / 2, pageLeft);
        right = Math.min(pageX + width / 2, pageRight);
        cssLeft = `${left}px`;
        if (right === pageRight) {
          maxWidth = `${pageRight - pageLeft}px`;
        }
        break;
      default:
        left = Math.max(pageX, pageLeft);
        right = Math.min(left + width, pageRight);
        cssLeft = `${left}px`;
        if (right === pageRight) {
          maxWidth = `${pageRight - left}px`;
        }
    }
    const fullSize = width * height;
    const realSize = (bottom - top) * (right - left);
    const visibility = realSize / fullSize;
    const transformOriginX = directionX === "center" ? "center" : directionX === "left" ? "right" : "left";
    const transformOriginY = directionY === "center" ? "center" : directionY === "up" ? "bottom" : "top";
    return {
      ...options,
      top,
      right,
      bottom,
      left,
      visibility,
      styles: {
        top: cssTop,
        bottom: cssBottom,
        left: cssLeft,
        right: cssRight,
        maxWidth,
        maxHeight,
        transformOrigin: `${transformOriginY} ${transformOriginX}`
      }
    };
  }

  // components/Scrim.js
  var Scrim_default = CustomElement.extend().observe({
    /** When true the scrim is hidden and will be removed after its fade-out animation. */
    hidden: "boolean"
  }).html`<div id=scroll-blocker></div>`.css`
    :host {
      position: fixed;
      inset: 0;

      display: block;
      overflow: overlay;

      overscroll-behavior: none;
      overscroll-behavior: contain;
      scrollbar-color: transparent transparent;
      scrollbar-width: none;

      cursor: pointer;

      outline: none; /* Older Chromium Builds */
      
      -webkit-tap-highlight-color: transparent;

      opacity: 0;

      z-index: 23;

      background-color: rgb(var(--mdw-color__scrim));
      
      animation: fade-in 200ms forwards ease-out;
      will-change: opacity;
    }

    :host::-webkit-scrollbar {
      display: none;
    }

    :host([hidden]) {
      animation-name: fade-out;
      animation-timing-function: ease-in;
    }

    :host([invisible]) {
      background: transparent;
    }

    #scroll-blocker {
      position: absolute;
      inset-block-start: 0;
      inset-inline-start: 0;

      display: block;

      block-size: 200%;
      inline-size: 200%;
    }

    @keyframes fade-in {
      from {
        opacity: 0;
      }

      to {
        opacity: 0.38;
      }
    }

    @keyframes fade-out {
      from {
        opacity: 0.38;
      }

      to {
        opacity: 0;
      }
    }
  `.events({
    animationend() {
      if (this.hidden) {
        this.remove();
      }
    }
  }).autoRegister("mdw-scrim");

  // mixins/PopupMixin.js
  var supportsHTMLDialogElement = typeof HTMLDialogElement !== "undefined";
  var OPEN_POPUPS = [];
  function onWindowResize() {
    for (const { element } of OPEN_POPUPS) {
      element.updatePopupPosition();
    }
  }
  function onNavMouseDown(event) {
    if (event.button === 3) {
      event.preventDefault();
    }
  }
  function onPopState(event) {
    if (!event.state) return;
    const lastOpenPopup = OPEN_POPUPS.at(-1);
    if (!lastOpenPopup || !lastOpenPopup.previousState) {
      return;
    }
    if (lastOpenPopup.previousState === event.state || Object.keys(event.state).every((key) => event.state[key] === lastOpenPopup.previousState[key])) {
      const cancelEvent = new Event("cancel", { cancelable: true });
      if (lastOpenPopup.element.dispatchEvent(cancelEvent)) {
        lastOpenPopup.element.close();
      } else {
        window.history.pushState(lastOpenPopup.state, lastOpenPopup.state.title);
      }
    }
  }
  function onBeforeUnload(event) {
    if (!OPEN_POPUPS.length) return;
    console.warn("Popup was open during page unload (refresh?).");
  }
  function PopupMixin(Base) {
    return Base.mixin(DelegatesFocusMixin).mixin(ResizeObserverMixin).observe({
      /** Whether the popup is currently open */
      open: "boolean",
      /** When true the popup behaves as a blocking modal */
      modal: "boolean",
      /** Use the native HTMLDialogElement when available */
      native: "boolean",
      /** Allow internal content to scroll when true */
      scrollable: "boolean",
      /** When true, match the popup width to the source element */
      matchSourceWidth: "boolean",
      /** Internal: current resolved flow used for positioning */
      _currentFlow: "string",
      flow: {
        type: "string",
        /** @type {'corner'|'adjacent'|'overflow'|'vcenter'|'hcenter'|'center'} */
        value: null
      },
      /** Margin between popup and viewport/anchor (px) */
      popupMargin: "float"
    }).set({
      /** Whether to push/pop history entries when opening the popup */
      useHistory: true,
      /** Optional return value for dialog-like popups */
      returnValue: "",
      /** Internal: true while closing is in-progress */
      _closing: false,
      /** Internal: whether to show a scrim (overlay) for modal popups */
      _useScrim: false,
      /**
       * Source that triggered the popup
       * @type {MouseEvent|PointerEvent|HTMLElement|Event}
       */
      _source: null,
      /**
       * Anchor used for positioning
       * @type {MouseEvent|PointerEvent|HTMLElement|Event}
       */
      _anchor: null
    }).define({
      _dialog() {
        return (
          /** @type {HTMLDialogElement} */
          this.refs.dialog
        );
      }
    }).expressions({
      _ariaHidden({ open }) {
        return open ? "false" : "true";
      }
    }).methods({
      /**
       * @param {DOMRectLike|Element} [anchor]
       * @return {void}
       */
      updatePopupPosition(anchor = this._anchor) {
        const flow = this._currentFlow ?? this.flow;
        Object.assign(this.style, {
          top: "0",
          left: "0",
          right: "auto",
          bottom: "auto",
          maxWidth: null,
          maxHeight: null
        });
        const layoutElement = this.native ? this._dialog : this;
        Object.assign(layoutElement.style, { width: "auto", height: "auto" });
        const width = anchor && this.matchSourceWidth ? (
          /** @type {Element} */
          anchor.clientWidth
        ) : 56 * Math.ceil(layoutElement.clientWidth / 56);
        layoutElement.style.setProperty("width", `${width}px`);
        const height = layoutElement.clientHeight;
        Object.assign(layoutElement.style, { height: null });
        const anchorOptions = {
          anchor,
          width,
          height,
          margin: this.popupMargin ?? (window.innerWidth < 648 ? 16 : 24)
        };
        const isPageRTL = isRtl(this);
        const xStart = isPageRTL ? "right" : "left";
        const xEnd = isPageRTL ? "left" : "right";
        const preferences = (
          /** @type {import('../utils/popup.js').CanAnchorPopUpOptions[]} */
          [
            (flow ?? "corner") === "corner" ? [
              { clientY: "bottom", clientX: xStart },
              { clientY: "bottom", clientX: xEnd },
              { clientY: "top", clientX: xStart },
              { clientY: "top", clientX: xEnd }
            ] : [],
            (flow ?? "adjacent") === "adjacent" ? [
              { clientY: "top", clientX: xEnd, directionX: xEnd, directionY: "down" },
              { clientY: "top", clientX: xStart, directionX: xStart, directionY: "down" },
              { clientY: "bottom", clientX: xEnd, directionX: xEnd, directionY: "up" },
              { clientY: "bottom", clientX: xStart, directionX: xStart, directionY: "up" }
            ] : [],
            (flow ?? "overlay") === "overlay" ? [
              { clientY: "top", clientX: xStart, directionX: xEnd, directionY: "down" },
              { clientY: "top", clientX: xEnd, directionX: xStart, directionY: "down" },
              { clientY: "bottom", clientX: xStart, directionX: xEnd, directionY: "up" },
              { clientY: "bottom", clientX: xEnd, directionX: xStart, directionY: "up" }
            ] : [],
            (flow ?? "vcenter") === "vcenter" ? [
              { clientY: "center", clientX: xEnd, directionX: xEnd, directionY: "center" },
              { clientY: "center", clientX: xStart, directionX: xStart, directionY: "center" }
            ] : [],
            (flow ?? "hcenter") === "hcenter" ? [
              { clientY: "bottom", clientX: "center", directionX: "center", directionY: "down" },
              { clientY: "top", clientX: "center", directionX: "center", directionY: "up" }
            ] : [],
            (flow ?? "center") === "center" ? [
              { clientY: "center", clientX: "center", directionX: "center", directionY: "center" }
            ] : []
          ].flat()
        );
        let anchorResult;
        for (const preference of preferences) {
          const result = canAnchorPopup({
            ...anchorOptions,
            ...preference
          });
          if (!anchorResult || anchorResult.visibility < result.visibility) {
            anchorResult = result;
          }
          if (result.visibility === 1) break;
        }
        let { maxWidth, maxHeight } = anchorResult.styles;
        if (maxWidth || maxHeight) {
          const styles = window.getComputedStyle(this);
          if (styles.maxWidth) {
            maxWidth = `min(${maxWidth}, ${styles.maxWidth})`;
          }
          if (styles.maxHeight) {
            maxHeight = `min(${maxHeight}, ${styles.maxHeight})`;
          }
        }
        Object.assign(this.style, { ...anchorResult.styles, maxWidth, maxHeight });
      },
      /**
       * @param {Event & {currentTarget: HTMLSlotElement}} event
       * @return {void}
       */
      onSlotChange({ currentTarget }) {
        const nodes = currentTarget.assignedNodes();
        const hasContent = nodes.some((node) => node.nodeType === node.ELEMENT_NODE || node.nodeType === node.TEXT_NODE && node.nodeValue.trim().length);
        currentTarget.toggleAttribute("slotted", hasContent);
      },
      /**
       * @param {MouseEvent|PointerEvent|HTMLElement|Event} [source]
       * @param {boolean} focus
       * @param {string} flow
       * @return {boolean} handled
       */
      showPopup(source, focus = true, flow = null) {
        if (this.open) return false;
        this.open = true;
        this._source = source;
        this._anchor = source;
        const { scrim } = this.refs;
        if (this._useScrim) {
          if (this.native) {
            document.body.append(scrim);
          } else {
            this.before(scrim);
          }
          scrim.hidden = false;
        } else {
          scrim.remove();
        }
        const previousFocus = source instanceof HTMLElement ? source : (
          /** @type {HTMLElement} */
          document.activeElement
        );
        if (supportsHTMLDialogElement && focus && !this._dialog.open) {
          this._dialog.show();
        }
        this._currentFlow = flow;
        this.updatePopupPosition(source);
        let newState;
        let scrollRestoration;
        let previousState;
        if (this.useHistory) {
          newState = { hash: Math.random().toString(36).slice(2, 18) };
          if (!window.history.state) {
            window.history.replaceState({
              hash: Math.random().toString(36).slice(2, 18)
            }, document.title);
          }
          previousState = window.history.state;
          scrollRestoration = window.history.scrollRestoration;
          window.history.scrollRestoration = "manual";
          window.history.pushState(newState, document.title);
          window.addEventListener("popstate", onPopState);
          window.addEventListener("beforeunload", onBeforeUnload);
        }
        window.addEventListener("mousedown", onNavMouseDown, { capture: true });
        window.addEventListener("resize", onWindowResize);
        window.addEventListener("scroll", onWindowResize);
        if (window.visualViewport) {
          window.visualViewport.addEventListener("resize", onWindowResize);
          window.visualViewport.addEventListener("scroll", onWindowResize);
        }
        OPEN_POPUPS.push({
          element: this,
          previousFocus,
          state: newState,
          previousState,
          scrollRestoration
        });
        if (focus) {
          this.focus();
        }
        return true;
      },
      /**
       * @param {MouseEvent|PointerEvent|HTMLElement|Event} [source]
       * @param {boolean} [focus]
       * @param {string} [flow]
       * @return {boolean} handled
       */
      showModal(source, focus, flow) {
        if (this.open) return false;
        this.modal = true;
        if (supportsHTMLDialogElement) {
          this._dialog.showModal();
          this.native = true;
        }
        return this.showPopup(source, focus, flow);
      },
      /**
       * @param {MouseEvent|PointerEvent|HTMLElement|Event} [source]
       * @param {boolean} [focus]
       * @param {string} [flow]
       * @return {boolean} handled
       */
      show(source, focus, flow) {
        if (navigator.userAgent.includes("Mac OS X")) {
          return this.showModal(source, focus, flow);
        }
        return this.showPopup(source, focus, flow);
      },
      /**
       * @param {any} [returnValue]
       * @param {boolean} [returnFocus=true]
       * @return {boolean} handled
       */
      close(returnValue = void 0, returnFocus = true) {
        var _a5, _b, _c;
        if (!this.open) return false;
        if (this._closing) return false;
        this._source = null;
        this._closing = true;
        this.modal = false;
        this.refs.scrim.hidden = true;
        if (this.native) {
          this.native = false;
        } else {
          const main = document.querySelector("main");
          if (main) {
            main.removeAttribute("aria-hidden");
          }
        }
        if (supportsHTMLDialogElement && this._dialog.open) {
          const previousFocus = document.activeElement;
          this._dialog.close();
          if (!attemptFocus(previousFocus, { preventScroll: true })) {
            const currentlyFocused = (
              /** @type {SVGElement|HTMLElement} */
              document.activeElement
            );
            (_a5 = currentlyFocused == null ? void 0 : currentlyFocused.blur) == null ? void 0 : _a5.call(currentlyFocused);
          }
        } else {
          this._dialog.returnValue = returnValue;
        }
        this.open = false;
        this._currentFlow = null;
        this.dispatchEvent(new Event("close"));
        const len = OPEN_POPUPS.length;
        for (let i = len - 1; i >= 0; i--) {
          const entry = OPEN_POPUPS[i];
          if (entry.element === this) {
            if (this.useHistory) {
              if (entry.state && window.history && window.history.state && entry.state.hash === window.history.state.hash) {
                window.removeEventListener("popstate", onPopState);
                window.history.back();
                window.history.replaceState(entry.previousState, document.title);
                window.history.scrollRestoration = entry.scrollRestoration || "auto";
                window.addEventListener("popstate", onPopState);
              } else {
                console.warn("Menu state mismatch?", entry, window.history.state);
              }
            }
            if (returnFocus) {
              (_c = (_b = entry.previousFocus) == null ? void 0 : _b.focus) == null ? void 0 : _c.call(_b, { preventScroll: true });
            }
            OPEN_POPUPS.splice(i, 1);
            break;
          } else if (this.contains(entry.element)) {
            entry.element.close(false);
          }
        }
        if (!OPEN_POPUPS.length) {
          window.removeEventListener("popstate", onPopState);
          window.removeEventListener("beforeunload", onBeforeUnload);
          window.removeEventListener("resize", onWindowResize);
          window.removeEventListener("mousedown", onNavMouseDown, { capture: true });
        }
        this._closing = false;
        return true;
      }
    }).overrides({
      onResizeObserved(entry) {
        if (!this.open || this._closing) return;
        this.updatePopupPosition();
      }
    }).html`
      <mdw-scrim id=scrim tabindex=-1 aria-hidden=true></mdw-scrim>
      <dialog id=dialog aria-modal=true role=dialog
      aria-hidden={_ariaHidden} scrollable={scrollable}>
        <slot id=slot on-slotchange={onSlotChange}></slot>
      </dialog>
    `.css`
    /* https://m3.material.io/components/dialogs/specs */

    :host([popover]) {
      margin: 0;
      border: 0;
      padding: 0;
    }

    :host(::backdrop) {
      display: none;
    }

    :host {
      --mdw-popup__expand-duration: var(--mdw-motion-expand-duration, 250ms);
      --mdw-popup__simple-duration: var(--mdw-motion-simple-duration, 100ms);
      --mdw-popup__standard-easing: var(--mdw-motion-standard-easing, cubic-bezier(0.4, 0.0, 0.2, 1));
      --mdw-popup__deceleration-easing: var(--mdw-motion-deceleration-easing, cubic-bezier(0.0, 0.0, 0.2, 1));
      --mdw-popup__fade-in-duration: var(--mdw-motion-fade-in-duration, 150ms);

      --mdw-shape__size: 28px;

      /* padding-inline: 12px; */

      --mdw-bg: var(--mdw-color__surface);
      --mdw-ink: var(--mdw-color__on-surface);

      position: fixed;

      inset-block-start: 0;
      inset-inline-start: 0;
      align-self: center;
      justify-self: center;

      display: block;
      overflow: auto;
      -webkit-overflow-scrolling: touch;
      overscroll-behavior: none;
      overscroll-behavior: contain;

      box-sizing: border-box;
      block-size: auto;
      min-block-size: none;
      max-block-size: 100vh;
      inline-size: auto;
      min-inline-size: none;
      max-inline-size: 100vw;

      outline: none; /* Older Chromium Builds */

      pointer-events: none;

      opacity: 0;
      transform: scale(0);

      visibility: hidden;
      z-index: 24;

      color: rgb(var(--mdw-ink));

      font: var(--mdw-type__font);
      letter-spacing: var(--mdw-type__letter-spacing);

      transition-delay: 200ms, 0s;
      transition-duration: 0s, 200ms, 200ms;
      transition-property: visibility, opacity, transform;
      transition-timing-function: ease-out;

      will-change: visibility, opacity, transform;

    }

    :host([open]) {
      pointer-events: inherit;

      opacity: 1;

      transform: none;
      visibility: inherit;

      transition-delay: 0s;
      transition-timing-function: ease-in;
    }

    :host([native][open]) {
      opacity: 0;
    }

    #dialog {
      position: static;
      inset-block-start: 0;
      inset-inline-start: 0;

      display: contents;
      align-items: inherit;
      flex-direction: inherit;
      gap: inherit;
      justify-content: inherit;
      justify-items: inherit;
      place-items: inherit;

      box-sizing: border-box;
      block-size: inherit;
      flex: inherit;
      margin:0;
      border: none;
      padding: inherit;
      padding: 0;

      pointer-events: inherit;

      filter: inherit;

      opacity: 1;

      transform:inherit;
      visibility: inherit;
      /* visiblity:hidden still registers events, hide from pointer with scale(0) */
      z-index: 24;

      background-color: transparent;

      color:inherit;
      
    }

    :host([color]) {
      background-color: rgb(var(--mdw-bg));
      color: rgb(var(--mdw-ink));
    }

    :host(:is([color="none"],[color="transparent"])) {
      background-color: transparent;
      color: inherit;
    }

    :host([scrollable]) {
      overflow-y:auto;
    }

    #dialog::backdrop {
      /** Use scrim instead */
      background-color: transparent;
    }

    #dialog:modal {
      position: inherit;
      inset: inherit;

      display: inherit;
      align-items: inherit;
      flex-direction: inherit;
      gap: inherit;
      justify-content: inherit;
      justify-items: inherit;
      place-items: inherit;

      block-size: auto;
      min-block-size: inherit;
      max-block-size: inherit;

      inline-size:auto;
      min-inline-size: inherit;
      max-inline-size: inherit;
      flex: inherit;
      padding: inherit;

      pointer-events: inherit;

      filter: inherit;
      transform: inherit;
      visibility: inherit;

      background-color: inherit;
      border-radius: inherit;
    }

    #dialog[scrollable][open] {
      display: inherit;
      align-items: inherit;
      flex-direction: inherit;
      gap: inherit;
      justify-content: inherit;
      justify-items: inherit;
      
      place-items: inherit;

      block-size: 100%;
      max-block-size: none;
      inline-size: 100%;
      max-inline-size: none;

      flex: 1;
    }

    

    #dialog[scrollable][open]:modal {
      overflow:auto;

      block-size:100%;
      min-block-size: none;
      max-block-size: inherit;
      inline-size:100%;
      min-inline-size: none;
      max-inline-size: inherit;
      flex: inherit;
      padding: inherit;
    }

    
  `.childEvents({
      dialog: {
        cancel(event) {
          event.stopPropagation();
          const cancelEvent = new Event("cancel", { cancelable: true });
          if (!this.dispatchEvent(cancelEvent)) {
            event.preventDefault();
          }
        },
        close(event) {
          event.stopPropagation();
          this.close(this.returnValue);
        },
        "~click"(event) {
          if (event.target !== event.currentTarget) return;
          if (!this.native) return;
          if (event.offsetX >= 0 && event.offsetX < event.currentTarget.offsetWidth && event.offsetY >= 0 && event.offsetY < event.currentTarget.offsetHeight) return;
          const cancelEvent = new Event("cancel", { cancelable: true });
          if (!this.dispatchEvent(cancelEvent)) return;
          this.close();
        }
      },
      scrim: {
        "~click"() {
          const cancelEvent = new Event("cancel", { cancelable: true });
          if (!this.dispatchEvent(cancelEvent)) return;
          this.close();
        }
      }
    });
  }

  // components/Popup.js
  var Popup_default = CustomElement.extend().mixin(ThemableMixin).mixin(ElevationMixin).mixin(ShapeMixin).mixin(PopupMixin).observe({
    /** Elevation level (05) controlling the drop-shadow depth of the popup. */
    elevation: "integer"
  }).css`
    :host {
      filter: var(--mdw-elevation__drop-shadow__0);

      transition: filter 200ms;
    }

    :host(:where([elevation="1"])) { filter: var(--mdw-elevation__drop-shadow__1); }
    :host(:where([elevation="2"])) { filter: var(--mdw-elevation__drop-shadow__2); }
    :host(:where([elevation="3"])) { filter: var(--mdw-elevation__drop-shadow__3); }
    :host(:where([elevation="4"])) { filter: var(--mdw-elevation__drop-shadow__4); }
    :host(:where([elevation="5"])) { filter: var(--mdw-elevation__drop-shadow__5); }
  `.autoRegister("mdw-popup");

  // components/Input.js
  var sharedPopup;
  function getSharedPopup() {
    if (!sharedPopup) {
      sharedPopup = new Popup_default();
      sharedPopup.scrollable = true;
      sharedPopup.shapeStyle = "extra-small";
      sharedPopup.color = "surface";
      sharedPopup.matchSourceWidth = true;
      sharedPopup.flow = "corner";
      sharedPopup.elevation = 2;
    }
    return sharedPopup;
  }
  var Input_default = CustomElement.extend().mixin(ThemableMixin).mixin(StateMixin).mixin(InputMixin).mixin(TextFieldMixin).mixin(ResizeObserverMixin).observe({
    /**
     * When true, the component inserts the best suggestion into the input field
     * as inline text. The appended portion of the suggestion is selected so the
     * user can accept it (e.g. press Enter) or continue typing to replace it.
     * Typically combined with `autosuggestInline` to display candidates while
     * typing.
     * @see https://w3c.github.io/aria/#aria-autocomplete
     */
    autocompleteInline: "boolean",
    /**
     * When set and not `'custom'`, `applyAutocompleteList()` filters the
     * listbox options to items that start * with the typed text. This controls
     * dropdown filtering but does not itself cause inline insertion.
     * @see https://w3c.github.io/aria/#aria-autocomplete
     */
    autocompleteList: "string",
    /**
     * When true, the component advances/searches suggestion candidates as the
     * user types (calls `changeSuggestion({ startsWith })`). If
     * `autosuggestInline` is true and `autocompleteInline` is also true the
     * current candidate will be shown inline; if `autocompleteInline` is false
     * only the candidate selection changes (no inline text insertion).
     */
    autosuggestInline: "boolean",
    /** If true, when listbox is open, arrow navigation will automatically select options. */
    autoSelect: "boolean",
    /** True when the listbox popup is currently expanded. */
    _expanded: "boolean",
    /** If true, when listbox is open, <Esc> accepts current suggestion (same as Enter). */
    acceptOnEscape: "boolean",
    _listbox: {
      type: "object",
      /** @type {InstanceType<Listbox>} */
      value: null
    },
    /** Currently focused suggestion value in the listbox. */
    _focusedValue: "string",
    /** Focus position in set (1-based) for aria-posinset. */
    _focusedPosInSet: { value: -1 },
    /** Computed size of the listbox (number of options). */
    _listboxSize: { value: -1 },
    /** Draft input text while composing suggestions. */
    _draftInput: { type: "string", nullable: false },
    /** Whether a suggestion is currently available. */
    _hasSuggestion: "boolean",
    /** The current selected/committed listbox value. */
    _listboxValue: "string",
    /** Last computed listbox value (non-nullable string). */
    _lastComputedListboxValue: { type: "string", nullable: false },
    _values: {
      type: "array",
      /** @type {string[]} */
      value: []
    },
    /** Whether an input chip is currently selected in multi-select mode. */
    _chipSelected: "boolean"
  }).observe({
    _hasListbox({ _listbox }) {
      return !!_listbox;
    },
    _isSelect({ type }) {
      return type.toLowerCase() === "select-one" || type.toLocaleLowerCase() === "select-multiple";
    }
  }).define({
    listbox() {
      return this._listbox;
    }
  }).set({
    /** @type {EventListener} */
    _onListboxChangeListener: null,
    /** @type {EventListener} */
    _onListboxClickListener: null,
    /** @type {EventListener} */
    _onPopupFocusoutListener: null,
    _suggestionText: "",
    _suggestionValue: "",
    /** @type {Pick<HTMLOptionElement, 'label'|'value'|'selected'>} */
    _suggestionOption: null
  }).define({
    stateTargetElement() {
      return this.refs.control;
    }
  }).methods({
    onResizeObserved() {
      if (!this._expanded) return;
      getSharedPopup().updatePopupPosition(this.refs.shape);
    },
    /**
     * Listbox should close if clicking own selection
     * @param {Event} event
     */
    onListboxClick(event) {
      this.closeListbox();
      this.refs.control.focus();
    },
    /**
     * @param {Event} event
     */
    onListboxChange(event) {
      if (this.multiple) {
        const values = [...this._listbox.selectedOptions].map((option2) => option2.value);
        this._values = values;
        if (this._input.value) {
          this.closeListbox();
        }
        return;
      }
      const option = this._listbox.selectedOptions.item(0);
      this.render({
        selectedOption: option
      });
      const { label: suggestionText, value: suggestionValue } = option;
      this._suggestionText = suggestionText;
      this._suggestionValue = suggestionValue;
      this._suggestionOption = option;
      this._hasSuggestion = true;
      this.acceptSuggestion(true);
      this.closeListbox();
      this.refs.control.focus();
    },
    /** @param {FocusEvent} Event */
    onPopupFocusout({ relatedTarget }) {
      if (!this._expanded) return;
      if (relatedTarget) {
        if (this === relatedTarget) return;
        if (this.contains(
          /** @type {any} */
          relatedTarget
        )) return;
        if (getSharedPopup().contains(
          /** @type {any} */
          relatedTarget
        )) return;
      }
      this.closeListbox();
    },
    applyAutocompleteList() {
      const { _listbox, _draftInput } = this;
      if (!_listbox) return;
      const lowerCase = _draftInput.toLowerCase();
      for (const option of _listbox) {
        option.hidden = !option.label.toLowerCase().startsWith(lowerCase);
      }
    },
    showListbox() {
      const _listbox = this._listbox;
      if (!_listbox) return;
      this._expanded = true;
      const { ariaListbox, shape } = this.refs;
      ariaListbox.setAttribute("aria-hidden", "false");
      const popup = getSharedPopup();
      if ("popover" in popup) {
        this.insertAdjacentElement("afterend", popup);
        popup.popover = "manual";
        popup.showPopover();
      } else {
        document.body.append(popup);
      }
      popup.replaceChildren(_listbox);
      popup.showPopup(shape, false);
      popup.addEventListener("focusout", this._onPopupFocusoutListener);
      if (!this._isSelect && !this.multiple) {
        _listbox.value = this._listboxValue;
      }
      const [option] = _listbox.selectedOptions;
      if (option) {
        option.scrollIntoView({
          behavior: "instant",
          block: "nearest"
        });
      }
    },
    closeListbox() {
      this._expanded = false;
      const { _listbox } = this;
      if (!_listbox) return;
      const popup = getSharedPopup();
      this.refs.ariaListbox.setAttribute("aria-hidden", "true");
      this.replaceChildren(_listbox);
      popup.close(void 0, false);
      popup.remove();
    },
    toggleListbox() {
      if (this._expanded) {
        this.closeListbox();
      } else {
        this.showListbox();
      }
    },
    /**
     * @param {Pick<HTMLOptionElement, 'label'|'value'|'selected'>} option
     * @return {void}
     */
    suggestOption(option) {
      this.render({
        selectedOption: option
      });
      const {
        _draftInput: currentInput,
        _input: inputElement,
        _isSelect,
        autocompleteInline,
        _expanded,
        autoSelect
      } = this;
      const { label: suggestionText, value: suggestionValue } = option;
      this._suggestionText = suggestionText;
      this._suggestionValue = suggestionValue;
      this._suggestionOption = option;
      this._hasSuggestion = true;
      if (autoSelect) {
        this.acceptSuggestion(true);
        return;
      }
      if (_isSelect && !this.multiple || autocompleteInline) {
        let valueText = suggestionText;
        let selectionStart = 0;
        if (_expanded) {
          if (!_isSelect && suggestionText.toLowerCase().startsWith(currentInput.toLowerCase())) {
            valueText = currentInput + suggestionText.slice(currentInput.length);
            selectionStart = currentInput.length;
          } else {
            selectionStart = suggestionText.length;
          }
        } else {
          selectionStart = 0;
        }
        inputElement.value = valueText;
        if (autocompleteInline) {
          inputElement.setSelectionRange(selectionStart, suggestionText.length);
        }
        if (!_expanded) {
          this.acceptSuggestion(true);
        }
      }
    },
    acceptSuggestion(emitChange = false) {
      if (!this._hasSuggestion) return;
      if (this.readOnly) return;
      const { _suggestionText, _suggestionValue, _input, multiple, _listbox, _values } = this;
      if (multiple) {
        const newArray = [..._values.filter(Boolean), _suggestionValue ?? _suggestionText];
        this._values = [...new Set(newArray)];
      } else {
        this.value = _suggestionValue;
        _input.value = _suggestionText;
        this._draftInput = _suggestionText;
        _listbox.value = _suggestionValue;
      }
      if (emitChange) {
        this.dispatchEvent(new Event("change", { bubbles: true }));
      }
    },
    /**
     * @param {Object} options
     * @param {boolean} [options.first] first option
     * @param {boolean} [options.last] first option
     * @param {boolean} [options.next] next fosuable option
     * @param {boolean} [options.previous] previous focusable option
     * @param {string} [options.startsWith] option label starsWith
     * @param {string} [options.value] matches option value
     * @param {string} [options.label] matches option label
     */
    changeSuggestion({ first, last, next, previous, startsWith, value, label }) {
      const _listbox = this._listbox;
      let suggestion;
      let suggestionIndex;
      let current;
      let currentIndex;
      let backup;
      let backupIndex = -1;
      let optionIndex = -1;
      for (const option of _listbox.options) {
        optionIndex++;
        if (!current && option.focused) {
          current = option;
          currentIndex = optionIndex;
          if (suggestion && (!next && !last)) {
            break;
          }
        }
        if (option.hidden) continue;
        if (last) {
          suggestion = option;
          suggestionIndex = optionIndex;
          continue;
        }
        if (first) {
          if (!suggestion) {
            suggestion = option;
            suggestionIndex = optionIndex;
          }
          continue;
        }
        if (startsWith != null) {
          if (!suggestion && option.label.toLowerCase().startsWith(startsWith)) {
            suggestion = option;
            suggestionIndex = optionIndex;
          }
          continue;
        }
        if (value != null) {
          if (!suggestion && option.value === value) {
            suggestion = option;
            suggestionIndex = optionIndex;
          }
          continue;
        }
        if (label != null) {
          if (!suggestion && option.label === label) {
            suggestion = option;
            suggestionIndex = optionIndex;
          }
          continue;
        }
        if (currentIndex === optionIndex) continue;
        if (previous) {
          suggestion = option;
          suggestionIndex = optionIndex;
        } else if (next) {
          if (current) {
            suggestion = option;
            suggestionIndex = optionIndex;
            break;
          } else if (!backup) {
            backup = option;
            backupIndex = optionIndex;
          }
        }
      }
      if (current && current !== suggestion) {
        current.focused = false;
      }
      if (!suggestion) {
        suggestionIndex = backupIndex;
        suggestion = backup;
        this._input.value = this._draftInput;
      }
      if (suggestionIndex === -1) {
        this._focusedPosInSet = -1;
        this._hasSuggestion = false;
        return;
      }
      this._focusedPosInSet = suggestionIndex + 1;
      suggestion.focused = true;
      suggestion.scrollIntoView({
        behavior: "instant",
        block: "nearest"
      });
      this.suggestOption(suggestion);
    },
    resetSuggestion() {
      if (this._isSelect) {
        this.changeSuggestion({ label: this._draftInput });
      } else {
        this.changeSuggestion({ value: this._listboxValue });
      }
    },
    refreshMultiple() {
      const { _values, multiple } = this;
      if (!multiple) {
        this.refs.chips.replaceChildren();
        return;
      }
      let element = (
        /** @type {InstanceType<import('./InputChip.js').default>} */
        this.refs.chips.firstElementChild
      );
      for (let i = 0; i < _values.length; i++) {
        const currentValue = _values[i];
        let foundOption;
        if (this.listbox) {
          for (const option of this.listbox.options) {
            if (option.value === currentValue) {
              foundOption = option;
              break;
            }
          }
        }
        element ??= /** @type {InstanceType<import('./InputChip.js').default>} */
        this.refs.chips.appendChild(document.createElement("mdw-input-chip"));
        element.closeButton = true;
        element.textContent = (foundOption == null ? void 0 : foundOption.label) || currentValue;
        element.textContent = (foundOption == null ? void 0 : foundOption.label) || currentValue;
        element.disabled = this.disabled;
        element.readOnly = this.readOnly;
        element.onclose ??= this.onChipClose.bind(this);
        element = /** @type {InstanceType<import('./InputChip.js').default>} */
        element.nextElementSibling;
      }
      while (element) {
        const prev = element;
        element = /** @type {InstanceType<import('./InputChip.js').default>} */
        element.nextElementSibling;
        prev.remove();
      }
      this._chipSelected = false;
      this._input.value = "";
      this._draftInput = "";
      this._listboxValue = "";
      if (this.listbox) {
        for (const option of this.listbox.options) {
          option.selected = _values.includes(option.value);
        }
      }
    },
    populateInputFromListbox() {
      if (this.multiple) {
        this.refreshMultiple();
        return;
      }
      if (!this._isSelect) return;
      if (!this._listbox) return;
      this._listbox.value = this._value;
      const [option] = this._listbox.selectedOptions;
      if (option) {
        this._input.value = option.label;
        this._draftInput = option.label;
      }
    },
    /** @param {CloseEvent & {currentTarget: HTMLElement}} event */
    onChipClose({ currentTarget }) {
      let prev = currentTarget;
      let elementIndex = 0;
      while (prev = prev.previousSibling) {
        elementIndex++;
      }
      currentTarget.remove();
      this._values.splice(elementIndex, 1);
      this._values = [...this._values];
    }
  }).childEvents({
    control: {
      click() {
        if (!this._isSelect) return;
        if (this.readOnly) return;
        this.toggleListbox();
      },
      input(event) {
        if (!this._hasListbox) return;
        event.stopPropagation();
        const performDefault = this.dispatchEvent(new InputEvent("input", {
          composed: true,
          data: event.data,
          bubbles: true,
          dataTransfer: event.dataTransfer,
          detail: event.detail,
          inputType: event.inputType,
          view: event.view,
          targetRanges: event.getTargetRanges(),
          isComposing: event.isComposing
        }));
        if (!performDefault) {
          event.preventDefault();
          return;
        }
        const value = (
          /** @type {HTMLInputElement} */
          event.currentTarget.value
        );
        this._draftInput = value;
        if (this.autocompleteList != null && this.autocompleteList !== "custom") {
          this.applyAutocompleteList();
        }
        this.resetSuggestion();
        if (value && !this._expanded && this._listbox.length) {
          this.showListbox();
        }
        if (event.data != null && this.autosuggestInline) {
          this.changeSuggestion({ startsWith: this._draftInput.toLocaleLowerCase() });
        }
      },
      keydown(event) {
        if (!this._listbox) return;
        switch (event.key) {
          case "Home":
            if (!this._isSelect) return;
            if (this.readOnly) return;
            this.changeSuggestion({ first: true });
            break;
          case "End":
            this._chipSelected = false;
            if (!this._isSelect) return;
            if (this.readOnly) return;
            this.changeSuggestion({ last: true });
            break;
          case "ArrowDown":
          case "Down":
            if (this.disabled) return;
            if (this.readOnly) return;
            this._chipSelected = false;
            if (this.readOnly) return;
            if (event.altKey) {
              this.toggleListbox();
              break;
            }
            if (!this._expanded && !this.autocompleteInline && !this._isSelect) return;
            this.changeSuggestion({ next: true });
            break;
          case "ArrowUp":
          case "Up":
            if (this.disabled) return;
            if (this.readOnly) return;
            if (event.altKey) {
              this.toggleListbox();
              break;
            }
            this._chipSelected = false;
            if (!this._expanded && !this.autocompleteInline && !this._isSelect) return;
            this.changeSuggestion({ previous: true });
            break;
          case "Escape":
            if (!this._expanded) return;
            event.stopImmediatePropagation();
            event.preventDefault();
            if (this.acceptOnEscape) {
              this.acceptSuggestion(true);
            } else {
              this.resetSuggestion();
            }
            this.closeListbox();
            break;
          case "Space":
            if (this.disabled) return;
            if (this.readOnly) return;
            if (!this._isSelect) return;
            if (!this._listbox) return;
            if (this._expanded) {
              if (this.multiple && this._suggestionOption) {
                this._suggestionOption.selected = !this._suggestionOption.selected;
                this.closeListbox();
              }
            } else {
              this.showListbox();
            }
            break;
          case "Backspace":
            if (this.disabled) return;
            if (this.readOnly) return;
            if (!this.multiple) return;
            if (this._isSelect) return;
            if (!this._input.value) {
              if (this._chipSelected) {
                this._values.pop();
                this._values = [...this._values];
              } else if (this._values.length) {
                this._chipSelected = true;
              }
            }
            return;
          case "Tab":
            if (!this._expanded && this.multiple) return;
            this.closeListbox();
            this.acceptSuggestion(true);
            event.stopPropagation();
            return;
          case "Enter":
            this._chipSelected = false;
            if (!this._expanded) return;
            event.stopImmediatePropagation();
            event.preventDefault();
            this.acceptSuggestion(true);
            this.closeListbox();
            break;
          case " ":
            return;
          default:
            if (this._isSelect && event.key.length === 1) {
              this.changeSuggestion({ startsWith: event.key.toLocaleLowerCase() });
              break;
            }
            return;
        }
        event.stopPropagation();
        event.preventDefault();
      }
    },
    slot: {
      /**
       * @param {{currentTarget: HTMLSlotElement}} event
       * @type {any}
       */
      slotchange({ currentTarget }) {
        if (this._expanded) return;
        const [listbox] = (
          /** @type {InstanceType<Listbox>[]} */
          currentTarget.assignedElements()
        );
        const _listbox = this._listbox;
        if (_listbox === listbox) {
          return;
        }
        if (_listbox) {
          _listbox.removeEventListener("change", this._onListboxChangeListener);
          _listbox.removeEventListener("click", this._onListboxClickListener);
          _listbox._handleFormReset = true;
        }
        this._listbox = listbox;
        if (listbox) {
          if (!this.multiple) {
            listbox.required = true;
          }
          listbox._handleFormReset = false;
          listbox.addEventListener("change", this._onListboxChangeListener);
          listbox.addEventListener("click", this._onListboxChangeListener);
          this.populateInputFromListbox();
        }
      }
    },
    trailingIcon: {
      "~click"() {
        if (!this._listbox) return;
        this.toggleListbox();
        this.refs.control.focus();
      }
    }
  }).events({
    blur({ relatedTarget }) {
      this._chipSelected = false;
      if (!this._expanded) return;
      const popup = getSharedPopup();
      if (popup === relatedTarget) return;
      if (relatedTarget && popup.contains(
        /** @type {Node} */
        relatedTarget
      )) return;
      if (popup.matches(":focus-within,:focus")) return;
      this.closeListbox();
    }
  }).expressions({
    showTrailingIcon({ trailingIcon, _listbox, _expanded, readOnly }) {
      if (trailingIcon != null) {
        return trailingIcon;
      }
      if (_listbox && !readOnly) {
        return _expanded ? "arrow_drop_up" : "arrow_drop_down";
      }
      return null;
    },
    computedTrailingIcon({ trailingIcon, _listbox, _expanded }) {
      if (trailingIcon != null) {
        return trailingIcon;
      }
      if (_listbox) {
        return _expanded ? "arrow_drop_up" : "arrow_drop_down";
      }
      return null;
    },
    controlTypeAttrValue({ _isSelect, type }) {
      if (_isSelect) return "text";
      return type;
    },
    controlReadonlyAttrValue({ _isSelect, type, readOnly }) {
      if (_isSelect) return true;
      return readOnly;
    },
    controlIsSelect({ _isSelect, type }) {
      return _isSelect;
    },
    ariaExpandedAttrValue({ _hasListbox, _expanded }) {
      if (!_hasListbox) return null;
      return `${_expanded}`;
    },
    ariaControlsAttrValue({ _hasListbox }) {
      if (!_hasListbox) return null;
      return "aria-listbox";
    },
    /**
     * Compute `aria-autocomplete` to describe the widget's behavior to AT.
     *
     * ARIA values:
     * - `none`  : no autocomplete behavior is provided
     * - `inline`: the textbox shows an inline completion the user can accept
     * - `list`  : a popup listbox provides choices (no inline insertion)
     * - `both`  : both inline completion and a listbox are available
     *
     * Component mapping:
     * - `autocompleteInline` -> inline completion behavior
     * - `autocompleteList` (non-null) -> listbox filtering / dropdown present
     * - `autosuggestInline` -> drives candidate selection as user types
     *
     * Note: the current implementation reports `'both'` when a named
     * `autocompleteList` is present (even if `autocompleteInline` is false).
     * A stricter mapping would return `list` when only a listbox is present
     * and `both` only when both `autocompleteInline` and a listbox exist.
     */
    ariaAutocompleteAttrValue({ _hasListbox, autocompleteList, _isSelect, autocompleteInline }) {
      if (!_hasListbox) return null;
      if (_isSelect) return null;
      if (autocompleteList != null) {
        return "both";
      }
      return "inline";
    },
    ariaActiveDescendantAttrValue({ _hasListbox, _expanded, _focusedValue }) {
      if (!_hasListbox) return null;
      if (_expanded && _focusedValue) return "aria-active";
      return "";
    },
    controlRoleAttrValue({ _hasListbox }) {
      if (_hasListbox) return "combobox";
      return null;
    },
    populatedState({ value, _badInput, _draftInput, type }) {
      return !!value || _badInput || !!_draftInput || type === "datetime-local";
    }
  }).recompose(({ refs: { control, trailingIcon, shape, labelText } }) => {
    control.setAttribute("aria-activedescendant", "{ariaActiveDescendantAttrValue}");
    control.setAttribute("aria-autocomplete", "{ariaAutocompleteAttrValue}");
    control.setAttribute("aria-controls", "{ariaControlsAttrValue}");
    control.setAttribute("aria-expanded", "{ariaExpandedAttrValue}");
    control.setAttribute("type", "{controlTypeAttrValue}");
    control.setAttribute("role", "{controlRoleAttrValue}");
    control.setAttribute("readonly", "{controlReadonlyAttrValue}");
    control.setAttribute("autocomplete", "off");
    control.setAttribute("is-select", "{controlIsSelect}");
    trailingIcon.setAttribute("mdw-if", "{showTrailingIcon}");
    trailingIcon.setAttribute("icon", "{computedTrailingIcon}");
    shape.setAttribute("trailing-icon", "{computedTrailingIcon}");
    labelText.setAttribute("trailing-icon", "{computedTrailingIcon}");
  }).overrides({
    _onSetValue(value) {
      if (this.multiple) {
        this._values = value.split(",").filter(Boolean);
      } else if (this._isSelect) {
        this._value = value;
      } else {
        this._input.value = value;
        this._value = this._input.value;
      }
    },
    _onControlValue(value) {
      if (this.multiple) {
        if (value) {
          this._chipSelected = false;
        }
        return;
      }
      this._value = value;
    }
  }).on({
    _valueChanged(previous, current) {
      if (this.multiple) return;
      if (this._isSelect) {
        this.populateInputFromListbox();
      } else {
        this._listboxValue = current;
      }
    },
    _valuesChanged(previous, current) {
      if (this.multiple && current) {
        this._value = current.join(",");
        this.refreshMultiple();
      }
    },
    _chipSelectedChanged(previous, current) {
      if (!this.multiple) return;
      const element = (
        /** @type {HTMLOptionElement} */
        this.refs.chips.lastElementChild
      );
      if (element) {
        element.selected = current;
      }
    },
    _listboxValueChanged(previous, current) {
      if (!this._hasListbox) return;
      this._listbox.value = current;
      this._draftInput = current;
      this.changeSuggestion({ value: current });
    },
    _expandedChanged(previous, current) {
      this._useFormImplicitSubmission = !current;
    },
    constructed() {
      this._onListboxChangeListener = this.onListboxChange.bind(this);
      this._onListboxClickListener = this.onListboxClick.bind(this);
      this._onPopupFocusoutListener = this.onPopupFocusout.bind(this);
      document.addEventListener("DOMContentLoaded", () => this.populateInputFromListbox(), { once: true });
    },
    multipleChanged(previous, current) {
      if (this.listbox) {
        this.listbox.multiple = current;
      }
      if (current) {
        this._onSetValue(this._input.value);
      }
    },
    disabledStateChanged() {
      this.refreshMultiple();
      this._chipSelected = false;
      this.closeListbox();
    },
    readOnlyChanged() {
      this.refreshMultiple();
      this._chipSelected = false;
      this.closeListbox();
    }
  }).html`
    <div id=chips mdw-if={multiple}></div>
    <slot id=slot></slot>
    <div id=aria-listbox role=listbox mdw-if={_hasListbox}>
      <div id=aria-active role=option aria-hidden=false aria-label={selectedOption.label}
        aria-setsize="{_listbox.length}" aria-posinset={_focusedPosInSet}></div>
    </div>
  `.css`
    #slot {
      display: none;
    }

    #aria-listbox {
      display: none;
    }

    #trailing-icon {
      align-self: center;
    }

    #control:where([type="button"], [is-select]) {
      cursor: pointer;
    }

    #inline[multiple] {
      gap: 8px;
    }

    mdw-input-chip {
      align-self: baseline;

    }

    #control[multiple] {
      align-self: baseline;
    }

    #chips {
      display: contents;
    }

    #inline {
      flex-wrap: wrap;
    }

    #inline:where([filled],[outlined]) {
      padding-inline: 16px;
    }

    #control {
      flex: 1 1 8ch;
    }

    #control[is-select][multiple] {
      flex: 1 1 0px;
    }
  `.recompose(({ refs: { inline, chips } }) => {
    inline.prepend(chips);
    inline.setAttribute("multiple", "{multiple}");
  }).extend((Base) => class Input extends Base {
    /** @type {InstanceType<ReturnType<RippleMixin>>['addRipple']} */
    addRipple(...args) {
      if (!this.active) return null;
      return super.addRipple(...args);
    }
  }).autoRegister("mdw-input");

  // services/rtl.js
  var globalStylesLoaded = false;
  function loadGlobalStyles() {
    if (globalStylesLoaded) return;
    addGlobalCss('html[dir="rtl"]{--mdw-dir: -1;}');
    globalStylesLoaded = true;
  }

  // components/Slider.js
  loadGlobalStyles();
  function parseFloat(value, onNaN = 0) {
    const number = Number.parseFloat(value);
    if (Number.isNaN(number)) return onNaN;
    return number;
  }
  function valueAsFraction(value, min, max) {
    const nValue = parseFloat(value);
    const nMin = parseFloat(min);
    const nMax = parseFloat(max, 100);
    return (nValue - nMin) / (nMax - nMin);
  }
  var Slider_default = CustomElement.extend().mixin(ThemableMixin).mixin(StateMixin).mixin(InputMixin).set({
    stateLayer: true,
    type: "range"
  }).observe({
    /** Number of tick marks to show along the track (integer). */
    ticks: "integer",
    /** Internal string representation of the current value used for formatting. */
    _valueAsText: { nullable: false },
    /** Text to show in the thumb label; when null the numeric value is shown. */
    thumbLabel: {
      type: "string",
      reflect: "read"
    },
    /** Rounded numeric value (used while dragging) tracked as a float. */
    _roundedValue: "float",
    /** True while the pointer is hovering the thumb (used to show the label). */
    _isHoveringThumb: "boolean",
    /** Last `value` string that produced a dispatched `change` event; used to avoid duplicates. */
    _lastDispatchedChangeValue: "string"
  }).methods({
    /**
     * Handle pointer or touch interactions on the native control to compute
     * position and update the intermediate rounded value while dragging.
     * @param {(MouseEvent|TouchEvent) & {currentTarget:HTMLInputElement}} event
     * @return {void}
     */
    onControlMouseOrTouch(event) {
      const input = event.currentTarget;
      if (input.disabled) return;
      if (this.disabledState) return;
      if (event.type === "touchend") {
        this._isHoveringThumb = false;
        return;
      }
      let offsetX;
      let clientX;
      let pageX;
      let isActive;
      const isTouch = "touches" in event;
      if (isTouch) {
        if (event.touches.length) {
          const [touch] = event.touches;
          isActive = true;
          ({ offsetX, clientX, pageX } = touch);
        }
      } else {
        isActive = (event.buttons & 1) === 1 && (event.type === "mousedown" || input.matches(":active"));
        ({ offsetX, clientX, pageX } = event);
      }
      if (offsetX == null) {
        clientX ??= pageX - window.scrollX;
        offsetX = clientX - input.getBoundingClientRect().left;
      }
      const { clientWidth } = input;
      let position = offsetX / clientWidth;
      if (position > 1) {
        position = 1;
      } else if (position < 0) {
        position = 0;
      }
      if (isActive) {
        this._isHoveringThumb = true;
        const { min, max, step } = this;
        const nMin = parseFloat(min);
        const nMax = parseFloat(max, 100);
        const nStep = parseFloat(step, 1);
        if (isRtl(this)) {
          position = 1 - position;
        }
        const currentValue = position * (nMax - nMin) + nMin;
        let roundedValue = Math.round(currentValue / nStep) * nStep;
        if (nStep < 1) {
          const log10 = Math.floor(Math.log10(nStep));
          const scale = 10 ** (-1 * log10);
          roundedValue = Math.round(roundedValue * scale) / scale;
        }
        this._roundedValue = roundedValue;
        this._valueAsText = roundedValue.toString(10);
        if (isTouch && SAFARI_VERSION) {
          if (event.type === "touchstart") {
            event.preventDefault();
          }
          const { _input } = this;
          if (_input.valueAsNumber !== roundedValue) {
            _input.valueAsNumber = roundedValue;
            this.dispatchEvent(new Event("input", { bubbles: true, composed: true }));
          }
        }
        return;
      }
      if (isTouch) return;
      let fractionalValue = valueAsFraction(this.value, this.min, this.max);
      if (isRtl(this)) {
        fractionalValue = 1 - fractionalValue;
      }
      const thumbOffset = fractionalValue * clientWidth;
      const thumbMin = thumbOffset - 20;
      const thumbMax = thumbOffset + 20;
      this._isHoveringThumb = offsetX >= thumbMin && offsetX <= thumbMax;
    },
    /**
     * Pointer leave/blur handler for the control; hides the thumb label when focus is lost.
     * @param {Event} event
     */
    onLeaveEvent({ currentTarget }) {
      if (isFocused(
        /** @type {Element} */
        currentTarget
      )) return;
      this._isHoveringThumb = false;
    },
    /**
     * Finalize interaction with the control: commit the rounded value to the
     * native input and dispatch a `change` event if the value changed.
     * @param {(MouseEvent|TouchEvent) & {currentTarget:HTMLInputElement}} event
     * @return {void}
     */
    onControlFinish(event) {
      const input = event.currentTarget;
      if (input.disabled) return;
      if (event.type === "click") {
        event.preventDefault();
      }
      input.valueAsNumber = this._roundedValue;
      this._value = input.value;
      if (this._lastDispatchedChangeValue !== this._value) {
        this._lastDispatchedChangeValue = this._value;
        this.dispatchEvent(new Event("change", { bubbles: true }));
      }
    }
  }).events({
    blur: "onLeaveEvent",
    mouseout: "onLeaveEvent"
  }).childEvents({
    control: {
      "~mousedown": "onControlMouseOrTouch",
      "~mousemove": "onControlMouseOrTouch",
      "~mouseout": "onControlMouseOrTouch",
      touchstart: "onControlMouseOrTouch",
      "~touchmove": "onControlMouseOrTouch",
      "~touchleave": "onControlMouseOrTouch",
      "~touchcancel": "onControlMouseOrTouch",
      "~touchend": "onControlMouseOrTouch",
      touchend: "onControlFinish",
      click: "onControlFinish",
      "~change"(event) {
        if (this._lastDispatchedChangeValue === this._value) {
          event.stopPropagation();
        }
        this._lastDispatchedChangeValue = this._value;
      }
    }
  }).expressions({
    /** Compute inline style variables for the track, including ticks and value fraction. */
    computeTrackStyle({ ticks, _valueAsText, min, max }) {
      return [
        ticks ? `--ticks:${ticks}` : null,
        `--value:${valueAsFraction(_valueAsText, min, max)}`
      ].filter(Boolean).join(";") || null;
    },
    /** True when the thumb label should be hidden (not hovering and not focused). */
    _thumbLabelHidden({ _isHoveringThumb, focusedState }) {
      return !_isHoveringThumb && !focusedState;
    },
    /** Compute the label text to show in the thumb: explicit `thumbLabel` or numeric value. */
    _computedThumbLabel({ thumbLabel, _valueAsText }) {
      return thumbLabel ?? _valueAsText;
    }
  }).html`
    <div id=track style={computeTrackStyle} aria-hidden=true disabled={disabledState}>
      <div mdw-if={ticks} id=ticks></div>
      <div id=track-active></div>
      <div id=thumb-anchor>
        <div id=thumb></div>
        <div id=thumb-label
          hidden={_thumbLabelHidden}
          text={_computedThumbLabel}></div>
      </div>
    </div>
  `.recompose(({ refs: { thumb, state, control } }) => {
    thumb.append(state);
    control.removeAttribute("aria-labelledby");
  }).on({
    valueChanged(oldValue, newValue) {
      this._valueAsText = newValue;
    }
  }).css`
    /* https://m3.material.io/components/sliders/specs */

    :host {
      --mdw-ink: var(--mdw-color__on-primary);
      --mdw-bg: var(--mdw-color__primary);

      display: block;
      vertical-align: middle;

      min-block-size: 40px;
      min-inline-size: 88px;

      background-color: transparent;
    }

    :host,
    :host([color]) {
      background-color: transparent;
    }

    #control {
      inset:0;

      overflow: visible;

      block-size: 100%;
      min-block-size: 0;
      inline-size: 100%;
      min-inline-size: 0;

      appearance: none;

      cursor: pointer;

      transform: none;

      background-color: transparent;
    }

    #control::-webkit-slider-runnable-track {
      /* stylelint-disable-next-line declaration-property-value-disallowed-list */
      margin-inline: -10px;

      appearance: none;

      background-color: transparent;
    }

    @supports (-moz-appearance:none ){
      #control {
        inset-inline: -10px;

        inline-size: calc(100% + 20px);
      }
    }

    #control::-moz-range-track {
      inline-size: calc(100% + 20px) !important;

      appearance: none;
    }

    #control::-webkit-slider-thumb {
      display: block;

      block-size: 20px;
      inline-size: 20px;

      -webkit-appearance: none;
      cursor: inherit;

      transform: scale(2);

      background-color: transparent; /* Safari */

      border-radius: 50%;
      box-shadow: none; /* Safari */
    }

    #control::-moz-range-thumb {
      display: block;

      box-sizing: content-box;
      block-size: 20px;
      inline-size: 20px;
      border: none;

      appearance: none;
      cursor: inherit;

      transform: scale(2);

      background-color: transparent;
      border-radius: 50%;
    }

    #control[disabled] {
      cursor: not-allowed;
    }

    #track {
      --value: 0.5;
      position: absolute;
      inset-block-start: 50%;
      inset-inline: 0;

      block-size: 4px;
      margin-block-start: -2px;

      pointer-events: none;
      user-select: none;

      background-color: rgb(var(--mdw-color__surface-container-highest));
      border-radius: inherit;
      color: rgb(var(--mdw-bg));
    }

    #thumb {
      position: absolute;
      inset-block-start: -18px;
      inset-inline-start: -20px;

      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;

      block-size: 40px;
      inline-size: 40px;

      pointer-events: none;

      border-radius: 50%;

      color: currentColor;
    }

    #thumb::before {
      content: '';

      display: block;

      block-size: 20px;
      inline-size: 20px;

      background-color: currentColor;
      border-radius: 50%;

      transition: color 100ms, background-color 100ms;
    }

    /* Inactive ticks */

    #ticks::before,
    #ticks::after {
      content: '';

      position: absolute;
      inset: 0;

      padding-inline: 2px;

      background-clip: content-box;
      background-image: radial-gradient(circle at 1px, currentColor 0, currentColor 1px, transparent 0);
      background-position: -1px 50%;
      background-repeat: repeat-x;
      background-size: calc(100% / (var(--ticks, 0) + 1)) 2px;
    }

    #ticks::before {
      color: rgb(var(--mdw-color__on-surface-variant));
    }

    #ticks::after {
      /* TODO: Use single-paint implementation */
      padding-inline-end: calc(100% - (100% * var(--value)) + 10px);

      z-index: 1;

      color: rgb(var(--mdw-ink));

      will-change: padding-inline-end;
    }
    /* Active Indicator */
    #track-active {
      position: absolute;
      inset: 0;

      overflow: hidden;

      border-radius: 99px;
    }

    #track-active::before {
      content: '';

      position: absolute;
      inset: 0;

      transform: scaleX(var(--value));
      transform-origin: calc(100% * calc(-0.5 * var(--mdw-dir, 1) + 0.5)) 0;

      background-color: currentColor;

      will-change: transform;
    }

    #thumb-anchor {
      position: absolute;

      inset-inline-start: calc(var(--value) * 100%);

      display: flex;
      align-items: flex-start;
      flex-direction: column;

      z-index: 24;

      /* stylelint-disable-next-line liberty/use-logical-spec */
      will-change: inset-inline-start, left, right;
    }

    #thumb-label {
      position: absolute;
      /* stylelint-disable-next-line liberty/use-logical-spec */
      left: 0;
      inset-block-end: 14px;

      display: flex;
      align-items: center;
      justify-content: center;

      box-sizing: content-box;
      margin-block-end: 6px;

      transform: translateX(-50%) scale(1);
      transform-origin: 50% 100%;

      font-weight: var(--mdw-typescale__label-medium__font-weight);
      line-height: var(--mdw-typescale__label-medium__line-height);
      font-family: var(--mdw-typescale__label-medium__font-family);
      letter-spacing: var(--mdw-typescale__label-medium__letter-spacing);

      transition: transform 200ms;
      will-change: transform;
    }

    #thumb-label:is([hidden],[text=""]) {
      transform: translateX(-50%) scale(0);
    }

    #thumb-label::before {
      content: attr(text);

      display: flex;
      align-items: center;
      justify-content: center;

      box-sizing: border-box;

      min-block-size: 28px;
      min-inline-size: 28px;
      padding: 4px;

      z-index: 1;

      background-color: rgb(var(--mdw-bg));
      border-radius: 14px;
      color: rgb(var(--mdw-ink));
    }

    #thumb-label::after {
      /* Values from Figma SVG */
      --x-start: 4.1005px; /*4.1005px*/
      --x-end: calc(100% - 4.1005px);
      --y: calc(100% - 9.9584px); /*24.0416px*/

      content: "";

      position: absolute;
      inset: 0;
      inset-block-end: -6px;

      clip-path: polygon(var(--x-start) var(--y), var(--x-end) var(--y), 50% 100%, var(--x-start) var(--y));

      background-color: currentColor;
    }

    #track[disabled] {
      --mdw-bg: var(--mdw-color__on-surface);
      cursor: not-allowed;

      opacity: 0.38;

      background-color: rgb(var(--mdw-color__on-surface), calc(0.12 / 0.38));
    }
  `.autoRegister("mdw-slider");

  // components/Divider.js
  var Divider_default = CustomElement.extend().mixin(ThemableMixin).observe({
    /** When true, render the divider vertically instead of horizontally. */
    vertical: "boolean"
  }).css`
    :host {
      --mdw-ink: var(--mdw-color__outline-variant);
      position: relative;

      display: block;
      overflow: visible;

      box-sizing: border-box;
      block-size: 0;
      inline-size: 100%;

      color: rgb(var(--mdw-ink));
    }

    :host::before {
      content: '';

      display: block;

      box-sizing: border-box;
      block-size: 1px;
      inline-size: auto;

      background-color: currentcolor;
    }

    :host([vertical]) {
      display: inline-flex;
      vertical-align: top;

      block-size: auto;
      min-block-size: 100%;
      inline-size: 0;
    }

    :host([vertical])::before {
      block-size: auto;
      min-inline-size: 1px;
    }

  `.autoRegister("mdw-divider");

  // core/customTypes.js
  var EVENT_HANDLER_TYPE = {
    type: "function",
    reflect: "read",
    value: null,
    parser(v) {
      return v;
    },
    attributeChangedCallback(name, oldValue, newValue) {
      if (oldValue == null && newValue == null) return;
      if (newValue == null) {
        this[name] = null;
        return;
      }
      let fn;
      try {
        const scopedCode = `with(this.ownerDocument ?? document){with(this.form ?? {}){with(this){${newValue}}}}`;
        fn = new Function(`return function ${name}(event){${scopedCode}}`)();
      } catch {
        const button = (this.ownerDocument ?? document).createElement("button");
        button.setAttribute("onclick", newValue);
        fn = button.onclick;
      }
      this[name] = fn;
    },
    propChangedCallback(name, oldValue, newValue) {
      const eventName = name.slice(2);
      if (oldValue) {
        this.removeEventListener(eventName, oldValue);
      }
      if (newValue) {
        this.addEventListener(eventName, newValue);
      }
    }
  };
  var queuedPropsByElement = /* @__PURE__ */ new WeakMap();
  var previousAnimationsByElement = /* @__PURE__ */ new WeakMap();
  function elementStylerMicrotaskCallback(name) {
    const previousAnimations = previousAnimationsByElement.get(this);
    let previousAnimation;
    if (previousAnimations == null ? void 0 : previousAnimations.has(name)) {
      previousAnimation = previousAnimations.get(name);
    }
    const queuedProps = queuedPropsByElement.get(this);
    const { initial } = queuedProps.get(name);
    queuedProps.delete(name);
    const value = this[name];
    if (!value) {
      previousAnimation == null ? void 0 : previousAnimation.cancel();
      return;
    }
    const { target, styles, timing } = value;
    const el = target ? typeof target === "string" ? this.refs[target] : target : this;
    const currentAnimation = el.animate(styles, {
      ...timing,
      ...initial ? { duration: 0 } : null,
      fill: "forwards"
    });
    currentAnimation.onremove = () => {
      previousAnimation == null ? void 0 : previousAnimation.effect.updateTiming({
        fill: "none"
      });
      previousAnimation == null ? void 0 : previousAnimation.finish();
      previousAnimation == null ? void 0 : previousAnimation.cancel();
      previousAnimation = null;
    };
    if (previousAnimations) {
      previousAnimations.set(name, currentAnimation);
    } else {
      previousAnimationsByElement.set(this, /* @__PURE__ */ new Map([[name, currentAnimation]]));
    }
  }
  var pendingResizeCallbacks = /* @__PURE__ */ new WeakMap();
  var pendingConnections = new ResizeObserver((entries) => {
    for (const { target } of entries) {
      if (pendingResizeCallbacks.has(target)) {
        const callbacks = pendingResizeCallbacks.get(target);
        pendingResizeCallbacks.delete(target);
        pendingConnections.unobserve(target);
        for (const callback of callbacks) {
          callback();
        }
      }
    }
  });
  var ELEMENT_ANIMATION_TYPE = {
    type: "object",
    reflect: false,
    diff: null,
    // Skip computing entire change
    propChangedCallback(name, oldValue, newValue) {
      if (!newValue) {
        const previousAnimations = previousAnimationsByElement.get(this);
        if (!(previousAnimations == null ? void 0 : previousAnimations.has(name))) {
          return;
        }
      }
      const queuedProps = queuedPropsByElement.get(this);
      const initial = !this.isConnected;
      if (queuedProps) {
        if (queuedProps.has(name)) return;
        queuedProps.set(name, { initial });
      } else {
        queuedPropsByElement.set(this, /* @__PURE__ */ new Map([[name, { initial }]]));
      }
      const callback = elementStylerMicrotaskCallback.bind(this, name);
      if (this.isConnected) {
        queueMicrotask(callback);
      } else if (pendingResizeCallbacks.has(this)) {
        pendingResizeCallbacks.get(this).push(callback);
      } else {
        pendingResizeCallbacks.set(this, [callback]);
        pendingConnections.observe(this);
      }
    }
  };
  var styleReferences = /* @__PURE__ */ new WeakMap();
  var useAdoptedStyleSheets = null;
  var ELEMENT_STYLE_TYPE = {
    type: "string",
    reflect: false,
    /**
     * @param {string|Record<keyof CSSStyleDeclaration & string, string|number>} value
     * @return {string}
     */
    parser(value) {
      if (!value || typeof value === "string") {
        return (
          /** @type {string} */
          value
        );
      }
      return `:host{${Object.entries(value).map(([key, rule]) => `${attrNameFromPropName(key)}:${rule}`).join(";")}}`;
    },
    propChangedCallback(name, oldValue, newValue) {
      let mapOfStyles;
      let styles;
      if (styleReferences.has(this)) {
        mapOfStyles = styleReferences.get(this);
        if (mapOfStyles.has(name)) {
          styles = mapOfStyles.get(name);
        }
      } else {
        if (!newValue) return;
        mapOfStyles = /* @__PURE__ */ new Map();
        styleReferences.set(this, mapOfStyles);
      }
      useAdoptedStyleSheets ??= "adoptedStyleSheets" in ShadowRoot.prototype;
      if (!styles) {
        if (useAdoptedStyleSheets) {
          styles = new CSSStyleSheet();
          this.shadowRoot.adoptedStyleSheets = [
            ...this.shadowRoot.adoptedStyleSheets,
            styles
          ];
        } else {
          const styleElement = this.ownerDocument.createElement("style");
          this.shadowRoot.prepend(styleElement);
          styles = styleElement;
        }
        mapOfStyles.set(name, styles);
      }
      if (newValue) {
        if (useAdoptedStyleSheets) {
          styles.replaceSync(newValue);
        } else if (newValue) {
          styles.textContent = newValue;
        }
        styles.disabled = false;
      } else {
        styles.disabled = true;
      }
    }
  };

  // mixins/AriaReflectorMixin.js
  function AriaReflectorMixin(Base) {
    return Base.observe({
      /** Role string mirrored to ARIA `role` property/attribute. */
      _ariaRole: "string"
    }).set({
      /**
       * Browsers that do not support ARIAMixin in ElementInternals need to have
       * their attributes set after construction.
       * @type {Map<StringKeyOfARIAMixin<keyof ARIAMixin>, ARIAMixin[StringKeyOfARIAMixin<keyof ARIAMixin>]>}
       */
      _onConnectAriaValues: null
    }).methods({
      /**
       * @param {keyof HTMLElement & keyof ElementInternals} name
       */
      readAriaProperty(name) {
        if (this.elementInternals && name in this.elementInternals) {
          return this.elementInternals[name];
        }
        if (name in this) {
          return this[name];
        }
        let attrName = name;
        if (attrName.startsWith("aria")) {
          attrName = `aria-${attrName.slice(4).toLowerCase()}`;
        }
        return this.getAttribute(name);
      },
      /**
       * @template {StringKeyOfARIAMixin<keyof ARIAMixin>} K
       * @param {K} name
       * @param {ARIAMixin[K]} value
       */
      updateAriaProperty(name, value) {
        if (this.elementInternals && name in this.elementInternals) {
          this.elementInternals[name] = value;
        } else if (this.isConnected) {
          if (name in this) {
            this[name] = value;
          } else {
            let attrName = name;
            if (attrName.startsWith("aria")) {
              attrName = `aria-${attrName.slice(4).toLowerCase()}`;
            }
            if (value == null) {
              this.removeAttribute(name);
            } else {
              this.setAttribute(attrName, value);
            }
          }
        } else {
          this._onConnectAriaValues ??= /* @__PURE__ */ new Map();
          this._onConnectAriaValues.set(name, value);
        }
      }
    }).on({
      _ariaRoleChanged(oldValue, newValue) {
        this.updateAriaProperty("role", newValue);
      },
      constructed() {
        this.updateAriaProperty("role", this._ariaRole);
      },
      connected() {
        if (!this._onConnectAriaValues) return;
        for (const [key, value] of this._onConnectAriaValues) {
          this.updateAriaProperty(key, value);
        }
        this._onConnectAriaValues = null;
      }
    });
  }

  // components/Tooltip.js
  var Tooltip_default = CustomElement.extend().mixin(ThemableMixin).mixin(ShapeMixin).mixin(AriaReflectorMixin).set({
    /** ARIA role applied by the AriaReflectorMixin (defaults to `tooltip`). */
    _ariaRole: "tooltip"
  }).observe({
    /**
     * When true the tooltip is visible/open. This also updates ARIA
     * `aria-hidden` for accessibility.
     */
    open: {
      type: "boolean",
      changedCallback(oldValue, newValue) {
        this.updateAriaProperty("ariaHidden", newValue ? "true" : "false");
      }
    }
  }).html`
    <div id=hover-target></div>
    <slot id=slot></slot>
    `.css`
    :host {
      --mdw-shape__size: var(--mdw-shape__extra-small);
      --mdw-ink: var(--mdw-color__inverse-on-surface);
      --mdw-bg: var(--mdw-color__inverse-surface);
      display: block;

      box-sizing: border-box;

      /* Ensure 24px min-height while keeping display:block */
      padding-block: calc(12px - var(--mdw-typescale__body-small__line-height) / 2);
      padding-inline: 8px;

      pointer-events: none;

      opacity: 0;
      transform: scale(0);
      z-index: 28;

      background-color: rgb(var(--mdw-bg));
      color: rgb(var(--mdw-ink));

      font: var(--mdw-typescale__body-small__font);
      letter-spacing: var(--mdw-typescale__body-small__letter-spacing);

      transition: transform 200ms, opacity 200ms;
    }

    @supports(width: 1lh) {
      :host {
        padding-block: calc(12px - 0.5lh);
      }
    }

    :host([open]) {
      pointer-events: auto;

      opacity: 1;
      transform: scale(1);
    }

    #hover-target {
      position: absolute;
      inset-block-start: 50%;
      inset-inline-start: 50%;

      box-sizing: content-box;
      block-size: 100%;
      inline-size: 100%;
      padding: 8px;

      transform: translateX(-50%) translateY(-50%);
      z-index: -1;
      
    }
  `.autoRegister("mdw-tooltip");

  // mixins/TooltipTriggerMixin.js
  function TooltipTriggerMixin(Base) {
    return Base.set({
      /** Idle delay before showing tooltip for mouse (ms) */
      TOOLTIP_MOUSE_IDLE_MS: 500,
      /** Idle delay before showing tooltip for touch (ms) */
      TOOLTIP_TOUCH_IDLE_MS: 1500,
      /** Timer id used for tooltip show/hide debouncing */
      /** @type {any} */
      _idleDebounce: null,
      /** Parents being observed for layout changes */
      /** @type {HTMLElement[]} */
      _watchedParents: null,
      /** ResizeObserver used to track tooltip/anchor size changes */
      /** @type {ResizeObserver} */
      _resizeObserver: null,
      /** IntersectionObserver used to detect occlusion */
      /** @type {IntersectionObserver} */
      _intersectObserver: null,
      /** Bound scroll listener attached to parent elements */
      _parentScrollListener: null,
      /** Slot id to use when cloning tooltip content */
      tooltipSlotId: "slot"
    }).observe({
      /** Text or content id used as tooltip content */
      tooltip: "string",
      /** When true, show tooltip automatically on hover/focus */
      autoTooltip: "boolean"
    }).html`<mdw-tooltip id=tooltip></mdw-tooltip>`.css`
      #tooltip {
        display:none;
      }
    `.methods({
      cancelShowTooltip() {
        clearTimeout(this._idleDebounce);
      },
      /** @param {'mouse'|'touch'|'keyboard'} type */
      scheduleHideTooltip(type) {
        this.cancelShowTooltip();
        const tooltip = (
          /** @type {InstanceType<Tooltip>} */
          this.refs.tooltip
        );
        if (!tooltip.open) {
          return;
        }
        let timeout = 0;
        switch (type) {
          case "mouse":
            timeout = 0;
            break;
          case "touch":
            timeout = 1500;
            break;
          default:
        }
        this._idleDebounce = setTimeout(() => {
          this.hideTooltip();
        }, timeout);
      },
      /** @param {'mouse'|'touch'|'keyboard'} type */
      scheduleShowTooltip(type) {
        const tooltip = (
          /** @type {InstanceType<Tooltip>} */
          this.refs.tooltip
        );
        if (tooltip.open) return;
        let timeout = 0;
        switch (type) {
          case "mouse":
            timeout = this.TOOLTIP_MOUSE_IDLE_MS;
            break;
          case "touch":
            timeout = this.TOOLTIP_TOUCH_IDLE_MS;
            break;
          default:
        }
        clearTimeout(this._idleDebounce);
        if (timeout) {
          this._idleDebounce = setTimeout(this.showTooltip.bind(this), timeout);
        } else {
          this.showTooltip();
        }
      },
      showTooltip() {
        const tooltip = (
          /** @type {InstanceType<Tooltip>} */
          this.refs.tooltip
        );
        if (tooltip.open) return;
        document.body.append(this.refs.tooltip);
        this.recloneTooltip();
        this.updateTooltipPosition();
        this._resizeObserver.observe(this, { box: "border-box" });
        this._resizeObserver.observe(tooltip, { box: "border-box" });
        this._intersectObserver.observe(this);
        this._intersectObserver.observe(tooltip);
        let offsetParent = this;
        while (offsetParent = /** @type {?HTMLElement} */
        offsetParent.offsetParent) {
          this._resizeObserver.observe(offsetParent, { box: "border-box" });
          this._watchedParents.push(offsetParent);
          this._intersectObserver.observe(offsetParent);
          offsetParent.addEventListener("scroll", this._parentScrollListener);
        }
        window.addEventListener("scroll", this._parentScrollListener);
        tooltip.open = true;
      },
      hideTooltip(cancelSchedule = false) {
        if (cancelSchedule) {
          this.cancelShowTooltip();
        }
        this._resizeObserver.disconnect();
        this._intersectObserver.disconnect();
        let parent;
        while (parent = this._watchedParents.pop()) {
          parent.removeEventListener("scroll", this._parentScrollListener);
        }
        window.removeEventListener("scroll", this._parentScrollListener);
        const tooltip = (
          /** @type {InstanceType<Tooltip>} */
          this.refs.tooltip
        );
        tooltip.open = false;
        tooltip.remove();
      },
      /**
       * TODO: Throttle multiple calls
       * @param {DOMRect} [domRect]
       * @return {void}
       */
      updateTooltipPosition(domRect) {
        const offset = 8;
        const tooltip = (
          /** @type {InstanceType<Tooltip>} */
          this.refs.tooltip
        );
        Object.assign(tooltip.style, {
          top: "0",
          left: "0",
          right: "auto",
          bottom: "auto",
          position: "fixed",
          maxWidth: null,
          maxHeight: null
        });
        const anchorOptions = {
          anchor: domRect ?? this.getBoundingClientRect(),
          width: tooltip.clientWidth,
          height: tooltip.clientHeight
          // margin,
        };
        const isPageRTL = getComputedStyle(this).direction === "rtl";
        const xStart = isPageRTL ? "right" : "left";
        const xEnd = isPageRTL ? "left" : "right";
        const preferences = [
          { clientY: "bottom", clientX: "center", offsetY: offset },
          { clientY: "bottom", clientX: xStart, offsetY: offset },
          { clientY: "bottom", clientX: xEnd, offsetY: offset },
          { clientY: "top", clientX: "center", offsetY: -offset },
          { clientY: "top", clientX: xStart, offsetY: -offset },
          { clientY: "top", clientX: xEnd, offsetY: -offset }
        ];
        let anchorResult;
        for (const preference of preferences) {
          const result = canAnchorPopup({
            ...anchorOptions,
            ...preference
          });
          if (!anchorResult || anchorResult.visibility < result.visibility) {
            anchorResult = result;
          }
          if (result.visibility === 1) break;
        }
        Object.assign(tooltip.style, {
          position: "fixed",
          ...anchorResult.styles
        });
      },
      recloneTooltip() {
        let args;
        const tooltip = this.tooltip;
        if (tooltip) {
          args = [tooltip];
        } else {
          args = /** @type {HTMLSlotElement} */
          this.refs[this.tooltipSlotId].assignedNodes().map((child) => child.cloneNode(true));
        }
        this.refs.tooltip.replaceChildren(...args);
      },
      closeIfNotHovered() {
        const check = () => {
          if (this.hoveredState) return;
          if (this.refs.tooltip.matches(":hover")) return;
          this.hideTooltip(true);
        };
        if (FIREFOX_VERSION) {
          requestAnimationFrame(check);
        } else {
          check();
        }
      }
    }).childEvents({
      slot: {
        slotchange: "recloneTooltip"
      },
      tooltip: {
        pointerleave: "closeIfNotHovered"
      }
    }).events({
      "~pointermove"(event) {
        if (event.pointerType === "touch") return;
        if (this.autoTooltip && !this.disabledState) {
          this.scheduleShowTooltip("mouse");
        }
      },
      "~keydown"({ ctrlKey }) {
        if (ctrlKey) {
          this.hideTooltip(true);
        }
      },
      "~click"() {
        this.hideTooltip(true);
      }
    }).on({
      constructed() {
        this._watchedParents = [];
        this._parentScrollListener = this.updateTooltipPosition.bind(this, null);
        this._resizeObserver = new ResizeObserver(() => {
          const tooltip = (
            /** @type {InstanceType<Tooltip>} */
            this.refs.tooltip
          );
          if (tooltip.open) {
            this.updateTooltipPosition();
          }
        });
        const threshold = [0, 0.49, 0.5, 0.51, 1];
        this._intersectObserver = new IntersectionObserver((entries) => {
          const tooltip = (
            /** @type {InstanceType<Tooltip>} */
            this.refs.tooltip
          );
          if (!tooltip.open) return;
          for (const entry of entries) {
            if (entry.intersectionRatio <= 0) {
              this.hideTooltip();
              return;
            }
            if (entry.target === tooltip) {
              this.updateTooltipPosition();
              return;
            }
            if (entry.target === this) {
              if (entry.intersectionRatio <= 0.5) {
                this.hideTooltip();
              } else {
                this.updateTooltipPosition(entry.boundingClientRect);
              }
              return;
            }
          }
          this.updateTooltipPosition();
        }, { threshold });
      },
      _focusedChanged(previous, current) {
        if (current) {
          if (!this._pointerPressed && !this._focusedSynthetic && this.autoTooltip) {
            this.showTooltip();
          }
        } else {
          this.closeIfNotHovered();
        }
      },
      _hoveredChanged(previous, current) {
        if (current) {
          if (this.autoTooltip && !this.disabledState) {
            this.scheduleShowTooltip("mouse");
          }
        } else {
          this.closeIfNotHovered();
        }
      },
      _pointerPressedChanged(previous, current) {
        if (this._lastInteraction !== "touch") return;
        if (current) {
          if (this.autoTooltip && !this.disabledState) {
            this.scheduleShowTooltip("touch");
          }
        } else {
          this.scheduleHideTooltip("touch");
        }
      },
      disconnected() {
        this.hideTooltip(true);
      },
      tooltipChanged() {
        this.recloneTooltip();
      }
    });
  }

  // mixins/NavigationListenerMixin.js
  function NavigationListenerMixin(Base) {
    return Base.rootEvents({
      click(event) {
        const { target } = event;
        if (!(target instanceof HTMLAnchorElement)) return;
        if (!target.href) return;
        const actionAllowed = target.dispatchEvent(new CustomEvent("mdw:hyperlink", {
          bubbles: true,
          composed: true,
          cancelable: true,
          detail: {
            download: target.download,
            href: target.href,
            hreflang: target.hreflang,
            target: target.target
          }
        }));
        if (!actionAllowed) {
          event.preventDefault();
        }
      }
    });
  }

  // mixins/HyperlinkMixin.js
  function buildHyperlinkDefinition(name) {
    return {
      get() {
        return new URL(this.href, window.location.href)[name];
      },
      set(value) {
        const { href } = this;
        if (!href) return;
        const url = new URL(href, window.location.href);
        url[name] = value;
        this.href = url.href;
      }
    };
  }
  function HyperlinkMixin(Base) {
    return Base.mixin(NavigationListenerMixin).observe({
      /** The URL that the hyperlink points to. */
      href: "string",
      /** The browsing context in which to open the linked resource (e.g. '_blank'). */
      target: "string",
      /** Suggested filename for download. */
      download: "string",
      /** URLs to be pinged when the link is followed. */
      ping: "string",
      /** Link relationship tokens (e.g. 'noopener', 'noreferrer'). */
      rel: "string",
      /** Language of the linked resource. */
      hreflang: "string",
      /** Referrer policy for the link (serialized to 'referrerpolicy' attribute). */
      referrerPolicy: { type: "string", attr: "referrerpolicy" }
    }).define({
      origin() {
        return new URL(this.href).origin;
      },
      protocol: buildHyperlinkDefinition("protocol"),
      username: buildHyperlinkDefinition("username"),
      password: buildHyperlinkDefinition("password"),
      host: buildHyperlinkDefinition("host"),
      hostname: buildHyperlinkDefinition("hostname"),
      port: buildHyperlinkDefinition("port"),
      pathname: buildHyperlinkDefinition("pathname"),
      search: buildHyperlinkDefinition("search"),
      hash: buildHyperlinkDefinition("hash")
    }).html`
      <a id=anchor
      href={href}
      target={target}
      download={download}
      ping={ping}
      rel={rel}
      hreflang={hreflang}
      referrerpolicy={referrerPolicy}
      ></a>
    `.methods({
      toString() {
        return this.href;
      }
    });
  }

  // components/Ripple.js
  var Ripple_default = CustomElement.extend().set({
    hadRippleHeld: false,
    hadRippleReleased: false,
    rippleStarted: false
  }).observe({
    /** Current lifecycle state for the ripple (e.g. 'filled', 'complete'). */
    rippleState: "string",
    /** When true, keep the ripple in the DOM after animation ends. */
    keepAlive: "boolean",
    /** X offset (px) from center used to position the ripple. */
    _positionX: "float",
    /** Y offset (px) from center used to position the ripple. */
    _positionY: "float",
    /** Computed ripple radius (px) used for sizing/animation. */
    _radius: "float",
    /** Hold the ripple (e.g. for long-press); triggers hold/release tracking. */
    holdRipple: {
      type: "boolean",
      changedCallback(oldValue, newValue) {
        if (newValue) {
          this.hadRippleHeld = true;
        } else {
          this.hadRippleReleased = true;
        }
      }
    }
  }).observe({
    /** Computed animation/style object used to position and size the ripple. */
    _positionStyle: {
      ...ELEMENT_ANIMATION_TYPE,
      get({ _positionX, _positionY, _radius }) {
        if (_radius == null) return null;
        return {
          styles: {
            minHeight: `${_radius}px`,
            minWidth: `${_radius}px`,
            boxShadow: `0 0 calc(0.10 * ${_radius}px) calc(0.10 * ${_radius}px) currentColor`,
            top: `calc(50% + ${_positionY}px)`,
            left: `calc(50% + ${_positionX}px)`
          }
        };
      }
    }
  }).methods({
    /**
     * @param {number} [x] offsetX
     * @param {number} [y] offsetY
     * @param {number} [size]
     * @return {void}
     */
    updatePosition(x, y, size) {
      let hypotenuse = size;
      const { offsetParent } = this;
      if (!offsetParent) return;
      const { clientWidth: parentWidth, clientHeight: parentHeight } = offsetParent;
      x ??= parentWidth / 2;
      y ??= parentHeight / 2;
      if (!hypotenuse) {
        const width = x >= parentWidth / 2 ? x : parentWidth - x;
        const height = y >= parentHeight / 2 ? y : parentHeight - y;
        hypotenuse = 2 * Math.hypot(width, height);
      }
      this._positionX = x - parentWidth / 2;
      this._positionY = y - parentHeight / 2;
      this._radius = hypotenuse;
    },
    /** Complete the ripple lifecycle: either mark complete or remove. */
    handleRippleComplete() {
      if (this.keepAlive) {
        this.setAttribute("ripple-state", "complete");
      } else {
        this.remove();
      }
    }
  }).events({
    animationstart({ animationName }) {
      if (animationName !== "ripple-fade-in") return;
      if (this.rippleStarted && !this.keepAlive) {
        this.remove();
        return;
      }
      this.rippleStarted = true;
    },
    animationend({ animationName }) {
      switch (animationName) {
        case "ripple-fade-in":
          this.rippleState = "filled";
          break;
        case "ripple-fade-out":
          this.handleRippleComplete();
          break;
        default:
      }
    }
  }).css`
    /* stylelint-disable liberty/use-logical-spec */
    :host {
      --enter-delay: 80ms;
      --touch-down-acceleration: 1024;
      --touch-up-acceleration: 3400;
      --mdw-ripple-expand-duration: 300ms;
      --mdw-ripple-simple-duration: 200ms;
      --mdw-ripple-fade-out-duration: 333ms;
      --mdw-ripple-standard-easing: var(--mdw-motion-standard-easing, cubic-bezier(0.4, 0.0, 0.2, 1));
      --mdw-ripple-deceleration-easing: var(--mdw-motion-deceleration-easing, cubic-bezier(0.0, 0.0, 0.2, 1));
    
      --size: 0;
      position: absolute;
      top: 50%;
      left: 50%;
    
      display: block;
    
      min-block-size: 141.42%; /* 2 * 100% */
      min-inline-size: 141.42%;
    
      pointer-events: none;
    
      -webkit-tap-highlight-color: transparent;
    
      opacity: 0.12;
      transform: translateX(-50%) translateY(-50%) scale(1);
    
      background-color: currentColor;
      border-radius: 50%;
    
      /* Adds feathered appearance to ripple */
      box-shadow: 0 0 calc(0.10 * var(--size)) calc(0.10 * var(--size)) currentColor;
    
      transition-delay: 0s;
      transition-duration: var(--mdw-ripple-simple-duration);
      transition-property: background-color, color;
      transition-timing-function: var(--mdw-ripple-standard-easing);
    
      animation-name: ripple-fade-in, none;
      animation-duration: var(--mdw-ripple-expand-duration), var(--mdw-ripple-fade-out-duration);
      animation-timing-function: linear, var(--mdw-ripple-deceleration-easing);
      animation-direction: normal;
      animation-fill-mode: forwards;
      /* stylelint-disable-next-line liberty/use-logical-spec */
      will-change: transform, opacity, top, left, box-shadow;
    
      aspect-ratio: 1/1;
    }
    
    :host([ripple-state="filled"]) {
      animation-name: none, ripple-fade-out;
    }
    
    :host([ripple-state="filled"][hold-ripple]) {
      animation-name: ripple-fade-in, none;
    }
    
    :host([ripple-state="complete"]) {
      animation-name: none, ripple-fade-out;
      animation-duration: 0s;
    }
    
    @keyframes ripple-fade-in {
      from {
        transform: translateX(-50%) translateY(-50%) scale(0);
      }
    }
    
    @keyframes ripple-fade-out {
    
      to { opacity: 0; }
    }
  `.autoRegister("mdw-ripple");

  // mixins/RippleMixin.js
  function RippleMixin(Base) {
    return Base.set({
      /** WeakRef to the last appended Ripple instance (used to release/hold) */
      /** @type {WeakRef<InstanceType<Ripple>>} */
      _lastRippleWeakRef: null,
      /** Flag set if ripple was added this event loop to avoid duplicate ripples */
      _rippleAdded: false
    }).define({
      _lastRipple: {
        get() {
          var _a5;
          const element = (_a5 = this._lastRippleWeakRef) == null ? void 0 : _a5.deref();
          if (element == null ? void 0 : element.isConnected) return element;
          return null;
        },
        set(ripple) {
          this._lastRippleWeakRef = ripple ? new WeakRef(ripple) : null;
        }
      }
    }).methods({
      /**
       * @param {number} [x]
       * @param {number} [y]
       * @param {boolean} [hold]
       * @return {InstanceType<Ripple>}
       */
      addRipple(x, y, hold) {
        const { rippleContainer } = this.refs;
        if (!rippleContainer.isConnected) return null;
        const ripple = new Ripple_default();
        this._rippleAdded = true;
        queueMicrotask(() => {
          this._rippleAdded = false;
        });
        rippleContainer.append(ripple);
        if (hold) {
          ripple.holdRipple = true;
        }
        ripple.updatePosition(x, y);
        this._lastRipple = ripple;
        return ripple;
      }
    }).html`
      <div id=ripple-container mdw-if={!disabledState} aria-hidden=true></div>
    `.events({
      "~pointerdown"(event) {
        if (event.button) return;
        if (this.disabledState) return;
        const { rippleContainer } = this.refs;
        if (!rippleContainer.isConnected) return;
        const rect = rippleContainer.getBoundingClientRect();
        const x = event.pageX - rect.left - window.pageXOffset;
        const y = event.pageY - rect.top - window.pageYOffset;
        const lastRipple = this._lastRipple;
        if (lastRipple) {
          lastRipple.holdRipple = false;
        }
        this.addRipple(x, y, true);
      },
      "~click"(e) {
        if (this._rippleAdded) {
          return;
        }
        if (e.pointerType || e.detail) return;
        if (this.disabledState) return;
        if (this.pressedState || this._keyReleased) return;
        const lastRipple = this._lastRipple;
        if (lastRipple) {
          lastRipple.holdRipple = false;
        }
        this.addRipple();
      }
    }).on({
      pressedStateChanged(oldValue, pressed) {
        const ripple = this._lastRipple;
        if (!pressed) {
          if (ripple) {
            ripple.holdRipple = false;
          }
          return;
        }
        if (!ripple || ripple.hadRippleReleased) {
          if (this._lastInteraction !== "key") {
            return;
          }
          this.addRipple(null, null, true);
          return;
        }
        if (ripple.hadRippleHeld) return;
        ripple.holdRipple = true;
      }
    }).css`
      :host {
        --mdw-state__pressed-opacity: 0;
      }
      
      #ripple-container {
        position: absolute;
        inset: 0;
      
        overflow: hidden;
      
        pointer-events: none;

        border-radius: inherit;
      }
    `;
  }

  // components/Button.js
  var Button_default = CustomElement.extend().mixin(ThemableMixin).mixin(DensityMixin).mixin(StateMixin).mixin(ElevationMixin).mixin(ShapeMixin).mixin(RippleMixin).mixin(InputMixin).mixin(HyperlinkMixin).define({
    /**
     * Returns the element used as the state target for visual states
     * (e.g., pressed/hover). Typically the internal control element.
     * @return {HTMLElement}
     */
    stateTargetElement() {
      return this.refs.control;
    }
  }).set({
    stateLayer: true,
    _allowedTypes: ["button", "submit", "reset", "file"]
  }).observe({
    /** The underlying control `type` (button, submit, reset, file). */
    type: {
      empty: "button",
      /**
       * @param {string} value
       * @param {*} internalSet
       */
      set(value, internalSet) {
        const enumeratedValue = (value == null ? void 0 : value.toLowerCase()) ?? "button";
        internalSet(
          this._allowedTypes.includes(enumeratedValue) ? enumeratedValue : "button"
        );
      }
    },
    /** Bound to [elevated] specifying whether the element should be elevated. */
    elevated: "boolean",
    /** Visual filled variant; may be "tonal" or boolean-filled token. */
    filled: "string",
    /** Whether the button should render an outline. */
    outlined: "boolean",
    /** Icon name (uses internal `mdw-icon` when set). */
    icon: "string",
    /** Ink color override for the icon. */
    iconInk: "string",
    // Overrides to string instead of DOMString
    /** Image source URL for an icon. */
    src: "string",
    /** Inline SVG markup to render as icon. */
    svg: "string",
    /** SVG `viewBox` attribute for inline SVG icons. */
    viewBox: "string",
    /** Path data for an inline SVG icon. */
    svgPath: "string"
  }).expressions({
    hasIcon({ icon, svg, src, svgPath } = this) {
      return icon ?? svg ?? src ?? svgPath;
    },
    iconVariation({ outlined } = this) {
      return outlined ? null : "filled";
    }
  }).methods({
    /** @type {HTMLElement['focus']} */
    focus(...options) {
      if (this.href) {
        this.refs.anchor.focus(...options);
      } else {
        this.refs.control.focus(...options);
      }
    }
  }).html`
    <mdw-icon mdw-if={hasIcon} id=icon ink={iconInk} disabled={disabledState}
      outlined={outlined} variation={iconVariation} aria-hidden=true svg={svg} src={src}
      svg-path={svgPath} view-box={viewBox} icon={icon}></mdw-icon>
    <slot id=slot disabled={disabledState} aria-hidden=true>{_defaultValue}</slot>
  `.recompose(({ refs: { anchor, control } }) => {
    control.setAttribute("mdw-if", "{!href}");
    control.setAttribute("role", "button");
    anchor.setAttribute("mdw-if", "{href}");
    anchor.setAttribute("aria-label", "{_computedAriaLabel}");
    anchor.setAttribute("aria-labelledby", "{_computedAriaLabelledby}");
  }).css`
    :host {
      --mdw-shape__size: var(--mdw-shape__full);
      --mdw-ink: var(--mdw-color__primary);

      --mdw-type__font: var(--mdw-typescale__label-large__font);
      --mdw-type__letter-spacing: var(--mdw-typescale__label-large__letter-spacing);

      display: inline-flex;

      align-items: center;
      gap: 0;
      justify-content: center;
      vertical-align: middle;

      /* box-sizing: border-box; */
      min-block-size: 24px;
      min-inline-size: 24px;

      padding-block: calc(8px + (var(--mdw-density) * 2px));
      padding-inline: calc(12px + (var(--mdw-density) * 2px));

      -webkit-tap-highlight-color: transparent;
      -webkit-user-select: none;
      user-select: none;

      color: rgb(var(--mdw-ink));

      font: var(--mdw-type__font);
      letter-spacing: var(--mdw-type__letter-spacing);
    }

    :host(:where([elevated],[filled])) {
      transition: box-shadow 200ms;
      will-change: box-shadow;
    }

    /** Elevated Color Defaults */
    :host(:where([elevated])) {
      --mdw-bg: var(--mdw-color__surface-container-low);
      --mdw-ink: var(--mdw-color__primary);
      box-shadow: var(--mdw-elevation__box-shadow__1);
    }
    /** Filled Color Defaults */
    :host(:where([filled])) {
      --mdw-bg: var(--mdw-color__primary);
      --mdw-ink: var(--mdw-color__on-primary);
      box-shadow: var(--mdw-elevation__box-shadow__0);
    }

    :host(:where([elevated]:hover:not(:active))) {
      box-shadow: var(--mdw-elevation__box-shadow__2);
    }

    :host(:where([filled]:hover:not(:active))) {
      box-shadow: var(--mdw-elevation__box-shadow__1);
    }

    :host(:where([elevated]:disabled)) {
      box-shadow: var(--mdw-elevation__box-shadow__0);
    }

    :host(:where([filled]:disabled)) {
      box-shadow: var(--mdw-elevation__box-shadow__0);
    }

    /** Filled Tonal Color Defaults */
    :host(:where([filled="tonal"])) {
      --mdw-bg: var(--mdw-color__secondary-container);
      --mdw-ink: var(--mdw-color__on-secondary-container);
    }
    /** Outlined Color Defaults */
    :host(:where([outlined])) {
      --mdw-ink: var(--mdw-color__primary);
    }

    :host(:where([icon])) {
      gap: 8px;

      padding-inline: calc(12px + (var(--mdw-density) * 2px)) calc(16px + (var(--mdw-density) * 2px));
    }

    :host(:where([outlined], [elevated], [filled])) {
      padding-inline: calc(24px + (var(--mdw-density) * 2px));
    }

    :host(:where([icon]):where([outlined], [elevated], [filled])) {
      gap: 8px;

      padding-inline: calc(16px + (var(--mdw-density) * 2px)) calc(24px + (var(--mdw-density) * 2px));
    }

    :host(:where([elevated],[filled],[color])) {
      background-color: rgb(var(--mdw-bg));
    }

    #slot {
      text-align: center;
      text-decoration: none;
      white-space: nowrap;
    }

    #control {
      cursor: pointer;
    }

    #anchor {
      position: absolute;
      inset: 0;

      cursor: pointer;
      outline: none;
    }

    :host([disabled]) {
      /* cursor: not-allowed; */

      color: rgba(var(--mdw-color__on-surface), 0.38);
    }

    :host([disabled]:is([elevated], [filled])) {
      background-color: rgba(var(--mdw-color__on-surface), 0.12);
      color: rgba(var(--mdw-color__on-surface), 0.38);
    }

    #slot[disabled] {
      color: rgba(var(--mdw-color__on-surface), 0.38);
    }

    #icon {
      font-size: calc(18/14 * 1em);
    }

    #icon[disabled] {
      opacity: 0.38;

      color: rgba(var(--mdw-color__on-surface));
    }

    #control[form-disabled] {
      cursor: not-allowed;
    }

    @media (any-pointer: coarse) {
      #touch-target {
        visibility: inherit;
      }
    }
  `.autoRegister("mdw-button");

  // components/IconButton.js
  var IconButton_default = Button_default.extend().mixin(TooltipTriggerMixin).set({
    _allowedTypes: ["button", "submit", "reset", "checkbox", "file"]
  }).observe({
    /** ARIA pressed state for toggle buttons (checkbox type). */
    _ariaPressed: {
      get({ type, checked, indeterminate }) {
        if (type !== "checkbox") return null;
        return indeterminate ? "mixed" : checked ? "true" : "false";
      }
    },
    /** True when the underlying control behaves as a toggle (checkbox). */
    _isToggle({ type }) {
      return type === "checkbox";
    },
    /** When present, enables automatic tooltip behavior from the mixin. */
    autoTooltip: { empty: true }
  }).expressions({
    iconVariation({ checked, outlined, _isToggle }) {
      if (!checked && (_isToggle || outlined)) return null;
      return "filled";
    }
  }).childEvents({
    control: {
      keydown(event) {
        if (event.key !== "Enter" && event.key !== " ") return;
        const input = (
          /** @type {HTMLInputElement} */
          event.currentTarget
        );
        if (input.type !== "checkbox") return;
        event.stopImmediatePropagation();
        event.stopPropagation();
        event.preventDefault();
        if (input.disabled) return;
        input.click();
      }
    }
  }).recompose(({ refs: { icon, control, outline } }) => {
    icon.removeAttribute("mdw-if");
    control.setAttribute("aria-pressed", "{_ariaPressed}");
    outline.setAttribute("toggle", "{_isToggle}");
    outline.setAttribute("selected", "{checked}");
  }).observe({
    _styles: {
      ...ELEMENT_STYLE_TYPE,
      get({ checked, disabled, filled, outlined, _isToggle }) {
        if (!_isToggle) return null;
        if (disabled) return null;
        if (outlined) {
          if (checked) {
            return {
              backgroundColor: "rgb(var(--mdw-bg))"
            };
          }
          return {
            color: "rgb(var(--mdw-color__on-surface-variant))"
          };
        }
        if (checked) return null;
        if (filled == null) return null;
        return {
          backgroundColor: "rgb(var(--mdw-color__surface-container-highest))",
          color: filled === "tonal" ? "rgb(var(--mdw-color__on-surface-variant))" : "rgb(var(--mdw-bg))"
        };
      }
    }
  }).css`
    :host {
      --mdw-shape__size: var(--mdw-shape__full);
      --mdw-ink: rgb(var(--mdw-color__on-surface-variant));

      align-items: center;
      justify-content: center;

      min-block-size: 1em;
      min-inline-size: 1em;

      padding: max(8px, calc(8px + (var(--mdw-density) * 2px)));

      font-size: 24px;

      transition-property: background-color, box-shadow;
    }

    :host(:where([type="checkbox"])) {
      --mdw-ink: var(--mdw-color__primary);
    }

    /** Filled | Filled Checked */
    :host(:where([filled])) {
      --mdw-ink: var(--mdw-color__on-primary);
      --mdw-bg: var(--mdw-color__primary);
    }

    /** Tonal | Tonal Checked */
    :host(:where([filled="tonal"])) {
      --mdw-ink: var(--mdw-color__on-secondary-container);
      --mdw-bg: var(--mdw-color__secondary-container);
    }

    /** Outlined | Outlined Unchecked */
    :host(:where([outlined])) {
      --mdw-ink: var(--mdw-color__on-surface-variant);
      background-color: transparent;
    }

    /** Outlined | Outlined Unchecked */
    :host(:where([outlined][type="checkbox"])) {
      --mdw-bg: var(--mdw-color__inverse-surface);
      --mdw-ink: var(--mdw-color__inverse-on-surface);
    }

    #slot { display: none; }

    #icon {
      pointer-events: none;

      font-size: inherit;

      /* stylelint-disable-next-line liberty/use-logical-spec */
      transition-property: color, inline-size, width;
    }

    #state {
      z-index:1;
    }

    #ripple-container {
      z-index:2;
    }

    #outline[focused] {
      opacity: 1;

      color: inherit;
    }
    
    #outline[focused][toggle] {
      color: rgb(var(--mdw-color__outline));
    }

    #outline[selected]:not([disabled]) {
      opacity: 0;
    }

  `.autoRegister("mdw-icon-button");

  // components/Progress.js
  var Progress_default = CustomElement.extend().mixin(ThemableMixin).observe({
    /** Render the circular variant when true; otherwise render a linear bar. */
    circle: "boolean",
    /** Current progress value. When present the indicator is determinate. */
    value: "float",
    /** Maximum progress value (defaults to 100 when not set). */
    max: "float",
    /** When true, the progress will auto-hide when complete. */
    autoHide: "boolean",
    /** Internal inline style string used to animate the determinate bar. */
    _determinateStyle: "string"
  }).observe({
    /**
     * Computed fractional progress (0.01.0) derived from `value` and `max`.
     * Used to drive the determinate animation and CSS variables.
     */
    _valueAsFraction: {
      type: "float",
      get({ value, max }) {
        return value / (max || 100);
      },
      /** Update `_determinateStyle` CSS variables when the fraction changes. */
      changedCallback(oldValue, newValue) {
        this._determinateStyle = `
        --previous:${oldValue ?? newValue ?? 0};
        --value:${newValue ?? 0};
      `;
      }
    }
  }).expressions({
    /** True when `value` is provided, indicating a determinate progress state. */
    isDeterminate({ value }) {
      return value != null;
    }
  }).define({
    /** Proxy to the internal `<progress>` element's `position` property. */
    position() {
      return (
        /** @type {HTMLProgressElement} */
        this.refs.progress.position
      );
    },
    /** Proxy to the internal `<progress>` element's `labels` collection. */
    labels() {
      return (
        /** @type {HTMLProgressElement} */
        this.refs.progress.labels
      );
    }
  }).html`
    <div id=determinate style="{_determinateStyle}">
      <progress id=progress value={value} max={max} circle={circle}></progress>
      <div mdw-if={circle} id=circle>
        <div id=semi1 class=semi></div>
        <div id=semi2 class=semi></div>
      </div>
    </div>
    <div mdw-if={!isDeterminate} id=indeterminate>
      <div mdw-if={!circle} id=indeterminate-line>
        <div id=line1 class=line value={value}></div>
        <div id=line2 class=line value={value}></div>
      </div>
      <div mdw-if={circle} id=indeterminate-circle>
        <div id=arc2 class=arc></div>
        <div id=arc3 class=arc></div>
        <div id=arc4 class=arc></div>
      </div>
    </div>
  `.css`
    /* Base Styles */

    :host {
      --mdw-bg: var(--mdw-color__surface-container-highest);
      --mdw-ink: var(--mdw-color__primary);
      --mdw-progress__opacity__duration: 500ms;
      position: relative;

      display: inline-block;
      overflow: hidden;
      vertical-align: middle;

      min-block-size: 4px;
      inline-size: 100%;

      opacity: 1;

      background-color: rgb(var(--mdw-bg));
      color: rgb(var(--mdw-ink));

      transition: opacity 500ms 275ms;
    }

    :host([auto-hide]) {
      will-change: opacity;
    }

    :host([auto-hide][value="100"]) {
      opacity:0;

      transition: opacity 1s 1s;
    }

    #determinate {
      --previous: 0;
      --value: 0;
    }

    #progress {
      position: absolute;
      inset: 0;

      box-sizing: border-box;
      block-size: 100%;
      inline-size: 100%;
      border: none; /* FireFox */

      -moz-appearance: none;
      appearance: none;

      opacity:0;
      transform: scaleX(var(--value, 0));
      transform-origin: 0 0;

      background-color: currentColor;
      color: inherit;

      transition: transform 275ms, opacity var(--mdw-progress__opacity__duration);
      will-change: transform, opacity;
    }

    #progress::-webkit-progress-bar {
      display: none;
    }

    #progress::-moz-progress-bar  {
      display: none; /* Doesn't always work */

      block-size: 0;
    }

    #progress[value] {
      opacity:1;
      transform: scaleX(var(--value, 0));
    }
  `.css`
    /* Line Styles */

    /* https://github.com/material-components/material-components-android/blob/ed77ab36ccac98df24e55060d58406c5981a9062/lib/java/com/google/android/material/progressindicator/ */

    :host {
      --mdw-progress__line1-head__timing: cubic-bezier(0.2, 0.8, 0, 1.0);
      --mdw-progress__line1-tail__timing: cubic-bezier(0.4, 0.0, 1.0, 1.0);
      --mdw-progress__line2-head__timing: cubic-bezier(0.0, 0.65, 0, 1.0);
      --mdw-progress__line2-tail__timing: cubic-bezier(0.1, 0.45, 0, 1.0);
      --mdw-progress__line__duration: 1800ms;
    }

    @media (prefers-reduced-motion) {
      :host {
        --mdw-progress__line__duration: 18000ms
      }
    }

    .line {
      opacity: 1;

      transition: opacity var(--mdw-progress__opacity__duration);
      will-change: opacity;
    }

    .line,
    .line::after {
      position: absolute;
      inset: 0;

      overflow: hidden;

      animation-duration: var(--mdw-progress__line__duration);
      animation-timing-function: linear;
      animation-iteration-count: infinite;
      animation-fill-mode: forwards;
    }

    .line::after {
      content: '';

      background-color: currentColor;

      animation: inherit;
      will-change: transform;
    }

    #line1 {
      animation-name: l1h;
    }

    #line2 {
      animation-name: l2h;
    }

    #line1::after {
      animation-name: l1t;
    }

    #line2::after {
      animation-name: l2t;
    }

    .line[value] {
      opacity: 0;
      visibility: hidden;

      transition: opacity var(--mdw-progress__opacity__duration), visibility 1ms var(--mdw-progress__opacity__duration);
    }

    /**
      * L1H = 1267 / +533 = 70.39% - 100%
      * L1T = 1000 / +567 = 55.56% - 87.05%
      * L2H = 0333 / +850 = 18.50% - 65.72%
      * L2T = 0000 / +750 = 0% - 41.67%
      * Total = 1800ms
      *
      *    t      l1h    l1t      l2h     l2t
      * --------------------------------------
      * 0.0000  0.0000  0.0000  0.0000  0.0000
      * 0.1850  0.0000  0.0000  0.0000  0.5899
      * 0.4167  0.0000  0.0000  0.7374  1.0000
      * 0.5556  0.0000  0.0000  0.9072  1.0000
      * 0.6572  0.0000  0.1544  1.0000  1.0000
      * 0.7039  0.0000  0.2939  1.0000  1.0000
      * 0.8706  0.7918  1.0000  1.0000  1.0000
      * 1.0000  1.0000  1.0000  1.0000  1.0000
    */

    @keyframes l1h {
      0% {
        transform: translateX(0%);
      }

      70.4% {
        transform: translateX(0%);

        animation-timing-function: var(--mdw-progress__line1-head__timing);
      }

      100% {
        transform: translateX(100%);
      }
    }
    @keyframes l1t {
      0% {
        transform: translateX(-100%);
      }

      55.6% {
        transform: translateX(-100%);

        animation-timing-function: var(--mdw-progress__line1-tail__timing);
      }

      87.1% {
        transform: translateX(0%);
      }

      100% {
        transform: translateX(0%);
      }
    }
    @keyframes l2h {
      0% {
        transform: translateX(0%);
      }

      18.5% {
        transform: translateX(0%);

        animation-timing-function: var(--mdw-progress__line2-head__timing);
      }

      65.72% {
        transform: translateX(100%);
      }

      to {
        transform: translateX(100%);
      }
    }
    @keyframes l2t {
      0% {
        transform: translateX(-100%);

        animation-timing-function: var(--mdw-progress__line2-tail__timing);
      }

      41.67% {
        transform: translateX(0%);
      }

      to {
        transform: translateX(0%);
      }
    }

  `.css`
    /* Circle Styles */
    /* stylelint-disable liberty/use-logical-spec */
    /** https://github.com/material-components/material-components-android/blob/ed77ab36ccac98df24e55060d58406c5981a9062/lib/java/com/google/android/material/progressindicator/CircularIndeterminateAnimatorDelegate.java */

    :host {
      --mdw-progress__circle__timing: cubic-bezier(0.4, 0.0, 0.2, 1);
      --mdw-progress__circle__margin: 4px;
      --mdw-progress__circle__duration: 5400ms;
      --mdw-progress__circle__duration__expand: 667ms;
      --mdw-progress__circle__duration__collapse: 667ms;
      --mdw-progress__circle__duration__fade-in: 333ms;
      --mdw-progress__circle__duration__complete-end: 333ms;
    }

    @media (prefers-reduced-motion) {
      :host {
        --mdw-progress__circle__duration: 54000ms;
      }
    }

    #circle {
      --startA: min(0.5, var(--previous));
      --endA: min(0.5, var(--value));
      --travelA: max(
          calc(var(--startA) - var(--endA)),
          calc(var(--endA) - var(--startA))
        );
      --delayA: max(0, calc(var(--previous) - 0.5));
      --startB: max(0, calc(var(--previous) - 0.5));
      --endB: max(0, calc(var(--value) - 0.5));
      --travelB: max(
          calc(var(--startB) - var(--endB)),
          calc(var(--endB) - var(--startB))
        );
      --delayB: max(0, 0.5 - calc(var(--previous)));

      position: absolute;
      inset: 0;
    }

    :host([circle]) {
      block-size: 48px;
      inline-size: 48px;
    }

    :host([circle]:not([color])) {
      background-color: transparent;
    }

    #progress[circle] {
      visibility: hidden;
    }

    .semi {
      position: absolute;
      inset: var(--mdw-progress__circle__margin);

      overflow: hidden;

      box-sizing: border-box;
    }

    #semi1 {
      left: 50%;
    }

    #semi2 {
      right: 50%;
    }

    .semi::after {
      content: "";

      position: absolute;
      inset: 0;

      box-sizing: border-box;
      border: solid currentcolor 4px;

      transform: rotate(var(--rotation));

      background-color: transparent;
      border-radius: 50%;

      transition: transform 400ms;
      transition-timing-function: linear;
    }

    #semi1::after {
      --rotation: min(180deg, calc(var(--value) * 360deg));
      left: -100%;

      clip-path: inset(0 50% 0 0);

      transition-delay: calc(var(--delayA) * var(--mdw-progress__circle__duration__expand));
      transition-duration: calc(var(--travelA) * var(--mdw-progress__circle__duration__expand));
    }

    #semi2::after {
      --rotation: max(0deg, calc(var(--value) * 360deg - 180deg));
      right: -100%;

      clip-path: inset(0 0 0 50%);

      transition-delay: calc(var(--delayB) * var(--mdw-progress__circle__duration__expand));
      transition-duration: calc(var(--travelB) * var(--mdw-progress__circle__duration__expand));
    }

    #indeterminate-circle {
      position: absolute;
      inset: 0;

      display: block;

      animation: rotate-cw calc(var(--mdw-progress__circle__duration) / 4) linear infinite;
    }

    .arc {
      position: absolute;
      inset: var(--mdw-progress__circle__margin);

      overflow: hidden;

      box-sizing: border-box;

      animation: rotate-jump var(--mdw-progress__circle__duration) steps(1,end) infinite;
    }

    .arc::after {
      content: "";

      position: absolute;
      inset: 0;

      box-sizing: border-box;
      border: solid currentcolor 4px;

      background-color: transparent;
      border-radius: 50%;

      animation: grow-shrink calc(var(--mdw-progress__circle__duration) / 4) var(--mdw-progress__circle__timing) infinite;
    }

    #arc2 {
      bottom: 50%;
      left: 50%;

      transform-origin: 0 100%;
    }

    #arc3 {
      top: 50%;
      right: 50%;

      transform-origin: 100% 0;
    }

    #arc4 {
      top: 50%;
      left: 50%;

      transform-origin: 0 0;
    }

    #arc2:after {
      bottom: -100%;
      left: -100%;

      clip-path: polygon(0% 0%, 50% 0%, 50% 50%, 100% 50%, 100% 100%, 0% 100%);
    }

    #arc3:after {
      top: -100%;
      right: -100%;

      clip-path: inset(0 50% 50% 0);
    }

    #arc4:after {
      top: -100%;
      left: -100%;

      clip-path: inset(0 50% 0 0);
    }

    @keyframes rotate-cw {
      from {
        transform: rotate(0deg);
      }

      to {
        transform: rotate(360deg);
      }
    }

    @keyframes rotate-jump {
      0% { transform: scaleX(1) rotate(0deg); }

      12.5% { transform: scaleX(-1) rotate(-270deg); }

      25% { transform: scaleX(1) rotate(270deg); }

      37.5% {transform: scaleX(-1) rotate(-180deg);}

      50% { transform: scaleX(1) rotate(180deg); }

      62.5% { transform: scaleX(-1) rotate(-90deg); }

      75% { transform: scaleX(1) rotate(90deg); }

      87.5% { transform: scaleX(-1) rotate(0deg); }

      to { transform: scaleX(1) rotate(0deg); }
    }

    @keyframes grow-shrink {
      from {
        transform: rotate(calc(0.01 * 360deg));
      }

      50% {
        transform: rotate(calc(0.73 * 360deg));
      }

      to {
        transform: rotate(calc(0.01 * 360deg));
      }
    }
  `.autoRegister("mdw-progress");

  // mixins/ShapeMaskedMixin.js
  function ShapeMaskedMixin(Base) {
    return Base.observe({
      /** Show top cut/shape on the element */
      shapeTop: "boolean",
      /** Show bottom cut/shape on the element */
      shapeBottom: "boolean",
      /** Show start-side cut/shape (logical start) */
      shapeStart: "boolean",
      /** Show end-side cut/shape (logical end) */
      shapeEnd: "boolean",
      /** Predefined shape size/style name (none|extra-small|small|medium|large|extra-large|full|inherit) */
      shapeStyle: "string"
    }).css`
    :host {
      --mdw-shape__size: 0px;
      --mdw-shape__ltr: calc(0.5 * var(--mdw-dir, 1) + 0.5); /* 1 if LTR, 0 if RTL */
      --mdw-shape__rtl: calc(-0.5 * var(--mdw-dir, 1) + 0.5); /* 0 if LTR, 1 if RTL */
      --mdw-shape__mask: none;

      /** By default, fallback to border-radius */
      --mdw-shape__rounded: 1;
      --mdw-shape__inline-start-deg: calc(var(--mdw-dir, 1) * -90deg);

      --mdw-shape__size__top-start-size: var(--mdw-shape__size);
      --mdw-shape__size__top-end-size: var(--mdw-shape__size);
      --mdw-shape__size__bottom-start-size: var(--mdw-shape__size);
      --mdw-shape__size__bottom-end-size: var(--mdw-shape__size);
      /* (1/2n + 1/2)L + (-1/2n + 1/2)R  */
      
      --mdw-shape__size__top-left-size: calc((var(--mdw-shape__ltr) * var(--mdw-shape__size__top-start-size)) + (var(--mdw-shape__rtl) * var(--mdw-shape__size__top-end-size)));
      --mdw-shape__size__top-right-size: calc((var(--mdw-shape__rtl) * var(--mdw-shape__size__top-start-size)) + (var(--mdw-shape__ltr) * var(--mdw-shape__size__top-end-size)));
      --mdw-shape__size__bottom-left-size: calc((var(--mdw-shape__ltr) * var(--mdw-shape__size__bottom-start-size)) + (var(--mdw-shape__rtl) * var(--mdw-shape__size__bottom-end-size)));
      --mdw-shape__size__bottom-right-size: calc((var(--mdw-shape__rtl) * var(--mdw-shape__size__bottom-start-size)) + (var(--mdw-shape__ltr) * var(--mdw-shape__size__bottom-end-size)));

      border-start-start-radius: calc(var(--mdw-shape__rounded) * var(--mdw-shape__size__top-start-size));
      border-start-end-radius: calc(var(--mdw-shape__rounded) * var(--mdw-shape__size__top-end-size));
      border-end-start-radius: calc(var(--mdw-shape__rounded) * var(--mdw-shape__size__bottom-start-size));
      border-end-end-radius: calc(var(--mdw-shape__rounded) * var(--mdw-shape__size__bottom-end-size));
    }

    :host([shape-style="none"]) {
      --mdw-shape__size: 0px;
    }
    
    :host([shape-style="extra-small"]) {
      --mdw-shape__size: var(--mdw-shape__extra-small);
    }
    
    :host([shape-style="small"]) {
      --mdw-shape__size: var(--mdw-shape__small);
    }
    
    :host([shape-style="medium"]) {
      --mdw-shape__size: var(--mdw-shape__medium);
    }
    
    :host([shape-style="large"]) {
      --mdw-shape__size: var(--mdw-shape__large);
    }
    
    :host([shape-style="extra-large"]) {
      --mdw-shape__size: var(--mdw-shape__extra-large);
    }
    
    :host([shape-style="full"]) {
      --mdw-shape__size: var(--mdw-shape__full);
    }
    
    :host([shape-style="inherit"]) {
      --mdw-shape__size: inherit;
    }
    
    :host([shape-top]) {
      --mdw-shape__size__bottom-start-size: 0px;
      --mdw-shape__size__bottom-end-size: 0px;
      --mdw-shape__mask: linear-gradient(transparent 50%, black 50%);
    }
    
    :host([shape-bottom]) {
      --mdw-shape__size__top-start-size: 0px;
      --mdw-shape__size__top-end-size: 0px;
      --mdw-shape__mask: linear-gradient(black 50%, transparent 50%);
    }
    
    :host([shape-start]) {
      --mdw-shape__size__top-end-size: 0px;
      --mdw-shape__size__bottom-end-size: 0px;
      --mdw-shape__mask: linear-gradient(var(--mdw-shape__inline-start-deg), black 50%, transparent 50%);
    }
    
    :host([shape-end]) {
      --mdw-shape__size__top-start-size: 0px;
      --mdw-shape__size__bottom-start-size: 0px;
      --mdw-shape__mask: linear-gradient(var(--mdw-shape__inline-start-deg), transparent 50%, black 50%);
    }

    @supports(-webkit-mask-box-image: none) {
      :host {
        /* Inherit all the way up to :root */
        --mdw-shape__rounded: inherit;
      }
    }

    @supports(-webkit-mask-box-image: none) {
      :host {
        -webkit-mask-box-image: var(--mdw-shape__mask-border-source)
          8 fill /
          var(--mdw-shape__size)
          stretch;

        -webkit-mask: var(--mdw-shape__mask);

        transition-duration: 200ms;
        transition-property: -webkit-mask-box-image-width;
        will-change: -webkit-mask-box-image;
      }
    }
  `;
  }

  // components/Shape.js
  var Shape_default = CustomElement.extend().mixin(ShapeMaskedMixin).html`<slot id=slot></slot>`.autoRegister("mdw-shape");

  // mixins/FlexableMixin.js
  function FlexableMixin(Base) {
    return Base.observe({
      /** Set `display: block` on the host (boolean) */
      block: "boolean",
      /** Use inline flex layout: `display: inline-flex` (boolean) */
      inline: "boolean",
      /** Switch main axis to horizontal: `flex-direction: row` (boolean) */
      row: "boolean",
      /**
       * Main-axis alignment / justification.
       * Allowed: 'start'|'center'|'end'|'between'|'around'|'stretch'|'baseline'.
       * Default: 'start'.
       */
      x: {
        type: "string",
        empty: "start",
        /** @type {'start'|'center'|'end'|'between'|'around'|'stretch'|'baseline'} */
        value: "start"
      },
      /**
       * Cross-axis alignment / alignment of items.
       * Same allowed values as `x`. Default: 'start'.
       */
      y: {
        type: "string",
        empty: "start",
        /** @type {'start'|'center'|'end'|'between'|'around'|'stretch'|'baseline'} */
        value: "start"
      },
      /** Gap between children. Accepts preset numeric strings (e.g. '8') mapped to px, or floats. */
      gap: "float",
      /** Padding preset or numeric value (e.g. 'pane', '8', '16'). */
      padding: "string"
    }).css`
      /* https://css-tricks.com/snippets/css/a-guide-to-flexbox/ */

      :host{
        display: flex;
        flex-direction: column;

        box-sizing: border-box;

      }

      :host(:is([inline])) {
        display: inline-flex;
      }

      :host(:is([block])) {
        display: block;
      }
      
      
      :host(:is([inline][block])) {
        display: inline-block;
      }

      :host(:is([row])) {
        flex-direction: row;
      }

      :host(:is([row][y="start"], [x="start"]:not([row]))) {
        align-items: flex-start;
      }

      :host(:is([row][y="end"], [x="end"]:not([row]))) {
        align-items: flex-end;
      }

      :host(:is([row][y="center"], [x="center"]:not([row]))) {
        align-items: center;
      }

      :host(:is([row][y="between"], [x="between"]:not([row]))) {
        align-items: space-between;
      }

      :host(:is([row][y="around"], [x="around"]:not([row]))) {
        align-items: space-around;
      }

      :host(:is([row][y="baseline"], [x="baseline"]:not([row]))) {
        align-items: baseline;
      }

      :host(:is([row][y="stretch"], [x="stretch"]:not([row]))) {
        align-items: stretch;
      }

      :host(:is([row][x="start"], [y="start"]:not([row]))) {
        justify-content: flex-start;
      }

      :host(:is([row][x="end"], [y="end"]:not([row]))) {
        justify-content: flex-end;
      }

      :host(:is([row][x="center"], [y="center"]:not([row]))) {
        justify-content: center;
      }

      :host(:is([row][x="between"], [y="between"]:not([row]))) {
        justify-content: space-between;
      }

      :host(:is([row][x="stretch"], [y="stretch"]:not([row]))) {
        justify-content: stretch;
      }

      :host(:is([wrap])) {
        flex-wrap: wrap;
      }

      :host(:is([wrap="reverse"])) {
        flex-wrap: wrap-reverse;
      }

      :host(:is([gap])) {gap: 0;}
      :host(:is([gap="4"])) {gap: 4px;}
      :host(:is([gap="8"])) {gap: 8px;}
      :host(:is([gap="12"])) {gap: 12px;}
      :host(:is([gap="16"])) {gap: 16px;}
      :host(:is([gap="20"])) {gap: 20px;}
      :host(:is([gap="24"])) {gap: 24px;}

      :host(:is([padding])) {padding: 0;}
      :host(:is([padding="pane"])) { padding-inline: var(--mdw-pane__padding-inline, 0) }
      :host(:is([padding="4"])) {padding: 4px;}
      :host(:is([padding="8"])) {padding: 8px;}
      :host(:is([padding="12"])) {padding: 12px;}
      :host(:is([padding="16"])) {padding: 16px;}
      :host(:is([padding="20"])) {padding: 20px;}
      :host(:is([padding="24"])) {padding: 24px;}
      :host(:is([padding-x])) {padding-inline: 0;}
      :host(:is([padding-x="4"])) {padding-inline: 4px;}
      :host(:is([padding-x="8"])) {padding-inline: 8px;}
      :host(:is([padding-x="12"])) {padding-inline: 12px;}
      :host(:is([padding-x="16"])) {padding-inline: 16px;}
      :host(:is([padding-x="20"])) {padding-inline: 20px;}
      :host(:is([padding-x="24"])) {padding-inline: 24px;}
      :host(:is([padding-y])) {padding-block: 0;}
      :host(:is([padding-y="4"])) {padding-block: 4px;}
      :host(:is([padding-y="8"])) {padding-block: 8px;}
      :host(:is([padding-y="12"])) {padding-block: 12px;}
      :host(:is([padding-y="16"])) {padding-block: 16px;}
      :host(:is([padding-y="20"])) {padding-block: 20px;}
      :host(:is([padding-y="24"])) {padding-block: 24px;}

      
    `;
  }

  // components/Surface.js
  var Surface_default = CustomElement.extend().mixin(ThemableMixin).mixin(FlexableMixin).mixin(ElevationMixin).mixin(ShapeMixin).html`<slot id=slot></slot>`.css`
    :host {
      --mdw-bg: var(--mdw-color__surface);
      --mdw-ink: var(--mdw-color__on-surface);
      position: relative;

      filter: var(--mdw-elevation__drop-shadow__0);
    
      background-color: rgb(var(--mdw-bg));
      color: rgb(var(--mdw-ink));
    
      font: var(--mdw-type__font);
      letter-spacing: var(--mdw-type__letter-spacing);

      transition: filter 200ms;
    }

    :host(:where([elevation="1"])) { filter: var(--mdw-elevation__drop-shadow__1); }
    :host(:where([elevation="2"])) { filter: var(--mdw-elevation__drop-shadow__2); }
    :host(:where([elevation="3"])) { filter: var(--mdw-elevation__drop-shadow__3); }
    :host(:where([elevation="4"])) { filter: var(--mdw-elevation__drop-shadow__4); }
    :host(:where([elevation="5"])) { filter: var(--mdw-elevation__drop-shadow__5); }
  `.autoRegister("mdw-surface");

  // components/Box.js
  var Box_default = CustomElement.extend().mixin(ThemableMixin).mixin(FlexableMixin).html`<slot id=slot></slot>`.css`
    :host(:where([color])) {
      background-color: rgb(var(--mdw-bg));
      color: rgb(var(--mdw-ink));
    }

    :host(:is([color="none"],[color="transparent"])) {
      background-color: transparent;
      color: inherit;
    }
    
    :host([ink]) {
      color: rgb(var(--mdw-ink));
    }
    
    :host([type-style]) {
      font: var(--mdw-type__font);
      letter-spacing: var(--mdw-type__letter-spacing);
    }

    #slot::slotted([flex-0]) {
      flex: 0;
    }

    #slot::slotted([flex-1]) {
      flex: 1;
    }

    #slot::slotted([flex-none]) {
      flex: none;
    }
  `.autoRegister("mdw-box");

  // components/CheckboxIcon.js
  var CheckboxIcon_default = CustomElement.extend().mixin(ThemableMixin).mixin(ShapeMixin).observe({
    /** Whether the icon is selected (checked). */
    selected: "boolean",
    /** Icon name to render inside the checkbox icon. */
    icon: "string",
    /** Whether the associated control is in an error state. */
    errored: "boolean",
    /** Whether the associated control is disabled. */
    disabled: "boolean"
  }).define({
    /** Alias for `selected` (quality-of-life property). */
    checked: {
      get() {
        return this.selected;
      },
      set(value) {
        this.selected = value;
      }
    }
  }).css`
    :host {
      --mdw-ink: var(--mdw-color__on-primary);
      --mdw-bg: var(--mdw-color__primary);
      --mdw-shape__size: 2px;
      --disabled-opacity: 0.38;
      position: relative;

      display: inline-block;
      align-items: center;
      justify-content: center;

      box-sizing: border-box;
      block-size: 18px;
      inline-size: 18px;

      font-size: 18px;
      line-height: 18px;
    }

    #icon {
      position: absolute;
      inset: 0;

      opacity: 0;

      background-color: rgb(var(--mdw-bg));
      border-radius: inherit;
      color: rgb(var(--mdw-ink));

      transition-duration: 200ms;
      transition-property: opacity, background-color, color;
      will-change: opacity;
    }

    #outline {
      border-width: 2px;

      color: rgb(var(--mdw-color__on-surface));

      transition-duration: 200ms;
      transition-property: opacity, background-color, color;
      will-change: opacity;
    }

    /* Selected */

    #icon[selected] {
      opacity: 1;
    }

    #outline[selected] {
      opacity: 0;
    }

    /* Errored */

    #icon[errored] {
      background-color: rgb(var(--mdw-color__error));
      color: rgb(var(--mdw-color__on-error));
    }

    #outline[errored] {
      color: rgb(var(--mdw-color__error));
    }

    /* Disabled */

    #icon[disabled] {
      background-color: rgba(var(--mdw-color__on-surface), var(--disabled-opacity));
      color: rgb(var(--mdw-color__surface), var(--disabled-opacity));
    }

    #outline[disabled] {
      color: rgb(var(--mdw-color__on-surface), var(--disabled-opacity));
    }
  `.html`
    <mdw-icon id=icon selected={selected} errored={errored} disabled={disabled} icon={icon}></mdw-icon>
  `.recompose(({ refs: { outline } }) => {
    outline.removeAttribute("mdw-if");
    outline.setAttribute("selected", "{selected}");
    outline.setAttribute("errored", "{errored}");
    outline.setAttribute("disabled", "{disabled}");
  }).autoRegister("mdw-checkbox-icon");

  // mixins/TouchTargetMixin.js
  function TouchTargetMixin(Base) {
    return Base.html`<div id=touch-target class=touch-target></div>`.css`
        /* stylelint-disable liberty/use-logical-spec */
      .touch-target {
        position: absolute;
        top: 50%;
        left: 50%;
        /* --mdw-device-pixel-ratio: 1; */
      
        block-size: 100%;
        min-block-size: 48px;
        /* min-block-size: 10mm; */
        /* min-block-size: calc(0.393701in / var(--mdw-device-pixel-ratio, 1)); */
        inline-size:100%;
        min-inline-size: 48px;
        /* min-inline-size: 10mm; */
        /* min-inline-size: calc(0.393701in / var(--mdw-device-pixel-ratio, 1)); */
      
        cursor: inherit;
      
        /* box-sizing: border-box; */
        /* border: solid 1px magenta; */
        pointer-events: auto;
      
        transform: translateX(-50%) translateY(-50%);
        visibility: inherit;
        z-index: 1;
      
        border-radius: inherit;
      }
    `;
  }

  // components/Checkbox.js
  var Checkbox_default = CustomElement.extend().mixin(ThemableMixin).mixin(StateMixin).mixin(RippleMixin).mixin(InputMixin).mixin(TouchTargetMixin).set({
    /** Whether the element renders a state layer for interaction feedback. */
    stateLayer: true,
    /** The underlying control input `type` value. */
    type: "checkbox"
  }).observe({
    /** Icon name to show for the checked state. */
    icon: { value: "check" },
    /** Icon name to show when the control is indeterminate. */
    indeterminateIcon: { value: "check_indeterminate_small" }
  }).expressions({
    _determinateIcon({ indeterminate, indeterminateIcon, icon }) {
      return indeterminate ? indeterminateIcon : icon;
    },
    _iconSelectedState({ checked, indeterminate }) {
      return checked || indeterminate;
    }
  }).html`
    <div id=checkbox errored={erroredState} selected={checked}>
      <mdw-checkbox-icon id=icon errored={erroredState} disabled={disabledState}
        icon={_determinateIcon} selected={_iconSelectedState}>
      </mdw-checkbox-icon>
    </div>
    <slot id=slot></slot>
  `.recompose(({ refs: { checkbox, state, rippleContainer } }) => {
    checkbox.append(state, rippleContainer);
  }).css`
    /* https://m3.material.io/components/checkbox/specs */

    :host {
      --mdw-ink: var(--mdw-color__on-primary);
      --mdw-bg: var(--mdw-color__primary);

      display: inline-grid;
      align-items: baseline;
      gap: 12px;
      grid-auto-flow: column;
      justify-content: flex-start;

      cursor: pointer;

      transition: none 100ms cubic-bezier(0.4, 0.0, 1, 1);
    }

    :host(:disabled) {
      cursor: not-allowed;

      opacity: 0.38;
    }

    :host([internals-disabled]) {
      cursor: not-allowed;

      opacity: 0.38;
    }

    :host(:empty) {
      vertical-align: -11.5%;

      line-height: 18px;
    }

    #control {
      grid-column: 1/1;

      cursor: inherit;
    }

    #state,
    #ripple-container {
      /* stylelint-disable-next-line liberty/use-logical-spec */
      top: 50%;
      /* stylelint-disable-next-line liberty/use-logical-spec */
      left: 50%;

      block-size: 40px;
      inline-size: 40px;

      transform: translateX(-50%) translateY(-50%);

      border-radius: 50%;
    }

    #checkbox {
      position: relative;

      display: inline-flex;

      grid-column: 1 / 1;

      pointer-events: none;

      transform: translateY(11.5%);

      color: rgb(var(--mdw-color__on-surface));
    }

    #checkbox[selected] {
      color: rgb(var(--mdw-bg));
    }

    #checkbox[disabled] {
      color: rgb(var(--mdw-color__on-surface));
    }

    #checkbox[errored] {
      color: rgb(var(--mdw-color__error));
    }

    :host(:empty) #checkbox {
      transform: none;
    }

    #icon {
      --mdw-ink: inherit;
      --mdw-bg: inherit;
      --disabled-opacity: 1;
    }
  `.autoRegister("mdw-checkbox");

  // components/Card.js
  var SUPPORTS_INERT = "inert" in HTMLElement.prototype;
  var Card_default = Box_default.extend().mixin(StateMixin).mixin(ElevationMixin).mixin(ShapeMixin).mixin(FormAssociatedMixin).mixin(AriaReflectorMixin).mixin(DelegatesFocusMixin).mixin(HyperlinkMixin).set({
    _ariaRole: "figure"
  }).observe({
    /** Whether the card displays an elevated surface. */
    elevated: "boolean",
    /** Whether the card uses a filled surface style. */
    filled: "boolean",
    /** When true, card renders an actionable control (clickable). */
    actionable: "boolean",
    /** Label for the action control used for accessibility. */
    actionLabel: "string",
    /** Event handler called when the card action is triggered. */
    onaction: EVENT_HANDLER_TYPE
  }).define({
    /**
     * Element used as the target for state styling (pressed/focus).
     * Returns the internal action control when actionable, otherwise the host.
     * @return {HTMLElement}
     */
    stateTargetElement() {
      return this.actionable ? this.refs.action : this;
    }
  }).expressions({
    showBlocker: ({ disabledState, disabled }) => disabledState && (!disabled || !SUPPORTS_INERT),
    showButton: ({ actionable, href }) => Boolean(actionable || href)
  }).methods({
    /**
     * Focuses the internal action control if the card is actionable and not disabled.
     * @return {void}
     */
    focus() {
      if (this.disabledState) return;
      if (!this.actionable) return;
      this.refs.action.focus();
    }
  }).html`
    <mdw-button mdw-if={showButton} aria-label={actionLabel} href={href}
      target={target}
      download={download}
      ping={ping}
      rel={rel}
      hreflang={hreflang}
      referrerpolicy={referrerPolicy} id=action disabled={disabledState}></mdw-button>
    <div mdw-if={showBlocker} id=inert-blocker></div>
  `.recompose(({ refs: { anchor, inertBlocker, slot } }) => {
    anchor.remove();
    slot.setAttribute("disabled", "{disabledState}");
    inertBlocker.before(slot);
  }).css`
    :host {
      --mdw-shape__size: var(--mdw-shape__medium);

      /* padding-inline: 12px; */

      --mdw-bg: var(--mdw-color__surface);
      --mdw-ink: var(--mdw-color__on-surface);
      position: relative;

      font: var(--mdw-type__font);
      letter-spacing: var(--mdw-type__letter-spacing);

      transition: filter 200ms;
      will-change: filter;
    }

    :host(:where([elevated],[filled],[outlined])) {
      background-color: rgb(var(--mdw-bg));
    }

    :host(:where([elevated])) {
      --mdw-bg: var(--mdw-color__surface-container-low);
      --mdw-ink: var(--mdw-color__on-surface);
      filter: var(--mdw-elevation__drop-shadow__1);
    }

    :host(:where([filled])) {
      --mdw-bg: var(--mdw-color__surface-container-highest);
      --mdw-ink: var(--mdw-color__on-surface-variant);
    }

    :host(:where([filled][actionable])) {
      filter: var(--mdw-elevation__drop-shadow__0);
    }

    :host(:where([elevated][actionable]:hover:not(:active))) {
      filter: var(--mdw-elevation__drop-shadow__2);
    }

    :host(:where([filled][actionable]:hover:not(:active))) {
      filter: var(--mdw-elevation__drop-shadow__1);
    }

    :host([disabled]) {
      cursor: not-allowed;

      filter: grayscale();
      opacity: 0.38;

      color: rgb(var(--mdw-color__on-surface));
    }

    #slot[disabled] {
      color: rgb(var(--mdw-color__on-surface));
    }

    #outline[disabled] {
      color: rgba(var(--mdw-color__on-surface), calc(0.12/0.38));
    }

    /** Firefox and Safari do not support [inert] */

    #inert-blocker {
      position: absolute;
      inset: 0;

      cursor: not-allowed;
      pointer-events: auto;

      z-index: 99;
    }

    :host([disabled][elevated]) {
      background-color: rgba(var(--mdw-color__surface-container-highest));
    }

    :host([disabled][filled]) {
      background-color: rgba(var(--mdw-color__surface));
    }

    #action {
      --mdw-ink: inherit;
      --mdw-shape__size: inherit;

      position: absolute;
      inset: 0;

      padding: 0;

      z-index: 0;

      color: inherit
    }
  `.recompose(({ refs: { slot, outline } }) => {
    outline.removeAttribute("pressed");
    outline.removeAttribute("focused");
    slot.setAttribute("inert", "{disabledState}");
    slot.setAttribute("disabled", "{disabledState}");
  }).childEvents({
    action: {
      click() {
        if (this.disabledState) return;
        this.dispatchEvent(new Event("action"));
      }
    },
    slot: SUPPORTS_INERT ? {} : {
      focusin() {
        if (this.disabledState) {
          console.warn("Inert not supported. Element should be able to receive focus");
        }
      }
    }
  }).autoRegister("mdw-card");

  // mixins/TypographyMixin.js
  function parseSize(input) {
    if (!input) return "";
    if (input.includes("px")) return input;
    if (input.includes("em")) return input;
    if (input.includes("ex")) return input;
    return `calc(${input.replace("sp", "")} * 0.0625rem)`;
  }
  function TypographyMixin(Base) {
    return Base.mixin(DelegatesFocusMixin).observe({
      /** General vertical padding for text content (css length) */
      textPadding: "string",
      /** Padding-top override for text content (css length) */
      textPaddingTop: "string",
      /** Line-leading (extra top spacing) for text (css length or 'sp' units) */
      textLeading: "string",
      /** Padding-bottom override for text content (css length) */
      textPaddingBottom: "string"
    }).observe({
      _computedTextPaddingTop({ textPaddingTop, textPadding }) {
        return parseSize(textPaddingTop ?? textPadding);
      },
      _computedTextPaddingBottom({ textPaddingBottom, textPadding }) {
        return parseSize(textPaddingBottom ?? textPadding);
      },
      _computedTextLeading({ textLeading }) {
        return parseSize(textLeading);
      }
    }).observe({
      _beforeStyle({ _computedTextPaddingTop, _computedTextLeading }) {
        if (_computedTextLeading) {
          return `margin-top:${_computedTextLeading}`;
        }
        if (_computedTextPaddingTop) {
          return `margin-top:${_computedTextPaddingTop}`;
        }
        return "";
      },
      _afterStyle({ _computedTextPaddingBottom }) {
        if (_computedTextPaddingBottom) {
          return `vertical-align:calc(-1em + (-1 * ${_computedTextPaddingBottom}));`;
        }
        return "";
      }
    }).html`
      <div id=wrapper style={_wrapperStyle} before={!!_beforeStyle} after={!!_afterStyle}
        ><span id=before mdw-if={!!_beforeStyle} style={_beforeStyle} text-leading={textLeading}></span
        ><span id=content before={!!_beforeStyle} after={!!_afterStyle}><span id=after mdw-if={!!_afterStyle} style={_afterStyle}></span></span
      ></div>
      `.recompose(({ refs: { content, slot } }) => {
      content.prepend(slot);
    }).css`
      :host {
        display: block;
      }

      :host(:where([text-padding],[text-padding-top],[text-padding-bottom])) {
        display: flex;
      }

      #wrapper {
        display: contents;

      }
      
      #wrapper:where([before], [after]) {
        display: flex;
        align-items: baseline; /* Allows growing element upwards without affecting text selection */

      }

      #wrapper[before] {
        margin-block-start: -1em;
      }

      #wrapper[after] {
        margin-block-end: -1em;
      }

      #before {
        display: inline-block;

        block-size: 1.4ex; /* Estimate */
        padding-block-start: 1em; /* Padding to be cropped by wrapper */
      }
      @supports(height:1cap) {
        #before {
          block-size: 1cap;
        }
      }

      #before[text-leading] {
        block-size: 0;
      }

      #content {
        display: contents;
      }
      
      #content:where([before], [after]) {
        display: block;
      }

      #after {
        display: inline-block;

        padding-block-end: 1em; /* Padding to be cropped by wrapper */
      }

    `;
  }

  // components/Label.js
  var Label_default = Box_default.extend().mixin(TypographyMixin).css`
    :host {
      font: var(--mdw-typescale__label-large__font);
      letter-spacing: var(--mdw-typescale__body-large__letter-spacing);
    }
    
    :host([size="medium"]) {
      font: var(--mdw-typescale__label-medium__font);
      letter-spacing: var(--mdw-typescale__body-medium__letter-spacing);
    }
    
    :host([size="small"]) {
      font: var(--mdw-typescale__label-small__font);
      letter-spacing: var(--mdw-typescale__body-small__letter-spacing);
    }
  `.autoRegister("mdw-label");

  // demo/sample/ProductPage.js
  var ProductPage_default = Card_default.extend().observe({
    title: "string",
    productId: {
      type: "integer",
      empty: 1
    },
    busy: {
      type: "boolean",
      reflect: false,
      empty: true
    },
    data: {
      type: "object",
      reflect: false,
      /** @type {SAMPLE_DATA} */
      value: null
    },
    lastObject: "object"
  }).observe({
    // Nested array need own observable
    _images({ data }) {
      return (data == null ? void 0 : data.images) || [];
    }
  }).set({
    /** @type {number} */
    lastFetchedId: null,
    /** @type {AbortController} */
    fetchAbortController: null,
    // Override Card defaults
    outlined: true
  }).expressions({
    // Automatically tracks data change
    hasStock({ data }) {
      return (data == null ? void 0 : data.stock) > 0;
    }
  }).css`
    :host {
      /* Time until busy styles show */
      --busy-delay: 500ms;
    }

    #overlay {
      position: absolute;
      inset: 0;

      display: flex;
      align-items: center;
      justify-content: center;

      opacity: 0;
      visibility: hidden;
      z-index:5;

      transition-duration: 200ms;
      transition-property: visibility, opacity;
    }

    #overlay[busy] {
      pointer-events: auto;
      
      opacity: 1;
      visibility: inherit;

      transition-delay: var(--busy-delay);
    }

    #content {
      transition: filter 200ms;
    }

    #content[busy] {
      filter: blur(2px) grayscale(1);

      transition-delay: var(--busy-delay);
    }

    #form {
      position: relative;

      overflow: hidden;
    }

    #thumbnail-shape {
      overflow: hidden;

      block-size: 128px;
      min-block-size: 128px;
      inline-size: 128px;
      min-inline-size: 128px;
    }

    #thumbnail {
      block-size: 100%;
      inline-size: 100%;

      object-fit: cover;
    }
    fieldset{ display: contents;}

    #images {
      display: grid;
      align-items: center;
      column-gap: 24px;
      grid-auto-flow: column;
      grid-template-rows: minmax(auto, 200px);
      justify-items: center;
      overflow-x: auto;
      scroll-behavior: smooth;
      scroll-snap-type: x mandatory;
      scrollbar-width: none;

      flex-grow: 1;
      padding-inline: 24px;
      -webkit-scroll-snap-type-x: mandatory;
      scroll-snap-type-x: mandatory;
      -webkit-scroll-snap-points-x: repeat(100%);
      scroll-snap-points-x: repeat(100%);
      overscroll-behavior-x: none;
    }

    .image {
      scroll-snap-align: center;

      max-block-size: 100%;

      object-fit: contain;
    }
  `.html`
    <form id=form>
      <!-- Binding to enumerable observable (busy) -->
      <div id=overlay busy={busy}>
        <mdw-progress circle></mdw-progress>
      </div>
      <div id=content busy={busy}>
        <fieldset disabled={busy}>
          <mdw-box row y=center gap=16 padding=16>
            <mdw-surface id=thumbnail-shape outlined shape-style=full>
              <img id=thumbnail src={data.thumbnail} />
            </mdw-surface>
            <div>
              <!-- Binding to nested variable (data.*) -->
              <mdw-title>{data.title}</mdw-title>
              <mdw-label ink=primary size=small>{data.brand}</mdw-label>
              <mdw-title size=small>{data.description}</mdw-title>
            </div>
          </mdw-box>
          <mdw-divider></mdw-divider>
          <mdw-box gap=16 padding=16>
            <mdw-input outlined type=number name=price value={data.price} label=Price input-prefix=$ step=0.01></mdw-input>
            <mdw-input outlined type=number name=discountPercentage value={data.discountPercentage} input-suffix=% label=Discount step=0.01></mdw-input>
            <mdw-slider name=rating value={data.rating} min=0 max=5 step=0.1 ticks=4></mdw-slider>
            <mdw-box row y=center gap=8>
                <mdw-checkbox-icon icon=check selected={hasStock}></mdw-checkbox-icon> Stock: {data.stock} </div>
            <mdw-box>
          </mdw-box>
          <mdw-divider></mdw-divider>
          <div id=images>
            <!-- mdw-if may remove element from DOM -->
            <mdw-label mdw-if={!_images.length}>(No images available)</mdw-label>
            <!-- mdw-for creates a sub-observable -->
            <img mdw-for="{image of _images}" class="image" src={image} />
          </div>
        </fieldset>
      </div>
    </form>
    <mdw-divider></mdw-divider>
    <mdw-box row x=between y=center padding=8 gap=8>
      <mdw-title ink=secondary>Product ID: {productId}</mdw-title>
      <mdw-box row gap=8>
        <!-- Inline attribute expression and event listener -->
        <mdw-icon-button
          disabled="${({ productId }) => productId === 1}"
          id="previous"
          icon="chevron_left"
          on-click="${function onClick() {
    this.productId--;
  }}">Previous</mdw-icon-button>
        <!-- Inline event listener -->
        <mdw-icon-button
          on-click=${function onClick2() {
    this.productId++;
  }}
          id=next
          icon=chevron_right>Next</mdw-icon-button>
        </mdw-box>
    </mdw-box>

  `.methods({
    async refresh() {
      var _a5;
      const productId = this.productId;
      (_a5 = this.fetchAbortController) == null ? void 0 : _a5.abort();
      const controller = new AbortController();
      this.fetchAbortController = controller;
      try {
        this.busy = true;
        const response = await fetch(`https://dummyjson.com/products/${productId}`, { signal: this.fetchAbortController.signal });
        const json = await response.json();
        this.data = json;
        this.refs.form.reset();
        this.busy = false;
      } catch (e) {
        if (controller.signal.aborted) {
          console.log("Aborted");
        } else {
          console.error(e);
        }
      }
    }
  }).on({
    connected() {
      this.refresh();
    },
    // Automatically listen for changes to productId and refresh data
    productIdChanged() {
      this.refresh();
    }
  }).autoRegister("dummy-product-page");
  addSVGAlias("check", "M382 816 154 588l57-57 171 171 367-367 57 57-424 424Z", "0 96 960 960");
  addSVGAlias("chevron_left", "M560 816 320 576l240-240 56 56-184 184 184 184-56 56Z", "0 96 960 960");
  addSVGAlias("chevron_right", "m376 816-56-56 184-184-184-184 56-56 240 240-240 240Z", "0 96 960 960");

  // demo/sample/sample.js
  ProductPage_default.autoRegister();
})();
//# sourceMappingURL=sample.min.js.map
